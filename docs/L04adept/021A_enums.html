<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>Enums! - Learn Programming with Rust as a first language</title>


    <!-- Custom HTML head -->
    
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="icon" href="../favicon.svg">
    <link rel="shortcut icon" href="../favicon.png">
    <link rel="stylesheet" href="../css/variables.css">
    <link rel="stylesheet" href="../css/general.css">
    <link rel="stylesheet" href="../css/chrome.css">
    <link rel="stylesheet" href="../css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="../fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="../highlight.css">
    <link rel="stylesheet" href="../tomorrow-night.css">
    <link rel="stylesheet" href="../ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    <link rel="stylesheet" href="../styles.css">

    <!-- MathJax -->
    <script async type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>

<body>
    <!-- Provide site root to javascript -->
    <script type="text/javascript">
        var path_to_root = "../";
        var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
    </script>

    <!-- Work around some values being stored in localStorage wrapped in quotes -->
    <script type="text/javascript">
        try {
            var theme = localStorage.getItem('mdbook-theme');
            var sidebar = localStorage.getItem('mdbook-sidebar');

            if (theme.startsWith('"') && theme.endsWith('"')) {
                localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
            }

            if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
            }
        } catch (e) { }
    </script>

    <!-- Set the theme before any content is loaded, prevents flash -->
    <script type="text/javascript">
        var theme;
        try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
        if (theme === null || theme === undefined) { theme = default_theme; }
        var html = document.querySelector('html');
        html.classList.remove('no-js')
        html.classList.remove('light')
        html.classList.add(theme);
        html.classList.add('js');
    </script>

    <!-- Hide / unhide sidebar before it is displayed -->
    <script type="text/javascript">
        var html = document.querySelector('html');
        var sidebar = 'hidden';
        if (document.body.clientWidth >= 1080) {
            try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
            sidebar = sidebar || 'visible';
        }
        html.classList.remove('sidebar-visible');
        html.classList.add("sidebar-" + sidebar);
    </script>

    <nav id="sidebar" class="sidebar" aria-label="Table of contents">
        <div class="sidebar-scrollbox">
            <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Introduction</a></li><li class="chapter-item expanded "><a href="../L01_starter.html"><strong aria-hidden="true">1.</strong> Level: Starter</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../L01starter/001A_first_language.html"><strong aria-hidden="true">1.1.</strong> Your first programming language</a></li><li class="chapter-item expanded "><a href="../L01starter/002A_books.html"><strong aria-hidden="true">1.2.</strong> Related books</a></li><li class="chapter-item expanded "><a href="../L01starter/003A_setup.html"><strong aria-hidden="true">1.3.</strong> Setting up the computer</a></li><li class="chapter-item expanded "><a href="../L01starter/004A_first_program.html"><strong aria-hidden="true">1.4.</strong> Your first program</a></li><li class="chapter-item expanded "><a href="../L01starter/005A_to_the_IDE.html"><strong aria-hidden="true">1.5.</strong> Quick, to the IDE!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../L01starter/005B_saving_progress.html"><strong aria-hidden="true">1.5.1.</strong> Saving our progress</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../L02_novice.html"><strong aria-hidden="true">2.</strong> Level: Novice</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../L02novice/006A_recipes.html"><strong aria-hidden="true">2.1.</strong> It's like cooking recipes, seriously</a></li><li class="chapter-item expanded "><a href="../L02novice/007A_little_boxes.html"><strong aria-hidden="true">2.2.</strong> Variables are like little boxes that store things inside</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../L02novice/007B_ex_print_format.html"><strong aria-hidden="true">2.2.1.</strong> Exercise: Printing and Formatting</a></li></ol></li><li class="chapter-item expanded "><a href="../L02novice/007C_fun_with_libs.html"><strong aria-hidden="true">2.3.</strong> Having fun with libraries</a></li><li class="chapter-item expanded "><a href="../L02novice/008A_declaring.html"><strong aria-hidden="true">2.4.</strong> Declaring variables</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../L02novice/008B_ex_variables.html"><strong aria-hidden="true">2.4.1.</strong> Exercise: Variables</a></li><li class="chapter-item expanded "><a href="../L02novice/008C_turtle.html"><strong aria-hidden="true">2.4.2.</strong> Let's try Turtle!</a></li></ol></li><li class="chapter-item expanded "><a href="../L02novice/009A_incrementing.html"><strong aria-hidden="true">2.5.</strong> Incrementing and decrementing</a></li><li class="chapter-item expanded "><a href="../L02novice/010A_looping.html"><strong aria-hidden="true">2.6.</strong> Looping' around</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../L02novice/010B_ex_loops.html"><strong aria-hidden="true">2.6.1.</strong> Exercise: loops</a></li><li class="chapter-item expanded "><a href="../L02novice/010C_turtle_loops.html"><strong aria-hidden="true">2.6.2.</strong> Turtle: loops</a></li></ol></li><li class="chapter-item expanded "><a href="../L02novice/011A_comments.html"><strong aria-hidden="true">2.7.</strong> Adding some comments</a></li><li class="chapter-item expanded "><a href="../L02novice/012A_ifs.html"><strong aria-hidden="true">2.8.</strong> What If…?</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../L02novice/012B_ex_ifs.html"><strong aria-hidden="true">2.8.1.</strong> Exercise: conditionals</a></li></ol></li><li class="chapter-item expanded "><a href="../L02novice/013A_loops_again.html"><strong aria-hidden="true">2.9.</strong> For loops again!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../L02novice/013B_other_loops.html"><strong aria-hidden="true">2.9.1.</strong> Other types of loops</a></li><li class="chapter-item expanded "><a href="../L02novice/013C_turtle_loops.html"><strong aria-hidden="true">2.9.2.</strong> Turtle: Improving with loops</a></li><li class="chapter-item expanded "><a href="../L02novice/013D_turtle_spiral.html"><strong aria-hidden="true">2.9.3.</strong> Turtle: Making a spiral</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../L03_apprentice.html"><strong aria-hidden="true">3.</strong> Level: Apprentice</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../L03apprentice/014A_functions.html"><strong aria-hidden="true">3.1.</strong> Introducing Functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../L03apprentice/014B_func_return.html"><strong aria-hidden="true">3.1.1.</strong> Returning values from functions</a></li><li class="chapter-item expanded "><a href="../L03apprentice/014C_func_args.html"><strong aria-hidden="true">3.1.2.</strong> Function arguments</a></li></ol></li><li class="chapter-item expanded "><a href="../L03apprentice/015A_data_types.html"><strong aria-hidden="true">3.2.</strong> Data types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../L03apprentice/015B_rust_types.html"><strong aria-hidden="true">3.2.1.</strong> Rust data types</a></li></ol></li><li class="chapter-item expanded "><a href="../L03apprentice/016A_typedvars.html"><strong aria-hidden="true">3.3.</strong> Back to declaring variables… with type</a></li><li class="chapter-item expanded "><a href="../L03apprentice/016B_dbg_format.html"><strong aria-hidden="true">3.4.</strong> dbg!() and format!()</a></li><li class="chapter-item expanded "><a href="../L03apprentice/017A_conversions.html"><strong aria-hidden="true">3.5.</strong> Converting types with explicit conversions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../L03apprentice/017B_ex_conversions.html"><strong aria-hidden="true">3.5.1.</strong> Exercise: explicit conversions</a></li></ol></li><li class="chapter-item expanded "><a href="../L03apprentice/018A_strings_intro.html"><strong aria-hidden="true">3.6.</strong> A tiny bit on strings</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../L03apprentice/018B_strings_and_str.html"><strong aria-hidden="true">3.6.1.</strong> Simple explanation on &str vs String</a></li></ol></li><li class="chapter-item expanded "><a href="../L03apprentice/X03A_funcs_revisited.html"><strong aria-hidden="true">3.7.</strong> A bit more detailed explanation on functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../L03apprentice/014D_closures.html"><strong aria-hidden="true">3.7.1.</strong> Closures</a></li></ol></li><li class="chapter-item expanded "><a href="../L03apprentice/020A_proj_game_macroquad.html"><strong aria-hidden="true">3.8.</strong> Project: A simple game with Macroquad</a></li></ol></li><li class="chapter-item expanded "><a href="../L04_adept.html"><strong aria-hidden="true">4.</strong> Level: Adept</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.</strong> const and static</div></li><li class="chapter-item expanded "><a href="../L04adept/020A_structs.html"><strong aria-hidden="true">4.2.</strong> Not everything are numbers and texts: Structs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../L04adept/020B_struct_impl.html"><strong aria-hidden="true">4.2.1.</strong> Struct-specific functions, really?</a></li><li class="chapter-item expanded "><a href="../L04adept/020C_oop.html"><strong aria-hidden="true">4.2.2.</strong> OOP? More like OP</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.2.3.</strong> What are objects and instances</div></li></ol></li><li class="chapter-item expanded "><a href="../L04adept/021A_enums.html" class="active"><strong aria-hidden="true">4.3.</strong> Enums!</a></li><li class="chapter-item expanded "><a href="../L04adept/022A_match.html"><strong aria-hidden="true">4.4.</strong> Match!</a></li><li class="chapter-item expanded "><a href="../L04adept/023A_float_gotchas.html"><strong aria-hidden="true">4.5.</strong> Floating point gotchas</a></li><li class="chapter-item expanded "><a href="../L04adept/024A_modules.html"><strong aria-hidden="true">4.6.</strong> Modules - splitting files</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.7.</strong> Contracts in programming</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.8.</strong> Data Structures</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.8.1.</strong> Lists</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.8.2.</strong> Tuples</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.8.3.</strong> Slices</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.8.4.</strong> HashMaps</div></li></ol></li><li class="chapter-item expanded "><a href="../L04adept/023A_proj_game_ggez.html"><strong aria-hidden="true">4.9.</strong> Project: A simple game with ggez</a></li></ol></li><li class="chapter-item expanded "><a href="../L05_master.html"><strong aria-hidden="true">5.</strong> Level: Master</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../L05master/X02A_datatypes.html"><strong aria-hidden="true">5.1.</strong> What are those other data types for?</a></li><li class="chapter-item expanded "><a href="../L05master/023A_borrowing.html"><strong aria-hidden="true">5.2.</strong> Borrowing</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> Lifetimes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.4.</strong> What it made it "click" for me - memory allocation</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.</strong> Generic parameters</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.6.</strong> Data Structures</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.6.1.</strong> Lists again!</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.6.1.1.</strong> Deques and ring buffers</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.6.2.</strong> HashMaps again!</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.6.2.1.</strong> HashSets, what?</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.6.3.</strong> The infamous linked list</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.6.4.</strong> Trees</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.6.5.</strong> Heaps</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.7.</strong> Algorithms</div></li></ol></li><li class="chapter-item expanded "><a href="../L06_grandmaster.html"><strong aria-hidden="true">6.</strong> Level: Grand Master</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> A glance over macros</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Polymorphism (Traits)</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> Functional programming</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.1.</strong> Iterators</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.4.</strong> Smart Pointers</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.4.1.</strong> Box</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.4.2.</strong> Rc</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.4.3.</strong> RefCell</div></li></ol></li><li class="chapter-item expanded "><a href="../L06grandmaster/X04A_garbage_collector.html"><strong aria-hidden="true">6.5.</strong> What is a Garbage Collector?</a></li></ol></li><li class="chapter-item expanded "><a href="../L07_legendary.html"><strong aria-hidden="true">7.</strong> Level: Legendary</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">7.1.</strong> Polymorphism (dyn Box)</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.2.</strong> No Size? ?Sized</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.3.</strong> Threading</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">7.3.1.</strong> Mutexes/Locks</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.3.2.</strong> Atomics</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.4.</strong> Async</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.5.</strong> Databases and SQL</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">7.5.1.</strong> What about NoSQL?</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.6.</strong> Web applications!</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">7.6.1.</strong> HTML+CSS+JS in one shot</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.6.2.</strong> Web servers</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.6.3.</strong> REST services</div></li><li class="spacer"></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../X01A_TODO.html"><strong aria-hidden="true">8.</strong> To-do: pieces that need more work</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="../Y01A_appendices.html"><strong aria-hidden="true">9.</strong> Appendices</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../Y02A_license.html"><strong aria-hidden="true">9.1.</strong> Appendix A. License of this book</a></li><li class="chapter-item expanded "><a href="../Y03A_caveats.html"><strong aria-hidden="true">9.2.</strong> Appendix B. Caveats and challenges in this book</a></li><li class="chapter-item expanded "><a href="../Y04A_solutions.html"><strong aria-hidden="true">9.3.</strong> Appendix C. Exercises and Solutions</a></li><li class="chapter-item expanded "><a href="../Y05A_projects.html"><strong aria-hidden="true">9.4.</strong> Appendix D. Proposed projects</a></li><li class="chapter-item expanded "><a href="../Y06A_rust_compared.html"><strong aria-hidden="true">9.5.</strong> Appendix E. Rust compared to other languages</a></li></ol></li></ol>
        </div>
        <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
    </nav>

    <div id="page-wrapper" class="page-wrapper">

        <div class="page">
                        <div id="menu-bar-hover-placeholder"></div>
            <div id="menu-bar" class="menu-bar sticky bordered">
                <div class="left-buttons">
                    <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                        aria-label="Toggle Table of Contents" aria-controls="sidebar">
                        <i class="fa fa-bars"></i>
                    </button>
                    <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                        aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                        <i class="fa fa-paint-brush"></i>
                    </button>
                    <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                        <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button>
                        </li>
                    </ul>
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                        aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                        aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
                </div>

                <h1 class="menu-title">🦀 Learn Programming with Rust as a first language</h1>

                <div class="right-buttons">
                    <a href="../print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>

                </div>
            </div>

            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                        aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>

            <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
            <script type="text/javascript">
                document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                    link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                });
            </script>

            <div id="content" class="content">
                <main>
                    <h1 id="enums"><a class="header" href="#enums">Enums!</a></h1>
<p>We just saw structs, where we could have a type that contains many things at 
a single time. Structs are one of the basic blocks of programming. Enums are
probably their other half.</p>
<p>Consider the following, what if instead of storing many things at a time, we
wanted to store one of several options?</p>
<p>For example, a type that could be either an integer or a string. But not both.</p>
<p>The usefulness of this, as usual, is hard to see initially. But examples will
follow soon!</p>
<h2 id="a-form-with-options"><a class="header" href="#a-form-with-options">A form with options</a></h2>
<p>Something that is easy to relate are real-world forms. Imagine you were trying
to get the bank to lend money to you, and they lend you a form.</p>
<p>In the form, the following appears:</p>
<blockquote>
<p>What is your current status?</p>
<ul>
<li>(_) Are you working?
<ul>
<li>Name of the company [_______]</li>
<li>Field / Type of company [______]</li>
<li>Type of contract?
(<em>) Permanent full time
(</em>) Permanent part-time
(_) Contractor</li>
</ul>
</li>
<li>(_) Are you studying?
<ul>
<li>Field of study [______]</li>
<li>Years in school [__]</li>
</ul>
</li>
<li>(_) Other, not studying or working.
<ul>
<li>Please specify [________]</li>
</ul>
</li>
</ul>
</blockquote>
<p>Or this:</p>
<blockquote>
<p>Marital Status:</p>
<ul>
<li>(_) Single</li>
<li>(_) Married</li>
<li>(_) Other</li>
</ul>
</blockquote>
<p>These “single choice” options can be represented as Enums.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum MaritalStatus {
    Single,
    Married,
    Other,
}
<span class="boring">}
</span></code></pre></pre>
<p>Then in code, we can choose one of the three options:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let status1 = MaritalStatus::Single;
let status2 = MaritalStatus::Married;
let status3 = MaritalStatus::Other;
<span class="boring">}
</span></code></pre></pre>
<p>Of course, you can put as many options as you want!</p>
<p>But, for “Other” we don’t really know what happened here, so we want to have
the user to specify what they meant by “Other”:</p>
<blockquote>
<p>Marital Status:</p>
<ul>
<li>(_) Single</li>
<li>(_) Married</li>
<li>(X) Other  [_________________]</li>
</ul>
</blockquote>
<p>In Rust, we do:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum MaritalStatus {
    Single,
    Married,
    Other(String),
}
<span class="boring">}
</span></code></pre></pre>
<p>Now, if we specify “Other” we need to put text with it:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let status3 = MaritalStatus::Other(&quot;divorced&quot;.to_string());
<span class="boring">}
</span></code></pre></pre>
<p>You can also have names and multiple values inside too:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum MaritalStatus {
    Single,
    Married,
    Other{ status: String, observations: String},
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let status3 = MaritalStatus::Other {
    status: &quot;divorced&quot;.to_string(),
    observations: &quot;in 2004&quot;.to_string(),
};
<span class="boring">}
</span></code></pre></pre>
<p>More complex enums are possible, as you can compose them with structs:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum ContractType {
    PermFullTime,
    PermPartTime,
    Contractor,
}

struct Work {
    company_name: String,
    field: String,
    contract_type: ContractType,
}

struct Study {
    field: String,
    years: i64,
}

enum CurrentStatus {
    Work,
    Study,
    Other { specify: String },
}
<span class="boring">}
</span></code></pre></pre>
<p>This reflects the earlier form:</p>
<blockquote>
<p>What is your current status?</p>
<ul>
<li>(_) Are you working?
<ul>
<li>Name of the company [_______]</li>
<li>Field / Type of company [______]</li>
<li>Type of contract?
(<em>) Permanent full time
(</em>) Permanent part-time
(_) Contractor</li>
</ul>
</li>
<li>(_) Are you studying?
<ul>
<li>Field of study [______]</li>
<li>Years in school [__]</li>
</ul>
</li>
<li>(_) Other, not studying or working.
<ul>
<li>Please specify [________]</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="enums-in-other-languages"><a class="header" href="#enums-in-other-languages">Enums in other languages</a></h2>
<p>In C++, Java and most other languages, enums are much simpler and can’t do
most of what Rust can.</p>
<p>In fact, they’re just a fancy way of creating constant values associated to
numbers.</p>
<p>Imagine we’re writing a library to open files, and we have a file mode:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum FileMode {
    Read,       // -&gt; 0
    Write,      // -&gt; 1
    ReadWrite,  // -&gt; 2
    Create,     // -&gt; 3
    Append,     // -&gt; 4
}
<span class="boring">}
</span></code></pre></pre>
<p>These are very similar to creating constants associated to numbers:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const READ: u16      = 0;
const WRITE: u16     = 1;
const READWRITE: u16 = 2;
const CREATE: u16    = 3;
const APPEND: u16    = 4;
<span class="boring">}
</span></code></pre></pre>
<p>Having an enum makes the creation simpler, and groups everything together nicely.</p>
<p>It starts counting at zero, but we can assign a particular number if we want. It
will continue counting from there:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum FileMode {
    Read = 12,  // -&gt; 12
    Write,      // -&gt; 13
    ReadWrite,  // -&gt; 14
    Create,     // -&gt; 15
    Append,     // -&gt; 16
}
<span class="boring">}
</span></code></pre></pre>
<p>If we have two numbers or more assigned, it works too:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum FileMode {
    Read = 12,  // -&gt; 12
    Write,      // -&gt; 13
    ReadWrite,  // -&gt; 14
    Create = 20,// -&gt; 20
    Append,     // -&gt; 21
}
<span class="boring">}
</span></code></pre></pre>
<p>In Rust, you can extract the actual number by casting to integer:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>dbg!(FileMode::ReadWrite as u16);
<span class="boring">}
</span></code></pre></pre>
<p>Another example:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Numbers {
    One = 1,        // -&gt;  1
    Two,            //     2
    Three,          //     3
    Four,           //     4

    FourtyTwo = 42, // -&gt; 42
    FourtyThree,    //    43
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="other-examples"><a class="header" href="#other-examples">Other examples</a></h2>
<p>Imagine a datatype called <code>When</code> that could take any of the following:</p>
<ul>
<li>“Tomorrow”: As in, the meeting will be tomorrow.</li>
<li>12 (hours): Even will happen in 12 hours.</li>
</ul>
<p>In a struct, the problem is that we must have two fields and one must remain
empty:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct When {
    name String,
    hours i64,
}
<span class="boring">}
</span></code></pre></pre>
<p>However, Rust doesn’t allow them to be empty. So we might be compelled to use
zero as empty or the empty name as not set. But this isn’t a good practice.
Using special values with special meanings is a bad idea in programming. We had
a long history with special values, and it usually ends in bugs.</p>
<p>Here’s where an Enum helps:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum When {
    name(String),
    hours(i64),
}
<span class="boring">}
</span></code></pre></pre>
<p>This can only take one of the values. Either is name or is hours.</p>
<p>We use them like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tomorrow = When::name(&quot;tomorrow&quot;.to_string());
let hours_3 = When::hours(3);
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>C++ has something similar to this, called union. But it’s not safe to use. 
Rust does have union as well and trust me, you don’t want to use unions unless
you really, really… really know what you’re doing.</p>
</blockquote>
<p>They also are useful to define names, for example a list of operation modes:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum OperationMode {
    Read,
    ReadWrite,
    Append,
    Create,
    SelfDestruct,
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Don’t confuse Rust enums with C++/Java enums. In these languages enums are 
useful only to associate a number to a name. Rust enums are way more powerful.</p>
</blockquote>
<p>You might say: “Well, nice, but I don’t see myself using this ever. How is this
a critical thing to know for a beginner?”</p>
<p>And the answer is that Rust itself is plagued with two very popular enums. 
You can’t avoid it. You’ll have enums in your code, want it or not.</p>
<p>These enums are <code>Option&lt;T&gt;</code> and <code>Result&lt;T&gt;</code>. I’ll discuss them now.</p>
<h2 id="option"><a class="header" href="#option">Option</a></h2>
<p>Option is basically:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option {
    Some(value),
    None,
}
<span class="boring">}
</span></code></pre></pre>
<p>And it is used when a value can be empty. But truly empty. Missing. Nil. Gone.</p>
<p>Because, you see, this is the empty string:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let text = &quot;&quot;.to_string();
<span class="boring">}
</span></code></pre></pre>
<p>But it’s not missing. It’s an empty string. The value is not empty; it contains
an empty string. Weird, hah!</p>
<p>You want an empty value?</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let text: Option&lt;String&gt; = None;
<span class="boring">}
</span></code></pre></pre>
<p>This one is empty.</p>
<p>And we can use this to have optional parameters in a function or a struct:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct User {
    username String,
    real_name Option&lt;String&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="result"><a class="header" href="#result">Result</a></h2>
<p>The other enum Result, is similar to this:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result {
    Ok(value),
    Err(error),
}
<span class="boring">}
</span></code></pre></pre>
<p>This is used to have fallible operations. If something fails, it will return an
<code>Err(error)</code>. The <code>error</code> inside contains details on what failed. If it works,
returns <code>Ok(value)</code> where <code>value</code> contains the data we needed.</p>
<p>For example, consider a function to divide:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn divide(a: f64, b: f64) -&gt; f64 {
    return a / b;
}
<span class="boring">}
</span></code></pre></pre>
<p>However, divide by zero is an error. To be able to communicate this error we can
do:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn divide(a: f64, b: f64) -&gt; Result&lt;f64&gt; {
    if b == 0 {
        return Err(DivideByZeroError);
    }
    return Ok(a / b);
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="unwrap"><a class="header" href="#unwrap">Unwrap</a></h1>
<p>As commented, Rust libraries are full of <code>Option</code> and <code>Result</code>. So it’s very
easy to find something that returns these things.</p>
<p>For example, if we want to parse a string into a number:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let num: i64 = &quot;1235&quot;.parse();
<span class="boring">}
</span></code></pre></pre>
<p>This doesn’t work because <code>parse()</code> will return a <code>Result</code> and not an <code>i64</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let num: Result&lt;i64&gt; = &quot;1235&quot;.parse();
<span class="boring">}
</span></code></pre></pre>
<p>But this is inconvenient. If we know that the result is going to be Ok, we
can use unwrap:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result_num: Result&lt;i64&gt; = &quot;1235&quot;.parse();
let num: i64 = result_num.unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>Or, in one line:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let num: i64 = &quot;1235&quot;.parse().unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>The problem with <code>unwrap()</code> is that <strong>will make the program crash</strong> if the result
is an error. So be careful when using this in places that are not guaranteed to
do as expected.</p>
<p>If you are okay with making the program crash at that point, consider using
<code>expect()</code> instead, which does the same but allows you to provide a message:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let num: i64 = &quot;1235&quot;.parse().expect(&quot;failed to parse credit card number&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>However, if making the program crash is not a good idea, you have to handle the
error:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result_num: Result&lt;i64&gt; = &quot;1235&quot;.parse();
match result_num {
    Ok(num) =&gt; {
        // .. handle here the parsed number ..
    },
    Err(e) =&gt; {
        // .. handle the error ..
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Rust forces you to choose what to do with the errors. There’s no “default action”
but instead, compiler errors and warnings until you decide to <code>unwrap</code> or handle
it. If you don’t decide, you’ll get complaints.</p>
<p>Oh, and this works with option too!</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// TODO: divide was returning a result - find another example!
let result_num: Option&lt;f64&gt; = divide(3.0, 1.2);
match result_num {
    Some(num) =&gt; {
        // .. handle here the parsed number ..
    },
    None =&gt; {
        // .. 
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="understanding-rust-enums-internals"><a class="header" href="#understanding-rust-enums-internals">Understanding Rust Enums internals</a></h2>
<blockquote>
<p>WARN: Technical info ahead! This describes how things work in memory 
internally. This section is not required to understand, and feel free to skip.
But for some readers, this might give some insight and understanding on Enums.
Don’t obsess into understanding everything; just a general overview here is fine.</p>
</blockquote>
<p>In C++ (and Rust) we have something called “unions”. A union is a type where
all contents will be stored in the same place in memory.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>union MyData {
    integer: i64,
    float: f32,
    text: [char; 20],
}
<span class="boring">}
</span></code></pre></pre>
<p>These contents will be put one on top of the other, overlapping the same region
in memory.</p>
<p>If we did a struct like that:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyData {
    integer: i64,
    float: f32,
    text: [char; 20],
}
<span class="boring">}
</span></code></pre></pre>
<p>In the memory we will have:</p>
<pre><code>  integer float        text
[________][____][____________________]
</code></pre>
<p>All variables will be packed one after another.</p>
<p>However, if we were only going to use one of those at a time, we would be 
wasting a lot of memory of the computer.</p>
<p>Unions instead put everything in the same place:</p>
<pre><code>[________] integer
[____] float
[____________________] text
</code></pre>
<p>Or, more accurately:</p>
<pre><code>float integer text
[____]___]___________]
</code></pre>
<p>There are bytes in memory that will be shared across the float, the integer, 
and the text. Because of this, they use only the memory needed to hold the
largest variable that they can contain.</p>
<p>This makes unions very dangerous as if you write text and then read float you’ll
get back basically garbage.</p>
<p>That’s why, in Rust, reading unions is unsafe.</p>
<p>But if we knew what field we wrote, then we could actually read it without risk 
of getting back garbage.</p>
<p>Imagine we had constants to specify which field it is:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const FIELD_FLOAT: u8 = 0;
const FIELD_INTEGER: u8 = 1;
const FIELD_TEXT: u8 = 2;
<span class="boring">}
</span></code></pre></pre>
<p>And then we store this along with the union, inside a struct:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>union MyData {
    integer: i64,
    float: f32,
    text: [char; 20],
}

struct MyDataSafe {
    field_written: u8,
    data: MyData,
}
<span class="boring">}
</span></code></pre></pre>
<p>Now, as long as we always keep the <code>field_written</code> up to date, we know which one
was used, so we can read confidently <code>data</code> without risk of getting back 
corrupted values.</p>
<p>We could write an implementation like this to ensure this is the case:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl MyDataSafe {
    pub fn write_integer(&amp;mut self, i: i64) {
        self.field_written = FIELD_INTEGER;
        self.data.integer = i;
    }
    pub fn write_float(&amp;mut self, f: f32) {
        self.field_written = FIELD_FLOAT;
        self.data.float = f;
    }
    pub fn write_text(&amp;mut self, t: [char; 20]) {
        self.field_written = FIELD_TEXT;
        self.data.text = t;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>And we could read “safely”:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl MyDataSafe {
    pub fn read_integer(&amp;self) -&gt; i64 {
        if self.field_written != FIELD_INTEGER {
            panic!(&quot;wrong field type&quot;);
        }
        unsafe {self.data.integer}
    }
    pub fn write_float(&amp;self) -&gt; f32 {
        if self.field_written != FIELD_FLOAT {
            panic!(&quot;wrong field type&quot;);
        }
        unsafe {self.data.float}
    }
    pub fn write_text(&amp;self) -&gt; [char; 20] {
        if self.field_written != FIELD_TEXT {
            panic!(&quot;wrong field type&quot;);
        }
        unsafe {self.data.text}
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Notice two things here. First, when we created the struct:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyDataSafe {
    field_written: u8,
    data: MyData,
}
<span class="boring">}
</span></code></pre></pre>
<p>The layout in memory is:</p>
<pre><code>   float integer text
[_][____]___]___________]
 ^    
 --- field_written
</code></pre>
<p>Second, those constants:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const FIELD_FLOAT: u8 = 0;
const FIELD_INTEGER: u8 = 1;
const FIELD_TEXT: u8 = 2;
<span class="boring">}
</span></code></pre></pre>
<p>Are actually a regular C++ enum:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Field {
    Float,
    Integer,
    Text,
}
<span class="boring">}
</span></code></pre></pre>
<p>And the struct:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyDataSafe {
    field_written: u8,
    data: MyData,
}
<span class="boring">}
</span></code></pre></pre>
<p>Is actually an equivalent of a Rust Enum!</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Field {
    Float(f32),
    Integer(i64),
    Text([char; 20]),
}
<span class="boring">}
</span></code></pre></pre>
<p>That’s what it actually is! Rust enums are kind of “safe C++ style unions”.</p>
<p>They use only the memory needed for the biggest value possible of all options,
and they’re safe. Plus an extra byte or two to hold which variant are we talking
about.</p>
<blockquote>
<p>In some cases, Rust is “too smart” and it’s able to omit the extra byte needed
to store the variant by using some tricks when compiling. But that is outside
what I want to cover here.</p>
</blockquote>

                </main>

                <nav class="nav-wrapper" aria-label="Page navigation">
                    <!-- Mobile navigation buttons -->
                    <a rel="prev" href="../L04adept/020C_oop.html" class="mobile-nav-chapters previous"
                        title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../L04adept/022A_match.html" class="mobile-nav-chapters next"
                        title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>

                    <div style="clear: both"></div>
                </nav>
            </div>
        </div>

        <nav class="nav-wide-wrapper" aria-label="Page navigation">
            <a rel="prev" href="../L04adept/020C_oop.html" class="nav-chapters previous" title="Previous chapter"
                aria-label="Previous chapter" aria-keyshortcuts="Left">
                <i class="fa fa-angle-left"></i>
            </a>

            <a rel="next" href="../L04adept/022A_match.html" class="nav-chapters next" title="Next chapter"
                aria-label="Next chapter" aria-keyshortcuts="Right">
                <i class="fa fa-angle-right"></i>
            </a>
        </nav>

    </div>

    <!-- Livereload script (if served using the cli tool) -->
    <script type="text/javascript">
        const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
        const socket = new WebSocket(wsAddress);
        socket.onmessage = function (event) {
            if (event.data === "reload") {
                socket.close();
                location.reload();
            }
        };

        window.onbeforeunload = function () {
            socket.close();
        }
    </script>



    <script type="text/javascript">
        window.playground_copyable = true;
    </script>


    <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

    <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
    <script src="../book.js" type="text/javascript" charset="utf-8"></script>

    <!-- Custom JS scripts -->


</body>

</html>