<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>Rust for Total Beginners</title>
    <meta name="robots" content="noindex" />


    <!-- Custom HTML head -->
    
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="icon" href="favicon.svg">
    <link rel="shortcut icon" href="favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
    <link rel="stylesheet" href="css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    <link rel="stylesheet" href="styles.css">

    <!-- MathJax -->
    <script async type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>

<body>
    <!-- Provide site root to javascript -->
    <script type="text/javascript">
        var path_to_root = "";
        var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
    </script>

    <!-- Work around some values being stored in localStorage wrapped in quotes -->
    <script type="text/javascript">
        try {
            var theme = localStorage.getItem('mdbook-theme');
            var sidebar = localStorage.getItem('mdbook-sidebar');

            if (theme.startsWith('"') && theme.endsWith('"')) {
                localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
            }

            if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
            }
        } catch (e) { }
    </script>

    <!-- Set the theme before any content is loaded, prevents flash -->
    <script type="text/javascript">
        var theme;
        try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
        if (theme === null || theme === undefined) { theme = default_theme; }
        var html = document.querySelector('html');
        html.classList.remove('no-js')
        html.classList.remove('light')
        html.classList.add(theme);
        html.classList.add('js');
    </script>

    <!-- Hide / unhide sidebar before it is displayed -->
    <script type="text/javascript">
        var html = document.querySelector('html');
        var sidebar = 'hidden';
        if (document.body.clientWidth >= 1080) {
            try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
            sidebar = sidebar || 'visible';
        }
        html.classList.remove('sidebar-visible');
        html.classList.add("sidebar-" + sidebar);
    </script>

    <nav id="sidebar" class="sidebar" aria-label="Table of contents">
        <div class="sidebar-scrollbox">
            <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded "><a href="L01_starter.html"><strong aria-hidden="true">1.</strong> Level: Starter</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="L01starter/001A_first_language.html"><strong aria-hidden="true">1.1.</strong> Your first programming language</a></li><li class="chapter-item expanded "><a href="L01starter/002A_books.html"><strong aria-hidden="true">1.2.</strong> Related books</a></li><li class="chapter-item expanded "><a href="L01starter/003A_setup.html"><strong aria-hidden="true">1.3.</strong> Setting up the computer</a></li><li class="chapter-item expanded "><a href="L01starter/004A_first_program.html"><strong aria-hidden="true">1.4.</strong> Your first program</a></li><li class="chapter-item expanded "><a href="L01starter/005A_to_the_IDE.html"><strong aria-hidden="true">1.5.</strong> Quick, to the IDE!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="L01starter/005B_saving_progress.html"><strong aria-hidden="true">1.5.1.</strong> Saving our progress</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="L02_novice.html"><strong aria-hidden="true">2.</strong> Level: Novice</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="L02novice/006A_recipes.html"><strong aria-hidden="true">2.1.</strong> It's like cooking recipes, seriously</a></li><li class="chapter-item expanded "><a href="L02novice/007A_little_boxes.html"><strong aria-hidden="true">2.2.</strong> Variables are like little boxes that store things inside</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="L02novice/007B_ex_print_format.html"><strong aria-hidden="true">2.2.1.</strong> Exercise: Printing and Formatting</a></li></ol></li><li class="chapter-item expanded "><a href="L02novice/007C_fun_with_libs.html"><strong aria-hidden="true">2.3.</strong> Having fun with libraries</a></li><li class="chapter-item expanded "><a href="L02novice/008A_declaring.html"><strong aria-hidden="true">2.4.</strong> Declaring variables</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="L02novice/008B_ex_variables.html"><strong aria-hidden="true">2.4.1.</strong> Exercise: Variables</a></li><li class="chapter-item expanded "><a href="L02novice/008C_turtle.html"><strong aria-hidden="true">2.4.2.</strong> Let's try Turtle!</a></li></ol></li><li class="chapter-item expanded "><a href="L02novice/009A_incrementing.html"><strong aria-hidden="true">2.5.</strong> Incrementing and decrementing</a></li><li class="chapter-item expanded "><a href="L02novice/010A_looping.html"><strong aria-hidden="true">2.6.</strong> Looping' around</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="L02novice/010B_ex_loops.html"><strong aria-hidden="true">2.6.1.</strong> Exercise: loops</a></li><li class="chapter-item expanded "><a href="L02novice/010C_turtle_loops.html"><strong aria-hidden="true">2.6.2.</strong> !? Turtle: loops</a></li></ol></li><li class="chapter-item expanded "><a href="L02novice/011A_comments.html"><strong aria-hidden="true">2.7.</strong> Adding some comments</a></li><li class="chapter-item expanded "><a href="L02novice/012A_ifs.html"><strong aria-hidden="true">2.8.</strong> What If…?</a></li><li class="chapter-item expanded "><a href="L02novice/013A_loops_again.html"><strong aria-hidden="true">2.9.</strong> For loops again!</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="L02novice/013B_other_loops.html"><strong aria-hidden="true">2.9.1.</strong> ? Other types of loops</a></li><li class="chapter-item expanded "><a href="L02novice/012B_ex_ifs.html"><strong aria-hidden="true">2.9.2.</strong> !!? Exercise: conditionals</a></li><li class="chapter-item expanded "><a href="L02novice/013C_turtle_loops.html"><strong aria-hidden="true">2.9.3.</strong> !!? Turtle: Improving with loops</a></li><li class="chapter-item expanded "><a href="L02novice/013D_turtle_spiral.html"><strong aria-hidden="true">2.9.4.</strong> !!!? Turtle: Making a spiral</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="L03_apprentice.html"><strong aria-hidden="true">3.</strong> Level: Apprentice</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="L03apprentice/014A_functions.html"><strong aria-hidden="true">3.1.</strong> Introducing Functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="L03apprentice/014B_func_return.html"><strong aria-hidden="true">3.1.1.</strong> Returning values from functions</a></li><li class="chapter-item expanded "><a href="L03apprentice/014C_func_args.html"><strong aria-hidden="true">3.1.2.</strong> Function arguments</a></li></ol></li><li class="chapter-item expanded "><a href="L03apprentice/015A_data_types.html"><strong aria-hidden="true">3.2.</strong> Data types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="L03apprentice/015B_rust_types.html"><strong aria-hidden="true">3.2.1.</strong> Rust data types</a></li></ol></li><li class="chapter-item expanded "><a href="L03apprentice/016A_typedvars.html"><strong aria-hidden="true">3.3.</strong> Back to declaring variables… with type</a></li><li class="chapter-item expanded "><a href="L03apprentice/016B_dbg_format.html"><strong aria-hidden="true">3.4.</strong> ? dbg!() and format!()</a></li><li class="chapter-item expanded "><a href="L03apprentice/017A_conversions.html"><strong aria-hidden="true">3.5.</strong> ? Converting types with explicit conversions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="L03apprentice/017B_ex_conversions.html"><strong aria-hidden="true">3.5.1.</strong> !!? Exercise: explicit conversions</a></li></ol></li><li class="chapter-item expanded "><a href="L03apprentice/018A_strings_intro.html"><strong aria-hidden="true">3.6.</strong> A tiny bit on strings</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="L03apprentice/018B_strings_and_str.html"><strong aria-hidden="true">3.6.1.</strong> Simple explanation on &str vs String</a></li></ol></li><li class="chapter-item expanded "><a href="L03apprentice/X03A_funcs_revisited.html"><strong aria-hidden="true">3.7.</strong> A bit more detailed explanation on functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="L03apprentice/014D_closures.html"><strong aria-hidden="true">3.7.1.</strong> ? Introduction to Closures</a></li></ol></li><li class="chapter-item expanded "><a href="L03apprentice/020A_proj_game_macroquad.html"><strong aria-hidden="true">3.8.</strong> !!? Project: A simple game with Macroquad</a></li></ol></li><li class="chapter-item expanded "><a href="L04_adept.html"><strong aria-hidden="true">4.</strong> Level: Adept</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.</strong> !!? const and static</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.2.</strong> !!? functions that write to original vars; &mut and *</div></li><li class="chapter-item expanded "><a href="L04adept/020A_structs.html"><strong aria-hidden="true">4.3.</strong> Not everything are numbers and texts: Structs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="L04adept/020B_struct_impl.html"><strong aria-hidden="true">4.3.1.</strong> Struct-specific functions, really?</a></li><li class="chapter-item expanded "><a href="L04adept/020C_oop.html"><strong aria-hidden="true">4.3.2.</strong> !? OOP? More like OP</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.3.3.</strong> !!? What are objects and instances</div></li></ol></li><li class="chapter-item expanded "><a href="L04adept/021A_enums.html"><strong aria-hidden="true">4.4.</strong> ? Enums!</a></li><li class="chapter-item expanded "><a href="L04adept/022A_match.html"><strong aria-hidden="true">4.5.</strong> !? Match!</a></li><li class="chapter-item expanded "><a href="L04adept/023A_float_gotchas.html"><strong aria-hidden="true">4.6.</strong> ? Floating point gotchas</a></li><li class="chapter-item expanded "><a href="L04adept/024A_modules.html"><strong aria-hidden="true">4.7.</strong> Modules - splitting files</a></li><li class="chapter-item expanded "><a href="L04adept/X02A_datatypes.html"><strong aria-hidden="true">4.8.</strong> What are those other data types for?</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.9.</strong> !!? Contracts in programming</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.10.</strong> !!? Algorithms</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.11.</strong> !!? Data Structures</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.11.1.</strong> !!? Lists</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.11.2.</strong> !!? Tuples</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.11.3.</strong> !!? Slices</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.11.4.</strong> !!? HashMaps</div></li></ol></li><li class="chapter-item expanded "><a href="L04adept/023A_proj_game_ggez.html"><strong aria-hidden="true">4.12.</strong> !!? Project: A simple game with ggez</a></li></ol></li><li class="chapter-item expanded "><a href="L05_master.html"><strong aria-hidden="true">5.</strong> !? Level: Master</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="L05master/023A_borrowing.html"><strong aria-hidden="true">5.1.</strong> Borrowing</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.</strong> !!? Lifetimes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> !!? What it made it "click" for me - memory allocation</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.4.</strong> !!? Generic parameters</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.</strong> !!? Data Structures</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.1.</strong> !!? Lists again!</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.1.1.</strong> !!? Deques and ring buffers</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.2.</strong> !!? HashMaps again!</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.2.1.</strong> !!? HashSets, what?</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.3.</strong> !!? The infamous linked list</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.4.</strong> !!? Trees</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.5.</strong> !!? Heaps</div></li></ol></li></ol></li><li class="chapter-item expanded "><a href="L06_grandmaster.html"><strong aria-hidden="true">6.</strong> !!? Level: Grand Master</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> !!? A glance over macros</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> !!? Polymorphism (Traits)</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> !!? Functional programming</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.1.</strong> !!? Iterators</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.4.</strong> !!? Smart Pointers</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.4.1.</strong> !!? Box</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.4.2.</strong> !!? Rc</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.4.3.</strong> !!? RefCell</div></li></ol></li><li class="chapter-item expanded "><a href="L06grandmaster/X04A_garbage_collector.html"><strong aria-hidden="true">6.5.</strong> !? What is a Garbage Collector?</a></li></ol></li><li class="chapter-item expanded "><a href="L07_legendary.html"><strong aria-hidden="true">7.</strong> !!? Level: Legendary</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">7.1.</strong> !!? Polymorphism (dyn Box)</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.2.</strong> !!? No Size? ?Sized</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.3.</strong> !!? Threading</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">7.3.1.</strong> !!? Mutexes/Locks</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.3.2.</strong> !!? Atomics</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.4.</strong> !!? Async</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.5.</strong> !!? Databases and SQL</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">7.5.1.</strong> !!? What about NoSQL?</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.6.</strong> !!? Web applications!</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">7.6.1.</strong> !!? HTML+CSS+JS in one shot</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.6.2.</strong> !!? Web servers</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.6.3.</strong> !!? REST services</div></li><li class="spacer"></li></ol></li></ol></li><li class="chapter-item expanded "><a href="Y01A_appendices.html"><strong aria-hidden="true">8.</strong> Appendices</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Y02A_license.html"><strong aria-hidden="true">8.1.</strong> Appendix A. License of this book</a></li><li class="chapter-item expanded "><a href="Y03A_caveats.html"><strong aria-hidden="true">8.2.</strong> Appendix B. Caveats and challenges in this book</a></li><li class="chapter-item expanded "><a href="Y04A_solutions.html"><strong aria-hidden="true">8.3.</strong> Appendix C. Exercises and Solutions</a></li><li class="chapter-item expanded "><a href="Y05A_projects.html"><strong aria-hidden="true">8.4.</strong> Appendix D. Proposed projects</a></li><li class="chapter-item expanded "><a href="Y06A_rust_compared.html"><strong aria-hidden="true">8.5.</strong> Appendix E. Rust compared to other languages</a></li></ol></li></ol>
        </div>
        <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
    </nav>

    <div id="page-wrapper" class="page-wrapper">

        <div class="page">
                        <div id="menu-bar-hover-placeholder"></div>
            <div id="menu-bar" class="menu-bar sticky bordered">
                <div class="left-buttons">
                    <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                        aria-label="Toggle Table of Contents" aria-controls="sidebar">
                        <i class="fa fa-bars"></i>
                    </button>
                    <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                        aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                        <i class="fa fa-paint-brush"></i>
                    </button>
                    <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                        <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                        <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button>
                        </li>
                    </ul>
                    <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                        aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                        aria-controls="searchbar">
                        <i class="fa fa-search"></i>
                    </button>
                </div>

                <h1 class="menu-title"><small>A Language to Teach Programming</small><br>🦀 Rust for Total Beginners 🦀</h1>

                <div class="right-buttons">
                    <a href="print.html" title="Print this book" aria-label="Print this book">
                        <i id="print-button" class="fa fa-print"></i>
                    </a>

                </div>
            </div>

            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                        aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>

            <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
            <script type="text/javascript">
                document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                    link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                });
            </script>

            <div id="content" class="content">
                <main>
                    <h1 id="learn-programming-with-rust-as-first-language"><a class="header" href="#learn-programming-with-rust-as-first-language">Learn programming with Rust as first language</a></h1>
<ul>
<li>Source for this book: <a href="https://github.com/deavid/lprfl">https://github.com/deavid/lprfl</a></li>
<li>Author: David Martínez Martí</li>
<li>Blog: <a href="https://deavid.wordpress.com/">https://deavid.wordpress.com/</a></li>
</ul>
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Coding can be a daunting task to any beginner. In fact even at seniority levels, 
it still is for advanced concepts. 
As you get on your journey of learning how to code you’ll begin to find previous 
hard tasks as easy. At some point they will become so obvious that it gets 
hard to imagine how other people don’t understand them. 
But regardless, there will always be daunting tasks waiting for you. Programming 
is not about the destination, it is about the journey itself.</p>
<p>It’s not something that you learn, and you’re done. There’s almost an infinite 
amount of stuff that can be learned and used, as you gain more expertise, you’ll 
be able to specialize on certain types of programs and make them go the extra 
mile, which feels very satisfying. This field also keeps constantly evolving, so 
much that in 10 years the job requirements change drastically, and it might 
be difficult to find a job if we don’t keep learning.</p>
<p>If you enjoy learning and trying to do new stuff day by day, then this is
for you. It will get easier over time, I promise!</p>
<p>From zero knowledge on programming to being able to apply to any job and 
hope to succeed, it takes at least 6 months with full day dedication 
(8 hours a day) if you’re a good learner.</p>
<p>To get rid of the “junior” title, you will need another 2-3 years usually. 
And (real) seniors have at least 8 years of experience. From there, the 
differences between someone with 8 or 20 years of experience tend to be very dim; 
it depends more on the people themselves than the experience.</p>
<p>The good news is that with enough dedication you can get yourself employed in 
record time, which for other careers requires proper study at a university, which 
takes several years.
And you’ll be able to grow easily on the job. Getting employed is not the 
destination, but maybe a new beginning. There’s always a huge demand on good 
developers, so if you prove yourself good, even if the company doesn’t allow 
you to grow, there will be several companies wanting your talent and will 
raise the offer accordingly.</p>
<p>So, before taking this journey ask yourself: Is this the path I want to take?
If the answer is yes, then do it! Commit and push forward to get it.</p>
<blockquote>
<p>NOTE: I love oversimplifying a lot!. And I will lie in order to make things 
look simpler and create simple rules that don’t always work. This is done on 
purpose to make the experience easy to follow and add concepts slowly. I will 
correct these and get into specifics slowly as I feel the reader got enough 
knowledge to understand the whole thing. </p>
</blockquote>
<h2 id="book-levels"><a class="header" href="#book-levels">Book Levels</a></h2>
<p>I organized the book into sections called levels, following “mage” levels as
in fantasy games.</p>
<p>These give a way to you to know how much progress you did and how far are from
your goals.</p>
<p>Your target should be to reach the “Adept” level and be proficient with it.
You could consider yourself a programmer just with that.</p>
<p>After this point, it’s a matter of wanting to be better. The better you are,
the easier it will become to get a job. I would recommend at least reaching
the Master level to be in a good position to start working.</p>
<h3 id="level-starter"><a class="header" href="#level-starter">Level: Starter</a></h3>
<p>You know how to install Rust and create programs.</p>
<h3 id="level-novice"><a class="header" href="#level-novice">Level: Novice</a></h3>
<p>Your programs know how to apply logic and process a lot of instructions.</p>
<h3 id="level-apprentice"><a class="header" href="#level-apprentice">Level: Apprentice</a></h3>
<p>Your programs become useful, and you’re able to create your own utilities for
your own use.</p>
<h3 id="level-adept"><a class="header" href="#level-adept">Level: Adept</a></h3>
<p>Able to use most libraries out there and create programs that would be 
production grade. This could be enough for some starting junior positions in 
some companies.</p>
<h3 id="level-master"><a class="header" href="#level-master">Level: Master</a></h3>
<p>Got rid of most of the blockers and brain-walls that are associated with Rust 
and programming. Coding complex stuff that matters, using the right tools for
the job and being able to participate and contribute with the community.</p>
<h3 id="level-grand-master"><a class="header" href="#level-grand-master">Level: Grand Master</a></h3>
<p>Expertise and in-depth knowledge on how Rust works. Able to follow almost all
code that you came to see. </p>
<h3 id="level-legendary"><a class="header" href="#level-legendary">Level: Legendary</a></h3>
<p>If you reach this level, better go and contribute to Rust itself!</p>
<h2 id="unfinished-chapters"><a class="header" href="#unfinished-chapters">Unfinished chapters</a></h2>
<p>This Book keeps growing. A lot of chapters are still a work in progress.</p>
<p>I added some symbols on the titles to clarify:</p>
<ul>
<li>?: Pending review and completing a bit.</li>
<li>!?: Several paragraphs are still missing.</li>
<li>!!?: Still mostly empty, placeholder.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="level-starter-1"><a class="header" href="#level-starter-1">Level: Starter</a></h1>
<p>Here your journey begins, little mage. This book will teach you how to get started
in Rust and get your magic flowing.</p>
<p>Shortly you’ll be able to start casting your first spells and get your programs
flowing.</p>
<p>The initial journey is hard, but don’t despair! We’ll go little by little.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="your-first-programming-language"><a class="header" href="#your-first-programming-language">Your first programming language</a></h1>
<p>This is a common question everyone asks themselves. 
In my opinion, Python and Rust are the two best languages to start with. 
While Python will give you an easier time to begin, and plenty of jobs that
actually exist, Rust is going to be a bit harder to begin with, with way less jobs.</p>
<p>As the title suggests, I’m going to recommend Rust. Why? Lots of reasons. 
I believe Rust will be the language of the future, so by the time you learn it 
hopefully there will be jobs waiting for you.</p>
<p>Rust also will teach you proper coding practices. As it is stricter, it will 
force you into the right shape and mindset for a programmer, and not someone who 
stitches things together that delivers delicate programs that break in strange 
ways just by looking at them.</p>
<p>The Rust community is very friendly. You’ll have a lot of people wanting to 
teach you the language and help you along on this. Python is a bit of 
hit-and-miss, some communities might be toxic.</p>
<p>The documentation is solid, nicely written, and very easy to follow. 
The reference docs might be a bit complex to understand at first, but 
after the first month or two it becomes very practical.</p>
<p>Rust has potential to be used for anything. Web, games, embedded devices, 
operating systems, browsers, you name it. There are still several gaps 
at the moment of this writing due to the nature of Rust being so new; over time 
more libraries will be created and mature, so right now there are several 
types of applications where Rust might not be fit. For now.</p>
<p>Python is very powerful and is able to do most of the applications that you 
might want to do, and it is very quick to write and get results with it. But it 
has several downsides (one is performance) that are very unlikely to disappear 
in the next 10 or 20 years<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<p>In the end, it doesn’t matter that much which language you start with. As long 
as you can learn to code, the language isn’t that important. All languages have 
lots of similarities, so much that when you learn the second one it will take 
99% less time than the first.</p>
<p>And you can’t count on learning a single language (i.e. Rust) and hope that this 
would be all. There are always languages that are very good at one thing, and 
you should learn those too. Because you don’t want to spend a week doing 
something in Rust that takes 1 line of Bash to do, if there’s no real reason or 
benefit<sup class="footnote-reference"><a href="#2">2</a></sup> for it.</p>
<p>So, no worries, you’ll be fine. You’ll learn other languages over the course of 
years and that will take less and less time as you go.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>As usual, there are several companies trying to make Python faster. Some
efforts are going through “compiling” typed python code with great speedups. 
There’s also PyPy. But the community at this point does not want a “typed Python”
so I don’t see the performance being fixed in the near future.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>I’ve seen someone write a full Java application for several days, trying
to make it as fast as possible, and someone else came up with a Bash one liner
with pipes that did the same thing 2x faster, and they basically spent 5 minutes
writing the line. Use the best tool for each job. You should learn more than one 
programming language.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="related-books"><a class="header" href="#related-books">Related books</a></h1>
<h2 id="the-holy-rust-book"><a class="header" href="#the-holy-rust-book">The holy Rust book</a></h2>
<p>You must know that there exists a book called just “The Rust book” or “the book”. </p>
<p>I will (jokingly &amp; friendly) call it here “The holy rust book”. </p>
<p>You can check it here:
<a href="https://doc.rust-lang.org/stable/book/">https://doc.rust-lang.org/stable/book/</a></p>
<p>The holy book is the main learning resource for Rust. 
It is the true starting point for learning the language and contains 
everything, from beginner to truly advanced. 
It covers the entire language (except the uses of Unsafe, that are covered in 
the Necronomicon… I mean, the Rustonomicon)</p>
<p>This guide it is not meant to replace the holy book itself, as it is very well 
written by experts and reviewed by the whole community. </p>
<p>If that’s the case, what’s the point of this then? Well, the holy book assumes 
some knowledge. It will rapidly grow in difficulty and will require several 
reads for beginners and look in other places as well to fully grasp the concepts.</p>
<p>Only a small part of the language will be covered here; enough to get you started, 
and at a slow pace enough to follow without external resources (hopefully). 
From time to time I’ll link to the holy book, so you can go there to read if you 
like, as there’s more detail.</p>
<p>I call it “holy” because it’s the Rust Bible (in fact some people call it that). 
If the holy book disagrees with me, the book is right, I’m wrong. 
Whatever it says, it is right. 
A lot of people call Rust a cult (seriously) so I pretend to extend and embrace 
the term to make it a funny joke.</p>
<h2 id="other-rust-books"><a class="header" href="#other-rust-books">Other Rust books</a></h2>
<p>See <a href="https://github.com/sger/RustBooks">https://github.com/sger/RustBooks</a></p>
<ul>
<li><a href="https://doc.rust-lang.org/rust-by-example/">Rust by Example</a></li>
<li><a href="https://dhghomon.github.io/easy_rust/">Easy Rust</a></li>
<li><a href="https://stevedonovan.github.io/rust-gentle-intro/">A Gentle Introduction to Rust</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-the-computer"><a class="header" href="#setting-up-the-computer">Setting up the computer</a></h1>
<p>So you reached this point! I guess we’re doing it. Let’s stop the chatter and bring in the real stuff. Let’s install Rust.</p>
<h2 id="installing-rust"><a class="header" href="#installing-rust">Installing Rust</a></h2>
<p>Get your browser and go to <a href="https://rustup.rs/">https://rustup.rs/</a>. Follow the instructions there.</p>
<ul>
<li>For Windows, there’s a <code>rust-init.exe</code> that you download and will install everything.</li>
<li>For Linux (my case), there’s a single command line that you copy and paste into the console.</li>
</ul>
<!--- TODO: And this is a security risk that some people don't want to take. Add an alternative option. -->
<p>(By the way, if you want to be a developer, you also need to make the terminal your friend)</p>
<p>That will be all we need to do. Congrats! You installed Rust in your machine!</p>
<blockquote>
<p><code>Chapter 1.1 - Installation</code> of the Holy Book contains the installation instructions.</p>
</blockquote>
<h2 id="choosing-an-editor-for-rust"><a class="header" href="#choosing-an-editor-for-rust">Choosing an editor for Rust</a></h2>
<p>I’m very opinionated here. Get Visual Studio Code. 
(not to be confused with MS Visual Studio)</p>
<!--- TODO: Add the de-Microsoftified Port of VS Code to your Guide: https://vscodium.com/ -->
<p>People call it VS Code or just “Code”. 
It’s open source, supports nearly all languages, and works really, really well.</p>
<p>From those that code with Rust, they mainly use VS Code or Vim. 
And I’m not going to recommend Vim to anyone. 
It is an excellent program, but geared towards very senior people. 
So VS Code it is.</p>
<p>I have more than 15 years coding, and I do use VS Code. It’s great. 
On the other hand, I almost never use Vim: 
it requires a lot of investment that I don’t want to commit to.</p>
<p>Now, go to the extensions panel and search for “rust-analyzer” and install it. 
This is all you need to get the best Rust experience.</p>
<p><img src="L01starter/./img/vscode_extensions.png" alt="VSCode Extensions" /></p>
<blockquote>
<p>It is really important to have Rust properly installed at this point, or rust-analyzer will fail.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="your-first-program"><a class="header" href="#your-first-program">Your first program</a></h1>
<p>Before doing anything, it is important to have a folder where you put all your programs. 
So go ahead and create a folder with the name you like (i.e., “programs”)<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<p>A few tips though:</p>
<ul>
<li>
<p>Prefer to use lowercase only for the folder, no spaces. 
Use an underscore if you need to separate words, but I would 
recommend writing something short.</p>
</li>
<li>
<p>Place the folder somewhere that has a short, easy path. Don’t place it on your 
Desktop. On Windows, “C:&quot; might be better as the home folder contains a path with spaces.</p>
</li>
</ul>
<p>Now open a terminal and go to this folder. 
Using <code>cd ..</code> and <code>cd your_folder_name</code> should do the trick. 
If you followed my tips, this should be an easy task.</p>
<p>Once you’re set, run the following command:</p>
<pre><code class="language-console">$ cargo new learnrust
     Created binary (application) `learnrust` package
</code></pre>
<p>This will create a folder called <code>learnrust</code>, you should be able to find it with 
your file explorer. 
Inside, there are a few folders and files. 
This is how an empty Rust program looks.</p>
<!-- Screenshot of the file manager? -->
<p>It already includes a program in src called <code>main.rs</code> (we’ll check out the contents later). 
And it can be executed. </p>
<p>Do <code>cd learnrust</code> on the console to get into the folder, then run:</p>
<pre><code class="language-console">$ cargo run
</code></pre>
<p>The output will be similar to this:</p>
<pre><code class="language-console">$ cargo run
Compiling learnrust v0.1.0 (/home/deavid/git/rust/learnrust)
Finished dev [unoptimized + debuginfo] target(s) in 0.34s
  Running `target/debug/learnrust`
Hello, world!
</code></pre>
<p>The program has been built and executed. The program output is “Hello, world!”.</p>
<p>Congrats! You just wrote your first program. (more or less, hah)</p>
<p>If you execute “cargo run” again, then:</p>
<pre><code class="language-console">    $ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
     Running `target/debug/learnrust`
    Hello, world!
</code></pre>
<p>Notice how something is different. 
At first, it compiled the program, then executed it. 
On the second time, it noticed that the program was unchanged, so 
it was run without compiling it again.</p>
<p>This is covered in <code>Chapter 1.2 - Hello World!</code> of the holy book.</p>
<h2 id="what-is-this-cargo-command"><a class="header" href="#what-is-this-cargo-command">What is this cargo command?</a></h2>
<p>Surely you noticed that we did “cargo run” and not “rust run”. 
Cargo is like the swiss-army knife of Rust, it will simplify all our processes 
during coding, and removes a lot of stuff that we don’t need to learn.</p>
<p>Main things that it does:</p>
<ul>
<li>Instead of compiling the program with <code>rustc</code>, it’s just <code>cargo build</code>. 
<code>rustc</code> will need flags, and it’s a bit tricky to do right, cargo makes this super simple.</li>
<li>Cargo built the program in <code>./target/debug/</code> or <code>./target/release</code>. 
We could run these directly, but we would need to remember to build them first. 
<code>cargo run</code> does this for us.</li>
<li>We might need to download libraries for additional stuff 
(this is common in all programming languages). Instead of doing this manually, 
we can declare in <code>Cargo.toml</code> which ones do we want, and when 
we do <code>cargo build</code> it will download anything missing automatically.</li>
</ul>
<p>There’s much more than this, but for now this is what we will be using. 
The bottom line is that we will always use <code>cargo</code> and forget about the other commands. 
That’s fewer things to remember.</p>
<p>As a side note, if you installed with <code>rustup.rs</code> as I recommended, there’s 
also a <code>rustup</code> command. This is used to update rust and cargo themselves. 
If you need to update, just run <code>rustup update</code> and everything will be done 
automatically. 
It’s a good idea to do this once a month or so, but if you don’t do it is also fine.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Personally I use <a href="https://git-scm.com/">Git</a> for everything, and I have 
the folders structured as <code>/home/deavid/git/rust/project_name</code>.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-to-the-ide"><a class="header" href="#quick-to-the-ide">Quick, to the IDE!</a></h1>
<p>Let’s start using that nice VS Code that we installed earlier. </p>
<p>Open VS Code, look for the Menu <code>File</code> and click <code>Open Folder...</code>. </p>
<p><img src="L01starter/./img/vscode_open_folder.png" alt="Open Folder" /></p>
<p>Select the <code>learnrust</code> folder that cargo created.</p>
<blockquote>
<p>NOTE: For myself, I find more convenient to open VSCode from the terminal.<br />
I simply <code>cd learnrust</code> and run <code>code .</code>. VSCode will open the folder.</p>
</blockquote>
<p>Now, open the src folder using the left panel, and you’ll see the <code>main.rs</code>. 
Double-click on it.</p>
<p>This is what you should see:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
   println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p><code>fn main()</code> represents the main program. </p>
<p>The brackets next to it (<code>{</code> and <code>}</code>) define where the program starts and ends. </p>
<p>Right now there’s only one line in the program: <code>println!(...)</code></p>
<p><code>println!(...)</code> is for printing text on the console/terminal.</p>
<p>The text between the parentheses is what will be printed. 
Notice that it’s surrounded by double quotes and these are 
not printed to the terminal. They’re required.</p>
<p>This line ends with a semicolon <code>;</code> this is what marks the end of the 
instruction (the command to run). 
Rust does not care about the different lines, or how they look in your editor. 
You can put all in one line and still will do the same thing. 
VSCode will format by default when you save, so it will always look nice and tidy.</p>
<!-- TODO: user might need to enable format on save; also other configs to tune would be helpful like auto save -->
<p>Open a new terminal inside VS Code. Go to <code>Terminal</code> ⇒ <code>New Terminal</code>:</p>
<p><img src="L01starter/./img/vscode_new_terminal.png" alt="New Terminal" /></p>
<p>This opens a terminal on the project folder, so you can now type there 
<code>cargo run</code> to run the program inside this terminal panel.</p>
<p>As you can see we can do the same things as with an external terminal. 
As this is more convenient, we’ll use this from now on. There’s no difference to
an external one, so if you prefer to have a separate terminal program 
running, it’s totally fine.</p>
<p>You can try to print different texts or more lines. For example:</p>
<p><img src="L01starter/./img/vscode_program_run.png" alt="Program run" /></p>
<p>This is not very useful, but it’s important to play around and get familiar 
with what we learn.</p>
<p>Programs are executed one line at a time. 
Rust will read the first line, execute the command, then go to the next line 
and do the same. 
Until it reaches the end of the program and then the program just ends.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="saving-our-progress"><a class="header" href="#saving-our-progress">Saving our progress</a></h1>
<p>When reading this book, you’ll find lots of small recipes to try out. You can
put them in your <code>main.rs</code> file and execute <code>cargo run</code>, but soon you’ll find
that you need to delete your old code to put the new one.</p>
<p>And you might not want to keep removing the old code. That’s understandable!</p>
<p>I would prefer to have something for you to build incrementally, but sadly at
this point it’s not possible. We need to learn the basics for a while before I 
can give you any sort of tasks. So for the next chapters, we’ll be using small
programs that are easy to understand. A few lines only each time.</p>
<p>But you, the reader, might want to keep those samples to play around later. And
avoid deleting them when trying out something new.</p>
<p>I have a solution for you, but you’ll have to trust me here.</p>
<h2 id="multiple-binaries-with-cargo"><a class="header" href="#multiple-binaries-with-cargo">Multiple binaries with Cargo</a></h2>
<p>First, create the folder <code>learnrust/src/bin/</code>, and add a file named <code>sample1.rs</code>
in it.</p>
<p>In this file <code>learnrust/src/bin/sample1.rs</code>, add the following contents:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    println!(&quot;sample program 1&quot;);
}
</code></pre></pre>
<p>Now open <code>Cargo.toml</code> file, and add the following lines:</p>
<pre><code class="language-toml">[[bin]]
name = &quot;sample1&quot;
</code></pre>
<p>Your file now should look like this:</p>
<pre><code class="language-toml">[package]
name = &quot;learnrust&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at ...

[[bin]]
name = &quot;sample1&quot;

[dependencies]
</code></pre>
<p>With this done, we now have two programs in one project folder <code>learnrust/</code>.</p>
<h2 id="executing-the-new-program"><a class="header" href="#executing-the-new-program">Executing the new program</a></h2>
<p>The new program we created is called “sample1”, and since we have two programs, 
we now need to specify to <code>cargo run</code> which program to run.</p>
<p>If we try to execute <code>cargo run</code> as usual, it will fail with this:</p>
<pre><code class="language-console">$ cargo run 
error: `cargo run` could not determine which binary to run. 
Use the `--bin` option to specify a binary, or the `default-run` manifest key.
available binaries: learnrust, sample1
</code></pre>
<blockquote>
<p>Please read the error messages. Carefully. 99.9% of the time we get stuck
because we don’t pay attention to what the error is telling us.</p>
</blockquote>
<p>To fix this, we run instead <code>cargo run --bin sample1</code>:</p>
<pre><code class="language-console">$ cargo run --bin sample1
   Compiling learnrust v0.1.0 (/home/deavid/git/rust/lprfl/learnrust)
    Finished dev [unoptimized + debuginfo] target(s) in 0.19s
     Running `target/debug/sample1`
sample program 1
</code></pre>
<p>Now we executed the new program.</p>
<p>Each time we want to add a new program, we just create another file in the 
<code>bin/</code> folder, add it to <code>Cargo.toml</code> as we just did, and voilà! We can have as 
many programs as we want.</p>
<blockquote>
<p>You can name your program as you want, but needs to be all letters, lowercase
and must end with <code>.rs</code>. It may contain numbers, but it must not begin with a 
number. For example <code>example1.rs</code> is fine, but <code>1example.rs</code> is not. You can
use underscores to separate words as well: <code>my_program.rs</code>. Don’t put spaces.</p>
</blockquote>
<h2 id="executing-the-old-program"><a class="header" href="#executing-the-old-program">Executing the old program</a></h2>
<p>Now, as you noticed, the old program in <code>main.rs</code> can no longer be executed by
running <code>cargo run</code>.</p>
<p>Instead, we will need to run <code>cargo run --bin learnrust</code>:</p>
<pre><code class="language-console">$ cargo run --bin learnrust
   Compiling learnrust v0.1.0 (/home/deavid/git/rust/lprfl/learnrust)
    Finished dev [unoptimized + debuginfo] target(s) in 0.18s
     Running `target/debug/learnrust`
Hello, world!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="level-novice-1"><a class="header" href="#level-novice-1">Level: Novice</a></h1>
<p>You got your first program working! Sorcery!</p>
<p>Now we’ll teach you the arcane stuff that nobody knows, the dark arts of coding.</p>
<p>Get ready because we’ll learn lots of new spells: <code>if</code>, <code>for</code> and much more!</p>
<p>Your magic will get powerful very shortly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="its-like-cooking-recipes-seriously"><a class="header" href="#its-like-cooking-recipes-seriously">It’s like cooking recipes, seriously</a></h1>
<p>You may not be into cooking, and that’s fine. 
But probably you know what a cooking recipe is: 
nothing more than a set of steps (instructions) that if followed 
produce the desired result: delicious food.</p>
<p>A program works in the same way. 
It has a set of instructions that should be followed step by step to produce 
the desired result. </p>
<p>There are stupid simple cooking recipes, for example to prepare frozen pizza:</p>
<ul>
<li>Preheat the oven to 180ºC for 10 minutes</li>
<li>Remove the pizza from the box and remove the film</li>
<li>Put the pizza into the oven, on top of a tray.</li>
<li>Wait 15 minutes.</li>
<li>Turn off the oven, remove the pizza and serve.</li>
</ul>
<p>And there are simple computer programs as well:</p>
<ul>
<li>Print one line on the console that says <code>Hello world!</code></li>
<li>end the program.</li>
</ul>
<p>But a common problem in cooking recipes is that they prepare a specific 
amount of food. If you want more or less, you have to tweak <em>“the program”</em> to 
roughly make more or less food to meet your requirements.</p>
<p>In programs, we have inputs (or arguments), where we can add a value and the 
program will take it into account for the calculation. In recipes, this is like 
having a number of “people to serve” and having some formula to scale up the 
ingredients to get the right amount of food.</p>
<p>We also have conditions, which work like those recipe 
steps that say “cook until brown”.</p>
<p>There are loops, which allow us to say “do this 10 times”.</p>
<p>There are functions, which in recipes appears when a meal is very complicated 
and for a particular step says “to do the base of the cake, refer to this other recipe”. 
It avoids repeating ourselves every time that a set of steps we can reuse across recipes.</p>
<p>Of course programs can do things really complicated that are quite far from recipes, 
but if you’re starting to learn, this comparison will serve you to get a 
better grasp on how this all works.</p>
<h2 id="understanding-what-a-program-is"><a class="header" href="#understanding-what-a-program-is">Understanding what a program is</a></h2>
<p>It might appear as a rhetorical question, but what is really a program?</p>
<p>In some sense, a program is a set of instructions that the computer executes in
order. In our case, it will read a file and execute line by line, from the top
to the bottom.</p>
<p>But programs are more than that.</p>
<p>A program can be compiled or interpreted. Interpreted programs, like Python ones,
are actually reading the file and executing the lines. But compiled programs 
like the ones Rust does, actually create something called a “binary”.</p>
<p>Rust will translate all our instructions into another language called “machine 
code”, which is the language that our computer does understand. Then it will
write the file with those instructions. This file is what we call the “binary”
program.</p>
<p>Also, programs can interact with the computer in several ways. For example, they
can accept input from the user, or communicate via the console. And they can also
read arguments when they’re executed.</p>
<p>As part of our journey to learn programming, it is critical that we understand
arguments and input/output in the console.</p>
<h3 id="program-arguments"><a class="header" href="#program-arguments">Program Arguments</a></h3>
<p>Let’s see arguments first.
When you execute a program in the console, it can accept several arguments.</p>
<p>An argument is basically text that we can provide a program to operate.</p>
<p>For example, we can open a browser from the console, passing the URL to open:</p>
<pre><code>$ firefox https://google.com
</code></pre>
<p>The URL is an argument (or parameter) that we provided to Firefox.</p>
<p>In general, we provide arguments like this:</p>
<pre><code>$ myprogram &quot;argument1&quot; &quot;argument2&quot; &quot;argument3&quot;
</code></pre>
<p>And just for the record, they also have “return values” which you can 
check in Bash<sup class="footnote-reference"><a href="#1">1</a></sup>:</p>
<pre><code>$ echo &quot;hello&quot;
$ echo $? 
0
</code></pre>
<p>Zero indicates success. Any other number is an error.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Bash is for Linux and other Unix-alike operating systems. Windows can do
this too, but in a different way.</p>
</div>
<h3 id="input-and-output"><a class="header" href="#input-and-output">Input and Output</a></h3>
<p>A program in the console has by default three ways to communicate:</p>
<ul>
<li>Standard Input  (stdin): This is what the user types in the console.</li>
<li>Standard Output (stdout): This is where the program writes in the console.</li>
<li>Standard Error  (stderr): Here the program sends error messages, usually they
appear in the console too.</li>
</ul>
<p>Very weird names for something tremendously simple:</p>
<pre><code>$ my_program
What is your name:      &lt;--- this is stdout
Waldo                   &lt;--- this is stdin (you type this)

Hello, waldo!

What is your age:
white

&gt;&gt; ERROR: white is not a number! Program failure. &lt;--- this is stderr (an error message)
$
</code></pre>
<p>Hope this serves to explain the basics on how programs have their inputs and 
outputs for the user, as this will be useful later on.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables-are-like-little-boxes-that-store-things-inside"><a class="header" href="#variables-are-like-little-boxes-that-store-things-inside">Variables are like little boxes that store things inside</a></h1>
<p>Printing some texts gets boring very fast. A computer does calculations 
for us, that’s what makes them useful. </p>
<p>It is possible to do simple calculations and print them, but this 
doesn’t have much mystery either:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> println!(&quot;{}&quot;, (2 * (1 + 5) + 3 / 7) / 2);
<span class="boring">}
</span></code></pre></pre>
<p>This will print 6, because it works with integers (whole numbers). 
Just like a regular calculator but without decimal points.</p>
<p>To get a decimal value just use all numbers as decimals, even if it’s <code>2.0</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;{}&quot;, (2.0 * (1.0 + 5.0) + 3.0 / 7.0) / 2.0);
<span class="boring">}
</span></code></pre></pre>
<p>This prints <code>6.214285714285714</code>, just like a calculator with probably more digits.</p>
<p>You’ll notice that Rust will error out if you mix numbers without decimals with 
numbers that do have decimals. We’ll go into more detail on this soon. 
For now, just remember that if you want decimal points, they need to be in all numbers.</p>
<p>Again, this gets boring very easily. We need to spice it up with… variables!</p>
<p>If you did math school before, you probably remember equations. For example:</p>
<p>\[ 1+x = 2x+5 \]</p>
<p>These have an <em>unknown</em> that is \(x\) that must be resolved for. In this case it would be \(x=-4\).</p>
<blockquote>
<p>If you hate math and equations, do not worry. 
This is just to anchor into something you know. In coding we don’t do equations. 
The computer is the one doing math, not us.</p>
</blockquote>
<p>So do we agree that \(x\) is “something” whose value is \(-4\), right?</p>
<p>Ok, hold on to that idea. That is the same for variables. What is not the same is:</p>
<ul>
<li>We don’t have equations. We have instructions. Instructions do things like 
storing something or printing in the terminal.</li>
<li>We don’t have <em>unknowns</em>, and \(x\) in this example is an <em>unknown</em>. 
In programming, we have variables. An <em>unknown</em> is something that we don’t know (yet), while 
a <strong>variable</strong> is something that <strong>always has a value, and we know it</strong>.</li>
</ul>
<p>In Rust, we would do instead:</p>
<pre><code class="language-rust no_run noplayground">x = -4;
</code></pre>
<p>Here <code>x</code> is the variable. It can be any name: <code>a</code>, <code>j</code> or even a word <code>animals</code>. 
Heck, even several words together: <code>number_of_legs_in_a_dog</code>. 
(If you’re a cat person, feel free to set <code>number_of_legs_in_a_cat</code> instead)</p>
<pre><code class="language-rust no_run noplayground">number_of_legs_in_a_cat = 4;
</code></pre>
<p>I did it for you. You can thank me later.</p>
<p>The equals part is an operation, it means “to store”. 
It actually saves the value on the right (number 4) into the name of the left.</p>
<blockquote>
<p>Variables should be named in <code>snake_case</code>, meaning they should be all 
lower case, contain only English characters, and it should start by letter.
Spaces are not valid<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
</blockquote>
<p>So now we do have a name <code>x</code> or <code>number_of_legs_in_a_cat</code> whose value is 4.</p>
<p>The semicolon marks the end of the instruction. This serves to tell Rust that 
this line is something that needs to be executed, and to avoid confusion with 
the next line. If we forget the semicolon, it will think that two lines are 
in fact one and will get confused.</p>
<p>If we translate this line into English it will say:</p>
<blockquote>
<p>Please store the value four into the variable named 
<code>number_of_legs_in_a_cat</code>, end of instruction.</p>
</blockquote>
<!-- TODO: Like a telegram where it said "stop" -->
<p>And from this point, the computer would remember that this name equals to 4, 
so we could print it later:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;{}&quot;, number_of_legs_in_a_cat);
<span class="boring">}
</span></code></pre></pre>
<p>This is actually the same as doing:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;4&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>So, if this is the case, why do we complicate this so much?</p>
<p>Well, variables will help us do much more complex programs, as they 
can keep track of what was the user input or other data that 
we are managing inside. 
It will make sense soon, so bear with me for now.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Actually it’s more flexible than that, Rust also allows some emojis; 
but for simplicity, let’s use only English alphabet.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercise-printing-and-formatting"><a class="header" href="#exercise-printing-and-formatting">Exercise: Printing and Formatting</a></h1>
<p>So we saw that <code>println!()</code> does print lines in the console. Let’s practice a 
bit and see other fun ways of using <code>println!()</code>.</p>
<p>First, we’ll create another program which we’ll call <code>print.rs</code>.</p>
<p>Go ahead and create a new file in <code>learnrust/src/bin/print.rs</code>.</p>
<p>Add the contents:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {}
</code></pre></pre>
<p>Now open <code>Cargo.toml</code> and add:</p>
<pre><code class="language-toml">[[bin]]
name = &quot;print&quot;
</code></pre>
<p>Your <code>Cargo.toml</code> should now look like this:</p>
<pre><code class="language-toml">[package]
name = &quot;learnrust&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at ...

[[bin]]
name = &quot;sample1&quot;

[[bin]]
name = &quot;print&quot;

[dependencies]
</code></pre>
<p>We can now run this program with <code>cargo run --bin print</code>:</p>
<pre><code class="language-console">$ cargo run --bin print
   Compiling learnrust v0.1.0 (/home/deavid/git/rust/lprfl/learnrust)
    Finished dev [unoptimized + debuginfo] target(s) in 0.66s
     Running `target/debug/print`
</code></pre>
<p>As you can see, aside of compiling the program, this does nothing. Pretty 
obvious when you see the code, right? It’s almost empty.</p>
<h2 id="printing-banners-of-text"><a class="header" href="#printing-banners-of-text">Printing banners of text</a></h2>
<p>Say we want to have some banner when the program starts. That would require 
multiple lines and will describe what is this program.</p>
<p>While it’s possible to have multiple lines in a single <code>println!()</code>, I don’t 
recommend this. It’s hard to read and hard to write.</p>
<p>Instead, we’ll just use one <code>println!()</code> per line:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    println!();
    println!(&quot;#############################################################&quot;);
    println!(&quot;#                                                           #&quot;);
    println!(&quot;#                This is a PRINT program                    #&quot;);
    println!(&quot;#                                                           #&quot;);
    println!(&quot;#############################################################&quot;);
    println!();
    println!(&quot;Summary: This program demonstrates different&quot;);
    println!(&quot;         ways of printing text&quot;);
    println!();
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>HINT: On the piece of code above there should appear a “play” button if your
browser supports JavaScript. If you click it, you can see the output of this
program. The play button appears in most of the pieces of code in this book,
so you don’t need to try every single program out.</p>
</blockquote>
<h2 id="placeholders"><a class="header" href="#placeholders">Placeholders</a></h2>
<p>Now, printing text is nice. But soon we will want to replace a part of the text
with something we can replace later on.</p>
<p>For example, consider this piece of code:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    println!(&quot;The sum of 2 + 3 is {}. Isn't that great?&quot;, 2 + 3);
<span class="boring">}
</span></code></pre></pre>
<p>The placeholder is <code>{}</code>. These two characters tell Rust that “here we want to
put a value”. Then after the text, we add a comma and write down the value we 
want. It can be a number, text, or like in this case, an operation.</p>
<p>Rut basically will do the following steps:</p>
<ol>
<li>It will compute the sum we wrote:</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    println!(&quot;The sum of 2 + 3 is {}. Isn't that great?&quot;, 5);
<span class="boring">}
</span></code></pre></pre>
<ol start="2">
<li>Replaces the placeholder with the value:</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    println!(&quot;The sum of 2 + 3 is 5. Isn't that great?&quot;);
<span class="boring">}
</span></code></pre></pre>
<ol start="3">
<li>Prints the text into the console:</li>
</ol>
<pre><code class="language-console">The sum of 2 + 3 is 5. Isn't that great?
</code></pre>
<p>We can use more than one placeholder, just add more values at the end separated
by commas:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    println!(&quot;And {} * {} is {}. Fantastic.&quot;, 4, 3, 12);
<span class="boring">}
</span></code></pre></pre>
<p>This prints: <code>And 4 * 3 is 12. Fantastic.</code></p>
<p>The values must appear in the same order as the placeholders. The first value
corresponds to the first <code>{}</code> from the left, the second value to the second <code>{}</code>.
You get the idea.</p>
<p>If it’s empty, without text or values, it will just print a new line. This can 
be useful to separate parts of the output:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    println!();
<span class="boring">}
</span></code></pre></pre>
<p>But be careful! We cannot put values without a placeholder. This <strong>DOES NOT WORK</strong>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(5 * 10);
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>HINT: Try to click the play button for the above code. It should show you the
error that Rust gives for this particular code.</p>
</blockquote>
<p>Instead, if we just want a value, we need to add a placeholder for it:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;{}&quot;, 5 * 10);
<span class="boring">}
</span></code></pre></pre>
<p>And of course, the number of placeholders must be equal to the number of values
we added. If too many placeholders appear, it will error out:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;{} this placeholder does not have a value-&gt;{}&quot;, 5 * 10);
<span class="boring">}
</span></code></pre></pre>
<p>And in the reverse, if we have too many values, it is also an error:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;{}&quot;, 5, 10, 5 * 10);
<span class="boring">}
</span></code></pre></pre>
<h2 id="understanding-rust-errors"><a class="header" href="#understanding-rust-errors">Understanding Rust errors</a></h2>
<p>Again, please read the errors carefully. They explain a lot of what is wrong.</p>
<p>For example, on the above code we had:</p>
<pre><code class="language-console">error: 2 positional arguments in format string, but there is 1 argument
 --&gt; src/main.rs:4:11
  |
4 | println!(&quot;{} this placeholder does not have a value-&gt;{}&quot;, 5 * 10);
  |           ^^                                         ^^   ------

error: could not compile `playground` due to previous error
</code></pre>
<p><strong>ALWAYS</strong> read the errors from top to bottom! Start from the first line and 
keep reading line by line, like a book. I know this sounds obvious, but in the 
console, we tend to read just the last line:</p>
<pre><code>error: could not compile `playground` due to previous error
</code></pre>
<p>In fact, most people just reads:</p>
<pre><code>error: could not compile
</code></pre>
<p>And forgets about anything else. I swear. Some people just reads <code>error</code> and 
gets puzzled. Don’t be like them. Read the errors from top to bottom.</p>
<p>Let’s break down the error in small parts to understand what it means:</p>
<pre><code>(...) 2 positional arguments in format string (...)
</code></pre>
<p>By “positional arguments”, Rust means that we wrote two placeholders. And 
“format string” is the text to print <code>&quot;{} this placeholder does not have a value-&gt;{}&quot;</code>.</p>
<pre><code>(...), but there is 1 argument
</code></pre>
<p>And the “argument” is the value on the right of the text, in our case <code>, 5 * 10</code>.</p>
<p>So, let’s read again:</p>
<pre><code>error: 2 positional arguments in format string, but there is 1 argument
</code></pre>
<p>Therefore, what Rust means here is:</p>
<blockquote>
<p>You wrote two placeholders <code>{}</code> in the text, but you only provided one 
value on the right: <code>, 5 * 10</code></p>
</blockquote>
<p>And if we keep reading (we must keep reading!), we have a nice help of what’s
happening:</p>
<pre><code class="language-console"> --&gt; src/main.rs:4:11
  |
4 | println!(&quot;{} this placeholder does not have a value-&gt;{}&quot;, 5 * 10);
  |           ^^                                         ^^   ------
</code></pre>
<p>Notice the first line: <code>--&gt; src/main.rs:4:11</code>. This tells us which file has the
problem (in my case I executed this in the browser, so the file does not match
with what we have in our project). The <code>:4:11</code> means <strong>line 4</strong>, character 11. 
Rust is telling us exactly (down to which character) has the problem. This is 
super useful!!</p>
<p>In the next lines, see how it is showing the line of the program that is 
affected. And the characters bellow (<code>^^</code> and <code>-----</code>) are underlining the parts
that are contributing to this error.</p>
<blockquote>
<p><strong>Error messages are super helpful!</strong> Keep reading them<sup class="footnote-reference"><a href="#1">1</a></sup>. They will explain to
you how to fix your program.</p>
</blockquote>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Each time that you reach out for help for an error and turns out that you
didn’t read the error message carefully, put one coin into your 
“Haven’t read the error message” jar. Use the contents to invite your helper
friends to a drink from time to time.</p>
</div>
<h2 id="formatting-numbers"><a class="header" href="#formatting-numbers">Formatting numbers</a></h2>
<p>Now that I’ve been a pain in the neck for long enough about errors, let’s do
something interesting again. Sorry about that, but you’ll thank me later.</p>
<p>Let’s say we want to print some decimal numbers. But sometimes, they’re ugly:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;5.0 / 3.0 = {}&quot;, 5.0 / 3.0);
<span class="boring">}
</span></code></pre></pre>
<p>This prints <code>5.0 / 3.0 = 1.6666666666666667</code><sup class="footnote-reference"><a href="#2">2</a></sup>, and it might be difficult
to read. Wouldn’t it be nice if we could round to two decimals?</p>
<p>Let’s see a few samples:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    println!(&quot;5.0 / 3.0 = {}&quot;, 5.0 / 3.0);
    println!(&quot;5.0 / 3.0 = {:.3}&quot;, 5.0 / 3.0);
    println!(&quot;5.0 / 3.0 = {:.2}&quot;, 5.0 / 3.0);
    println!(&quot;5.0 / 3.0 = {:.0}&quot;, 5.0 / 3.0);
<span class="boring">}
</span></code></pre></pre>
<p>Click on the play button and see how they are rounded to different decimal 
places. Also, notice that Rust rounded the number, so 1.6 becomes 2.</p>
<blockquote>
<p>You can read the full documentation on formatting in here: <a href="https://doc.rust-lang.org/std/fmt/">https://doc.rust-lang.org/std/fmt/</a></p>
</blockquote>
<p>We can also do leading zeros:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;10 / 2 = {:04}&quot;, 5);
<span class="boring">}
</span></code></pre></pre>
<p>And we can mix both together, but be careful because the leading zeros count
all digits and dot. So you need more “leading zeros” to cover for the decimal
places:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;5.0 / 3.0 = {:07.2}&quot;, 5.0 / 3.0);
<span class="boring">}
</span></code></pre></pre>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Note that, depending on your computer and Rust version you might see more or
less decimals; Also the last digits might change. This is normal. Don’t
think much about it. The explanation is an advanced concept that I hope to get
at later stages of this book. For now, let’s move on.</p>
</div>
<h2 id="done"><a class="header" href="#done">Done!</a></h2>
<p>That’s it for now! Feel free to play around and try yourself.</p>
<p>Here’s the program completed:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    println!();
    println!(&quot;#############################################################&quot;);
    println!(&quot;#                                                           #&quot;);
    println!(&quot;#                This is a PRINT program                    #&quot;);
    println!(&quot;#                                                           #&quot;);
    println!(&quot;#############################################################&quot;);
    println!();
    println!(&quot;Summary: This program demonstrates different&quot;);
    println!(&quot;         ways of printing text&quot;);
    println!();
    println!(&quot;The sum of 2 + 3 is {}. Isn't that great?&quot;, 2 + 3);
    println!(&quot;And {} * {} is {}. Fantastic.&quot;, 4, 3, 12);
    println!();
    println!(&quot;5.0 / 3.0 = {}&quot;, 5.0 / 3.0);
    println!(&quot;5.0 / 3.0 = {:.3}&quot;, 5.0 / 3.0);
    println!(&quot;5.0 / 3.0 = {:.2}&quot;, 5.0 / 3.0);
    println!(&quot;5.0 / 3.0 = {:.0}&quot;, 5.0 / 3.0);
    println!();
    println!(&quot;10 / 2 = {:04}&quot;, 5);
    println!(&quot;5.0 / 3.0 = {:07.2}&quot;, 5.0 / 3.0);
    println!();
}
</code></pre></pre>
<p>Remember to write save it in <code>learnrust/src/bin/print.rs</code> and edit <code>Cargo.toml</code>
as I explained on top. </p>
<p>Then run it with: <code>cargo run --bin print</code></p>
<pre><code class="language-console">$ cargo run --bin print
   Compiling learnrust v0.1.0 (/home/deavid/git/rust/lprfl/learnrust)
    Finished dev [unoptimized + debuginfo] target(s) in 1.11s
     Running `target/debug/print`

#############################################################
#                                                           #
#                This is a PRINT program                    #
#                                                           #
#############################################################

Summary: This program demonstrates different
         ways of printing text

The sum of 2 + 3 is 5. Isn't that great?
And 4 * 3 is 12. Fantastic.

5.0 / 3.0 = 1.6666666666666667
5.0 / 3.0 = 1.667
5.0 / 3.0 = 1.67
5.0 / 3.0 = 2

10 / 2 = 0005
5.0 / 3.0 = 0001.67
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="having-fun-with-libraries"><a class="header" href="#having-fun-with-libraries">Having fun with libraries</a></h1>
<p>Doing everything by ourselves might be rewarding, but it is also tiring. 
It takes a lot of effort and knowledge to code a proper program that is really
useful. But I like a saying that goes: <em>“Don’t reinvent the wheel”</em></p>
<p>If you need something, it is highly probable that someone else did it already 
and shared it for free. Seriously. Most of the time it is just a problem of not 
googling enough, or using the right keywords.</p>
<p>People share their functions and modules as libraries called “crates” in a site
called <a href="https://crates.io">https://crates.io</a>.</p>
<p>As a beginner, it is important to use as many crates as you can<sup class="footnote-reference"><a href="#1">1</a></sup>. 
They will allow you to create interesting programs easily, giving you a good 
sense of progress.</p>
<p>The first library I want you to try is “rand”: https://crates.io/crates/rand</p>
<p>This crate as the name suggests creates random numbers. We need to install it in
our project, and for that, notice that on the right side of the website there
are Install instructions and Documentation:</p>
<p>So we will follow the installation instructions. 
We need to open our <code>Cargo.toml</code> file first. 
This file was created when we did <code>cargo new</code>.</p>
<pre><code class="language-toml"> [package]
 name = &quot;learnrust&quot;
 version = &quot;0.1.0&quot;
 edition = &quot;2021&quot;
 
 # See more keys and their definitions at ...
 
 [dependencies]
 rand = &quot;0.8.4&quot;   # Add dependencies here
</code></pre>
<p>We add the new crate to this file by inserting the line <code>rand = &quot;0.8.4&quot;</code> as the instructions say just below the <code>[dependencies]</code>.</p>
<p>If we execute now <code>cargo run</code> we get something different already:</p>
<pre><code> $ cargo run
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.15
   Compiling libc v0.2.107
   Compiling getrandom v0.2.3
   Compiling rand_core v0.6.3
   Compiling rand_chacha v0.3.1
   Compiling rand v0.8.4
   Compiling learnrust v0.1.0 (/home/deavid/git/rust/learnrust)
    Finished dev [unoptimized + debuginfo] target(s) in 2.54s
     Running `target/debug/learnrust`
 Hello world
</code></pre>
<p>Cargo noticed that we have added a new dependency, so it downloaded the 
required libraries and compiled them too! A lot of work that didn’t require 
almost any manual action from our side.</p>
<p>The program however still does the same thing. Just installing a library is not
going to make our program generate random numbers.</p>
<p>The simplest way to start with it is to use <code>rand::random()</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
   let randnum: i64 = rand::random();
   println!(&quot;Hello world: {}&quot;, randnum);
}
</code></pre></pre>
<p>We need to define the type of <code>randnum</code> this time. The reason is that this 
library detects where we want to save it and creates a random number as big as
possible that does fit.</p>
<p>The result is:</p>
<pre><code> deavid@debian:~/git/rust/learnrust$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
     Running `target/debug/learnrust`
 Hello world: 1976599895379426978
 deavid@debian:~/git/rust/learnrust$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
     Running `target/debug/learnrust`
 Hello world: -2920297650750248329
 deavid@debian:~/git/rust/learnrust$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
     Running `target/debug/learnrust`
 Hello world: 8971769657686972258
 deavid@debian:~/git/rust/learnrust$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
     Running `target/debug/learnrust`
 Hello world: -8688429354790802443
</code></pre>
<p>As we can see it creates very big numbers, both positive and negative. 
A different random number will be generated in each run.</p>
<p>We could make the number non-negative and smaller by choosing <code>u8</code> instead of <code>i64</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   let randnum: u8 = rand::random();
<span class="boring">}
</span></code></pre></pre>
<p>This creates the following results:</p>
<pre><code> Hello world: 140
 Hello world: 215
 Hello world: 99
 Hello world: 221
</code></pre>
<p>Because u8 is unsigned and can hold numbers between 0 and 255 \((2^8-1)\), this is the range that we get.</p>
<p>We can instead ask this library for a specific range:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use rand::Rng;

fn main() {
   let mut rng = rand::thread_rng();
   let randnum: i64 = rng.gen_range(1..=100);
   println!(&quot;Hello world: {}&quot;, randnum);
}
</code></pre></pre>
<p>In this case we need to create a random number generator object <code>rng</code>. 
This will be holding the internal state of the random generator. 
It needs to be mutable because the state changes as each number is generated, 
so the numbers aren’t repeated every time.</p>
<p>The <code>gen_range(1..=100)</code> specifies which range of numbers to retrieve, like in 
a for loop, but in this case we only get a single number, randomly.</p>
<p>The <code>use rand::Rng</code> on the top is needed to access the <code>gen_range</code> method. 
This is what Rust calls a Trait. We will go over these later on.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Of course, don’t go crazy and import the whole site. It’s not a race to 
see who imports more crates. Also, as you gain more experience you should be 
able to keep the number of imported libraries low.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="declaring-variables"><a class="header" href="#declaring-variables">Declaring variables</a></h1>
<p>Before we can store values into a variable, we need to declare it. Declaring a 
variable means to tell Rust to create it, we will be explaining to it that this 
name is something that we will be using later.</p>
<!-- TODO: I don't really like this explanation but can't think of anything else -->
<p>Some programming languages don’t require declaring, and just storing a value 
for the first time will do the trick. 
This is the case for Python, but not for Rust.</p>
<p>Anyway, it’s not a big deal. Declaring a variable is very easy, we just have to use <code>let</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   let x;
<span class="boring">}
</span></code></pre></pre>
<p>This comes from the wording in math of <em>“let x be a number…”</em>, so we use 
the keyword let to announce new variable names.</p>
<blockquote>
<p>A keyword is a reserved name by the programming language. 
So this means that you can’t have a variable named <code>let</code>, because <code>let let;</code> 
would be confusing for Rust to understand your program.</p>
</blockquote>
<p>A very simple program that makes use of variables could be:</p>
<pre><pre class="playground"><code class="language-rust edition2021">   fn main() {
      let x;
      x = 4;
      println!(&quot;{}&quot;, x);
   }
</code></pre></pre>
<p>You already know what it does. Prints <code>4</code>. That’s all.</p>
<p>A variable can change their value at any time. 
For this we need to use <code>let mut x</code> instead of <code>let x</code>, so Rust knows that we 
want to mutate the value inside this variable later on (more on this later).</p>
<p>An example:</p>
<pre><pre class="playground"><code class="language-rust edition2021">   fn main() {
      let mut x;
      x = 4;
      println!(&quot;{}&quot;, x);
      x = 6;
      println!(&quot;{}&quot;, x);
      x = 1;
      println!(&quot;{}&quot;, x);
   }
</code></pre></pre>
<p>That will print <code>4</code>, then <code>6</code>, then <code>1</code>. 
It’s just that the variable has changed the value it 
contained over time, as the program runs. 
Then the <code>println!()</code> just reads the value at that point in time and prints 
it to the terminal.</p>
<p>An important thing here, we have to use <code>let mut x</code> instead of just <code>let x</code> 
to tell Rust that this variable is “mutable”, this means that we can change 
the contents later on.</p>
<p>We can declare one variable per line, each one with its own let:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x;
let y;
let z;
<span class="boring">}
</span></code></pre></pre>
<p>But we can’t declare these in a single let instruction. 
Other programming languages such as C++ allow separating them with commas, but not in Rust. 
We need one line for each one.</p>
<p>Most of the time we declare a variable we actually want to give them a value, 
because after all a value must always have a value at all times. 
So we can save a few lines and do it in one shot:</p>
<!-- TODO: Why can we declare without assigning if it has to have a value anyway? -->
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 4;
let y = 3;
let z = 2;
<span class="boring">}
</span></code></pre></pre>
<p>So now this does two things at the same time, it declares, and it stores a value. 
To be clear, this is just shorter and nicer on our eyes. 
To the computer, it is exactly the same as if we declared first, 
and then we used another 3 lines to store the value. 
The program will be identical and will run equally fast.</p>
<p>Bottom line: do you prefer to see it on three lines all together or in six lines? 
Which one is easier to understand and read for you? 
Whatever is your response, that should be what you should write.</p>
<p>We don’t write the programs for computers, we write them for humans to understand. 
If you think that a particular way is easier to read and understand, go with it.</p>
<p>As you’ll start to notice by now, there are several ways to write a program 
(in fact, they’re infinite). 
This might feel annoying. Worse even, there’s no “right way”. 
There are subjectively better and worse ways, but it’s always up to humans 
to define what looks and feels better and come up with reasons for it.</p>
<p>Don’t be bothered about this, don’t think much about this. It is fine. 
Just write what it feels better to you personally, and you’ll be grand. 
Over time, you’ll learn more about how to make the code more readable, 
but that comes with experience. For now, let’s focus on learning this.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercise-variables"><a class="header" href="#exercise-variables">Exercise: Variables</a></h1>
<p>In the last exercise we saw lots of ways to print, but to be fair, using
placeholders doesn’t make much sense if we have to write what goes inside, right?</p>
<p>So in this one we’ll explore how to combine the previous things we learned with 
variables.</p>
<p>First things first, we’ll create a new program again. This time we will call it
<code>variables.rs</code>. </p>
<p>So go ahead and create it in the folder <code>learnrust/src/bin/</code>.</p>
<p>As usual, we will start with <code>fn main() {}</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {

}
</code></pre></pre>
<p>Now go to <code>Cargo.toml</code> and add:</p>
<pre><code class="language-toml">[[bin]]
name = &quot;variables&quot;
</code></pre>
<p>Test that it works by running:</p>
<pre><code class="language-console">$ cargo run --bin variables
</code></pre>
<h1 id="hello-waldo"><a class="header" href="#hello-waldo">Hello, Waldo!</a></h1>
<p>Let’s try a variation of the mythical “Hello, World!” program:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let name = &quot;Waldo&quot;;
    println!(&quot;Hello, {}!&quot;, name);
<span class="boring">}
</span></code></pre></pre>
<p>And we can try a few variables with numbers and math:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let a = 3;
    let b = 7;
    let c = a * b;
    println!(&quot;The result of {} * {} is {}&quot;, a, b, c);
<span class="boring">}
</span></code></pre></pre>
<p>Let’s try to mutate one variable over and over:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut x = 4;
    let a = 3;
    println!(&quot;{}&quot;, x);
    x = 6;
    println!(&quot;{}&quot;, x);
    x = 1 + a;
    println!(&quot;{}&quot;, x);
<span class="boring">}
</span></code></pre></pre>
<p>We can also do operations with variables:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let x = 4;
    let a = 3;
    println!(&quot;{} + {} = {}&quot;, x, a, x + a);
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>HINT: Remember you have the play button/icon on each code block to execute 
these samples in your browser.</p>
</blockquote>
<h2 id="done-1"><a class="header" href="#done-1">Done!</a></h2>
<p>Here’s the full program:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let name = &quot;Waldo&quot;;
    println!(&quot;Hello, {}!&quot;, name);

    let a = 3;
    let b = 7;
    let c = a * b;
    println!(&quot;The result of {} * {} is {}&quot;, a, b, c);

    let mut x = 4;
    let a = 3;
    println!(&quot;{}&quot;, x);
    x = 6;
    println!(&quot;{}&quot;, x);
    x = 1 + a;
    println!(&quot;{}&quot;, x);

    let x = 4;
    let a = 3;
    println!(&quot;{} + {} = {}&quot;, x, a, x + a);
}
</code></pre></pre>
<p>The output is:</p>
<pre><code>Hello, Waldo!
The result of 3 * 7 is 21
4
6
4
4 + 3 = 7
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lets-try-turtle"><a class="header" href="#lets-try-turtle">Let’s try Turtle!</a></h1>
<p>For learning purposes, there was a little program called <code>turtle</code> in the 80s for
a programming language called LOGO.</p>
<p>This was intended for kids to learn coding. It displayed a little turtle, and
they could send commands such as:</p>
<ul>
<li>Move right 30 pixels.</li>
<li>Move top 30 pixels.</li>
<li>Move left 30 pixels.</li>
<li>Move bottom 30 pixels.</li>
</ul>
<p>And that would create a rectangle on screen.</p>
<p>This is fascinating for learning because there is a visual feedback on the 
screen. And let’s face it, the console is booooring.</p>
<p>In Rust, there’s a library for this and I think it’s worth exploring.</p>
<p>If it doesn’t work for you, or if you prefer console, just move on. I’ll have
examples for everything in the console.</p>
<p>The library is this one: <a href="https://crates.io/crates/turtle">https://crates.io/crates/turtle</a></p>
<p>What we should do now is add this library as a dependency to our <code>Cargo.toml</code>
like this:</p>
<pre><code class="language-toml">[dependencies]
turtle = { git = &quot;https://github.com/sunjay/turtle.git&quot;, tag = &quot;v1.0.0-rc.2&quot; }
</code></pre>
<p>We just need to add the line<sup class="footnote-reference"><a href="#1">1</a></sup> 
<code>turtle = { git = &quot;https://github.com/sunjay/turtle.git&quot;, tag = &quot;v1.0.0-rc.2&quot; }</code> 
at the end of the file, just below <code>[dependencies]</code>.</p>
<p><strong>BEFORE GOING FURTHER:</strong> Please verify this does work for you. Run <code>cargo build</code>
on the terminal and ensure that there are no errors.</p>
<p>Here’s what happens on my computer after running this the first time:</p>
<pre><code class="language-console">$ cargo build
   Compiling lazy_static v1.4.0
   Compiling bitflags v1.3.2
   Compiling byteorder v1.4.3
   Compiling scopeguard v1.1.0
   Compiling cfg-if v0.1.10
   Compiling piston-float v1.0.1
   Compiling rand_core v0.4.2
   Compiling void v1.0.2
   Compiling adler32 v1.2.0
   Compiling downcast-rs v1.2.0
   Compiling piston-graphics_api_version v0.2.0
   Compiling same-file v1.0.6
   Compiling lzw v0.10.0
   Compiling either v1.6.1
   Compiling cty v0.2.2
   Compiling color_quant v1.1.0
   Compiling piston-texture v0.8.0
   Compiling percent-encoding v2.1.0
   Compiling scoped_threadpool v0.1.9
   Compiling read_color v1.0.0
   Compiling interpolation v0.2.0
   Compiling fnv v1.0.7
   Compiling piston-shaders_graphics2d v0.3.1
   Compiling itoa v1.0.1
   Compiling ryu v1.0.9
   Compiling svg v0.6.0
   Compiling libloading v0.6.7
   Compiling lock_api v0.3.4
   Compiling draw_state v0.8.0
   Compiling inflate v0.4.5
   Compiling piston-viewport v1.0.2
   Compiling vecmath v1.0.0
   Compiling rand_core v0.3.1
   Compiling rand_jitter v0.1.4
   Compiling raw-window-handle v0.4.3
   Compiling libc v0.2.125
   Compiling crossbeam-utils v0.8.8
   Compiling maybe-uninit v2.0.0
   Compiling crc32fast v1.3.2
   Compiling shader_version v0.6.0
   Compiling walkdir v2.3.2
   Compiling gif v0.10.3
   Compiling stb_truetype v0.3.1
   Compiling deflate v0.7.20
   Compiling num-traits v0.2.15
   Compiling memoffset v0.6.5
   Compiling libloading v0.5.2
   Compiling dlib v0.4.2
   Compiling rand_hc v0.1.0
   Compiling rand_xorshift v0.1.1
   Compiling rand_isaac v0.1.1
   Compiling crossbeam-channel v0.5.4
   Compiling rand_chacha v0.1.1
   Compiling rand_pcg v0.1.2
   Compiling gfx_core v0.9.2
   Compiling smallvec v0.6.14
   Compiling crossbeam-epoch v0.9.8
   Compiling wayland-sys v0.21.13
   Compiling glutin_egl_sys v0.1.5
   Compiling gfx_gl v0.6.1
   Compiling serde v1.0.137
   Compiling gl v0.11.0
   Compiling dirs-sys v0.3.7
   Compiling nix v0.14.1
   Compiling num_cpus v1.13.1
   Compiling memmap v0.7.0
   Compiling x11-dl v2.19.1
   Compiling raw-window-handle v0.3.4
   Compiling shared_library v0.1.9
   Compiling rand_os v0.1.3
   Compiling parking_lot_core v0.6.2
   Compiling png v0.15.3
   Compiling crossbeam-deque v0.8.1
   Compiling dirs v4.0.0
   Compiling rand v0.6.5
   Compiling osmesa-sys v0.1.2
   Compiling ordered-float v1.1.1
   Compiling approx v0.3.2
   Compiling line_drawing v0.7.0
   Compiling num-integer v0.1.45
   Compiling tiff v0.3.1
   Compiling parking_lot v0.9.0
   Compiling rayon-core v1.9.3
   Compiling xdg v2.4.1
   Compiling rusttype v0.8.3
   Compiling num-rational v0.2.4
   Compiling num-iter v0.1.43
   Compiling gfx v0.18.2
   Compiling gfx_device_gl v0.16.2
   Compiling rusttype v0.7.9
   Compiling andrew v0.2.1
   Compiling piston2d-graphics v0.35.0
   Compiling rayon v1.5.3
   Compiling glutin_glx_sys v0.1.7
   Compiling pistoncore-input v0.28.1
   Compiling serde_json v1.0.81
   Compiling wayland-commons v0.21.13
   Compiling wayland-client v0.21.13
   Compiling jpeg-decoder v0.1.22
   Compiling pistoncore-window v0.44.0
   Compiling pistoncore-event_loop v0.49.0
   Compiling wayland-protocols v0.21.13
   Compiling piston v0.49.0
   Compiling image v0.22.5
   Compiling smithay-client-toolkit v0.4.6
   Compiling piston-gfx_texture v0.40.0
   Compiling piston2d-gfx_graphics v0.66.0
   Compiling winit v0.19.5
   Compiling glutin v0.21.2
   Compiling pistoncore-glutin_window v0.63.0
   Compiling piston_window v0.105.0
   Compiling turtle v1.0.0-rc.3
   Compiling learnrust v0.1.0 (/home/deavid/git/rust/lprfl/learnrust)
    Finished dev [unoptimized + debuginfo] target(s) in 14.61s
</code></pre>
<p>If we run it again, it will be much shorter. This is correct:</p>
<pre><code>$ cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.03s
</code></pre>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>I had to use the Git repository and the tag <code>v1.0.0-rc.2</code> because 
<code>v1.0.0-rc.3</code> which is the latest one crashes for me, and just specifying the
RC version doesn’t seem to be something that Cargo likes for this package.</p>
</div>
<h1 id="testing-turtle"><a class="header" href="#testing-turtle">Testing Turtle</a></h1>
<p>Let’s begin by creating a file <code>turtle_vars.rs</code> in <code>learnrust/src/bin/</code> and
place the following example code inside:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use turtle::Turtle;

fn main() {
    let mut turtle = Turtle::new();

    turtle.forward(10.0);
}
</code></pre></pre>
<p>Now, remember that we have to add this program into <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[[bin]]
name = &quot;turtle_vars&quot;
</code></pre>
<p>And now, let’s test this:</p>
<pre><code class="language-console">$ cargo run --bin turtle_vars
</code></pre>
<p>This should display a window like this:</p>
<p><img src="L02novice/../img/turtle_vars_01.png" alt="Small arrow up" /></p>
<p>If this is what you see, congrats! It works for you!</p>
<h1 id="drawing-a-rectangle"><a class="header" href="#drawing-a-rectangle">Drawing a rectangle</a></h1>
<p>As explained at the beginning, we just need a few commands to do this.</p>
<p>Basically, we can tell the turtle to turn right while moving, and if done
in four steps, we should get a rectangle:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    turtle.forward(100.0);
    turtle.right(90.0);
    turtle.forward(100.0);
    turtle.right(90.0);
    turtle.forward(100.0);
    turtle.right(90.0);
    turtle.forward(100.0);
<span class="boring">}
</span></code></pre></pre>
<p>And this gives us a nice animation. The end result is:</p>
<p><img src="L02novice/../img/turtle_vars_02.png" alt="Square" /></p>
<p>But wait! What does <code>100.0</code> mean? And <code>90.0</code>?</p>
<p>The first one is the distance to move, the second one is the angle to turn.</p>
<p>So the program really says:</p>
<ul>
<li>Walk forward 100 pixels.</li>
<li>Turn right 90 degrees.</li>
<li>Now walk forward again 100 pixels.</li>
<li>Turn right again 90 degrees.</li>
<li>Walk again 100 pixels.</li>
<li>Right by 90 degrees.</li>
<li>Walk 100 pixels.</li>
</ul>
<p>But to someone reading the program it might be confusing to understand.</p>
<p>Also, what if we want to make the rectangle bigger or smaller? We would need
to change the <code>100.0</code> in all four places. That’s a lot of work!<sup class="footnote-reference"><a href="#2">2</a></sup></p>
<p>So let’s use variables to prevent repetition:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let distance = 100.0;
    let angle = 90.0;

    turtle.forward(distance);
    turtle.right(angle);
    turtle.forward(distance);
    turtle.right(angle);
    turtle.forward(distance);
    turtle.right(angle);
    turtle.forward(distance);
<span class="boring">}
</span></code></pre></pre>
<p>Nice! Now if we want to make it bigger we just change:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let distance = 200.0;
    let angle = 90.0;
<span class="boring">}
</span></code></pre></pre>
<p>But what happens if we change the angle? Let’s try it out!</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let distance = 200.0;
    let angle = 120.0;
<span class="boring">}
</span></code></pre></pre>
<p><img src="L02novice/../img/turtle_vars_03.png" alt="Triangle" /></p>
<p>It draws a triangle! Wait, what?!</p>
<p>That’s because a regular polygon has their sides separated by an angle defined by:</p>
<p>\[angle = 360 / sides \]</p>
<p>And \(360/3=120\), so 120 degrees is just a triangle.</p>
<p>Wait a second… can we make this, so it can do different polygons?</p>
<p>Sure! First we copy the <code>forward</code> and <code>right</code> commands a few times more:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let distance = 200.0;
    let angle = 120.0;

    turtle.forward(distance);
    turtle.right(angle);
    turtle.forward(distance);
    turtle.right(angle);
    turtle.forward(distance);
    turtle.right(angle);
    turtle.forward(distance);
    turtle.right(angle);
    turtle.forward(distance);
    turtle.right(angle);
    turtle.forward(distance);
    turtle.right(angle);
    turtle.forward(distance);
    turtle.right(angle);
    turtle.forward(distance);
    turtle.right(angle);
    turtle.forward(distance);
<span class="boring">}
</span></code></pre></pre>
<p>Now we can compute the angle by using the formula:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let sides = 5.0;
    let distance = 200.0;
    let angle = 360.0 / sides;
<span class="boring">}
</span></code></pre></pre>
<p>And we get a new figure:</p>
<p><img src="L02novice/../img/turtle_vars_04.png" alt="Pentagon" /></p>
<p>Try playing yourself with the values and see what happens each time. </p>
<ul>
<li>What happens if we put <code>sides = 10.0</code> and <code>distance = 50.0</code>? Why?</li>
<li>What happens if we change <code>angle = 300.0</code> and <code>sides = 8.0</code>?</li>
<li>And <code>angle = 315.0</code> and <code>sides = 5.0</code>?</li>
</ul>
<hr />
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Yes, we programmers are lazy. How could you have guessed that?</p>
</div>
<h2 id="thats-it"><a class="header" href="#thats-it">That’s it!</a></h2>
<p>Well done. Hope you enjoyed this.</p>
<p>Yes, there’s still a lot of repetition in the code, 
but well get to that very soon.</p>
<p>Here’s the full program:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use turtle::Turtle;

fn main() {
    let mut turtle = Turtle::new();

    let sides = 5.0;
    let distance = 200.0;
    let angle = 360.0 / sides;

    turtle.forward(distance);
    turtle.right(angle);
    turtle.forward(distance);
    turtle.right(angle);
    turtle.forward(distance);
    turtle.right(angle);
    turtle.forward(distance);
    turtle.right(angle);
    turtle.forward(distance);
    turtle.right(angle);
    turtle.forward(distance);
    turtle.right(angle);
    turtle.forward(distance);
    turtle.right(angle);
    turtle.forward(distance);
    turtle.right(angle);
    turtle.forward(distance);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="incrementing-and-decrementing"><a class="header" href="#incrementing-and-decrementing">Incrementing and decrementing</a></h1>
<p>There’s a lot of stuff we can do with variables, but a very common thing is 
to use them to count, so an instruction that just says 
“add one to X” is quite handy:</p>
<pre><pre class="playground"><code class="language-rust edition2021"> fn main() {
   let mut x = 4;
   println!(&quot;{}&quot;, x);
   x += 1;
   println!(&quot;{}&quot;, x);
   x += 2;
   println!(&quot;{}&quot;, x);
   x += 3;
   println!(&quot;{}&quot;, x);
  }
</code></pre></pre>
<p>This program will output <code>4</code>, <code>5</code>, <code>7</code> and <code>10</code>.</p>
<p>The other way around, subtracting, is also possible:</p>
<pre><pre class="playground"><code class="language-rust edition2021"> fn main() {
   let mut x = 10;
   println!(&quot;{}&quot;, x);
   x -= 1;
   println!(&quot;{}&quot;, x);
   x -= 1;
   println!(&quot;{}&quot;, x);
   x -= 1;
   println!(&quot;{}&quot;, x);
  }
</code></pre></pre>
<p>This one returns <code>10</code>, <code>9</code>, <code>8</code> and <code>7</code>.</p>
<p>These operations are just a shorthand of this:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   x = x + 1;
   x = x - 1;
<span class="boring">}
</span></code></pre></pre>
<p>Which just means: read “x”, add one, and write the result into “x” again; 
overwriting the previous content.</p>
<p>A reminder: these are instructions, not math equations. 
The equals sign stores on the left the result of evaluating the right side.</p>
<p>Most operations you can think of that take the same form have a shortened 
operator as well. 
For example doubling a number is just <code>x *= 2</code>, which means <code>x = x * 2</code>.</p>
<h2 id="the-modulo-or-remainder-operator"><a class="header" href="#the-modulo-or-remainder-operator">The modulo or remainder operator</a></h2>
<p>Something that is little known is that in programming we have an operator
to get the remainder of a division.</p>
<p>For example, if we do <code>12 / 10 = 1</code>, but the remainder of that division is 2.</p>
<p>To get the remainder we use the modulo operator <code>%</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = 35;
let b = 10;
let remainder = v % b;
println!(&quot;{} % {} = {}&quot;, v, b, remainder);
<span class="boring">}
</span></code></pre></pre>
<p>This operator is useful when we want a value that wraps around a particular
number. For example when counting time, seconds goes to 60, then back to zero.</p>
<p>So if we do:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let time_sec = 100322;
let seconds = time_sec % 60;
<span class="boring">}
</span></code></pre></pre>
<p>It will make the <code>seconds</code> variable to be on the range 0…60, excluding 60.</p>
<p>This, with the use of divisions, it can make for a very easy code to transform
a lot of seconds into hours, minutes, and seconds. Here’s the recipe.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let time_sec = 100322;
let seconds = (time_sec) % 60;
let minutes = (time_sec / 60) % 60;
let hours =   (time_sec / 60 / 60) % 24;
let days =    (time_sec / 24 / 60 / 60) % 30;
let months =  (time_sec / 30 / 24 / 60 / 60) % 12;
let years =   (time_sec / 12 / 30 / 24 / 60 / 60);
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>NOTE: The operator actually computes the modulo, not the remainder, which
is almost the same, but not identical. For negative values it behaves 
differently.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="looping-around"><a class="header" href="#looping-around">Looping’ around</a></h1>
<p>I’m sure you feel that variables don’t do that much. 
But that’s because the programs we can write up to now are too linear and simple. 
We need to step up the game with… loops!</p>
<p>Loops are ways of repeating the same piece of code several times without 
need of copying and pasting. 
For example, imagine we want to make a simple program that counts from 1 to 100:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
   println!(&quot;Number {}&quot;, 1);
   println!(&quot;Number {}&quot;, 2);
   println!(&quot;Number {}&quot;, 3);
   // ...
   println!(&quot;Number {}&quot;, 98);
   println!(&quot;Number {}&quot;, 99);
   println!(&quot;Number {}&quot;, 100);
 }
</code></pre></pre>
<p>As you can imagine, this gets tedious very easily. 
Copying, pasting and changing all the numbers manually is cumbersome.</p>
<p>Presenting… the for loop!</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
   for number in 1..=100 {
       println!(&quot;Number {}&quot;, number);
   }
 }
</code></pre></pre>
<p>This program does exactly the same thing in just three lines! Amazing, isn’t it? 
Now variables are actually being useful.</p>
<p>The syntax for this is as follows<sup class="footnote-reference"><a href="#1">1</a></sup>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for variable_name in first_number..=last_number
<span class="boring">}
</span></code></pre></pre>
<p>We are asking the program to have a variable that counts from 1 to 100. 
The current count number will be stored in the variable <code>number</code> 
(which we can name it as we like).</p>
<p>The <code>..=</code> in between the numbers defines a range. 
The equals on the right means that it includes the right number. 
There also exists <code>..</code> which does not include the last number 
(i.e., <code>0..100</code> counts from 0 to 99).</p>
<p>We can also put a loop inside a loop, so we can count in two directions. 
This could be useful to describe all positions in a chess board:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
   for row in 1..=8 {
       for column in 1..=8 {
           println!(&quot;Row {}, Column {}&quot;, row, column);
       }
   }
 }
</code></pre></pre>
<p>And of course, there’s no limit. 
You could put three or ten loops one inside another. 
The limit is your imagination here!</p>
<p>In this code, it will first pick a row, then go over all the columns. 
When the program finishes all 8 columns, it will proceed with the next row.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>As usual, I’m lying, and it’s not the real syntax. For loops are way more
powerful than this; we’ll get to that later.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercise-loops"><a class="header" href="#exercise-loops">Exercise: loops</a></h1>
<p>Do you know Fibonacci numbers? These are a sequence in math that go:</p>
<pre><code>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144,...
</code></pre>
<p>Each number in this list has to be the sum of the previous two numbers.</p>
<p>We start with zero and one and begin adding them together:</p>
<pre><code>0 + 1 = 1
1 + 1 = 2
1 + 2 = 3
2 + 3 = 5
3 + 5 = 8
</code></pre>
<p>But why Fibonacci numbers? Well, they’re easy to calculate. Nothing too fancy.</p>
<p>Also, they are closely related to lots of stuff in math. The golden ratio.
The pascal triangle. The rate at which vampires (and bunnies) breed. The size
of an A4. The binomial distribution.</p>
<p><a href="https://en.wikipedia.org/wiki/Fibonacci_number">https://en.wikipedia.org/wiki/Fibonacci_number</a></p>
<p>Let’s make a program that calculates several thousands of these!</p>
<p>Yeah, exciting. I know.</p>
<p>Again, let’s make a new binary <code>fibonacci.rs</code> inside <code>src/bin/</code> and add
a <code>fn main() {}</code>.</p>
<p>Also, in <code>Cargo.toml</code>, remember to add:</p>
<pre><code class="language-toml">[[bin]]
name = &quot;fibonacci&quot;
</code></pre>
<blockquote>
<p>At some point, I’ll stop telling you to do these steps. Don’t forget to do 
this!</p>
</blockquote>
<h2 id="lets-create-the-main-thingy"><a class="header" href="#lets-create-the-main-thingy">Let’s create the main thingy</a></h2>
<p>So we know we want lots of numbers and a loop.</p>
<p>First, let’s do it without a loop for 2 or 3 numbers.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let n1 = 0;
    let n2 = 1;
    println!(&quot;{} {}&quot;, n1, n2);

    let n3 = n1 + n2;

    println!(&quot;{}&quot;, n3);

    let n1 = n2;
    let n2 = n3;

    let n3 = n1 + n2;

    println!(&quot;{}&quot;, n3);
<span class="boring">}
</span></code></pre></pre>
<p>We first define <code>n1</code> and <code>n2</code> as the initial numbers \(0,1\). This part is what 
initializes the Fibonacci. </p>
<p>Then we compute <code>n3 = n1 + n2</code>. Each number is the sum of the last two.</p>
<p>In the next step we need to move the numbers to the left, so <code>n3</code> becomes <code>n2</code>
and <code>n2</code> becomes <code>n1</code>. And then we can compute <code>n3</code> again.</p>
<p>However, the order here matters. If we first move <code>n3</code> into <code>n2</code>, we will lose
the contents in <code>n2</code>.</p>
<p>Instead, we need to move first <code>n2</code> to <code>n1</code> to avoid losing any data.</p>
<h2 id="now-onto-the-loop"><a class="header" href="#now-onto-the-loop">Now onto the loop!</a></h2>
<p>We make the <code>n1</code> and <code>n2</code> variables mutable and keep everything in a loop:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut n1 = 0;
    let mut n2 = 1;
    println!(&quot;{} {}&quot;, n1, n2);
    for _ in 0..10 {
        let n3 = n1 + n2;

        println!(&quot;{}&quot;, n3);

        n1 = n2;
        n2 = n3;
    }
<span class="boring">}
</span></code></pre></pre>
<p>That’s it! We have Fibonacci numbers!</p>
<p>It’s really fast, right?</p>
<blockquote>
<p>NOTE: We had to use the <code>mut</code> keyword to indicate to Rust that we want to be
able to change the contents of a variable. Otherwise, the compiler 
would complain.</p>
</blockquote>
<p>But it’s hard to read. Let’s do something about it. What if we print 10 per line?</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut n1 = 0;
    let mut n2 = 1;
    print!(&quot;{},{},&quot;, n1, n2);
    for _ in 0..10 {
        for _ in 0..10 {
            let n3 = n1 + n2;

            print!(&quot;{},&quot;, n3);

            n1 = n2;
            n2 = n3;
        }
        println!()
    }
<span class="boring">}
</span></code></pre></pre>
<p>Oh no…</p>
<pre><code class="language-console">0,1,1,2,3,5,8,13,21,34,55,89,
144,233,377,610,987,1597,2584,4181,6765,10946,
17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,
2178309,3524578,5702887,9227465,14930352,24157817,39088169,63245986,102334155,165580141,
thread 'main' panicked at 'attempt to add with overflow', src/bin/fibonacci.rs:45:22
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<p>What happened here?</p>
<p>Turns out that our numbers are getting too big, and they don’t fit.</p>
<p>By default, Rust is using 32bits (4 bytes) for each number, so they can hold
any number up to \(2^{31} = 2147483648\).</p>
<p>We could tell Rust to use 64bit instead, but no. We’ll be using floating points.</p>
<p>Floating points have less precision than integers, but they can cover numbers
way bigger and way smaller than integers themselves.</p>
<p>All that we need to do is add a decimal place to <code>n1</code> and <code>n2</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut n1 = 0.0;
    let mut n2 = 1.0;
    print!(&quot;{},{},&quot;, n1, n2);
    for _ in 0..10 {
        for _ in 0..10 {
            let n3 = n1 + n2;

            print!(&quot;{},&quot;, n3);

            n1 = n2;
            n2 = n3;
        }
        println!()
    }
<span class="boring">}
</span></code></pre></pre>
<p>Yay! That worked!</p>
<pre><code>0,1,1,2,3,5,8,13,21,34,55,89,
144,233,377,610,987,1597,2584,4181,6765,10946,
17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,
2178309,3524578,5702887,9227465,14930352,24157817,39088169,63245986,102334155,165580141,
267914296,433494437,701408733,1134903170,1836311903,2971215073,4807526976,7778742049,12586269025,20365011074,
32951280099,53316291173,86267571272,139583862445,225851433717,365435296162,591286729879,956722026041,1548008755920,2504730781961,
4052739537881,6557470319842,10610209857723,17167680177565,27777890035288,44945570212853,72723460248141,117669030460994,190392490709135,308061521170129,
498454011879264,806515533049393,1304969544928657,2111485077978050,3416454622906707,5527939700884757,8944394323791464,14472334024676220,23416728348467684,37889062373143900,
61305790721611580,99194853094755490,160500643816367070,259695496911122560,420196140727489660,679891637638612200,1100087778366101900,1779979416004714000,2880067194370816000,4660046610375530000,
7540113804746346000,12200160415121877000,19740274219868226000,31940434634990100000,51680708854858330000,83621143489848430000,135301852344706760000,218922995834555200000,354224848179262000000,573147844013817200000,
</code></pre>
<p>Okay, I know. This is not really helpful. This program might be somewhat helpful
to some mathematician, but not for you and not for me either.</p>
<p>But we have to endure these silly examples for now. At our current level it is 
very hard to find anything to do that it’s actually possible with what
I explained so far.</p>
<p>It is important to practice. And these examples will help you get an idea on how
the syntax works.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="turtle-loops"><a class="header" href="#turtle-loops">Turtle: loops</a></h1>
<p>We had this program:</p>
<pre><pre class="playground"><code class="language-rust edition2021">use turtle::Turtle;

fn main() {
    let mut turtle = Turtle::new();

    let sides = 5.0;
    let distance = 200.0;
    let angle = 360.0 / sides;

    turtle.forward(distance);
    turtle.right(angle);
    turtle.forward(distance);
    turtle.right(angle);
    turtle.forward(distance);
    turtle.right(angle);
    turtle.forward(distance);
    turtle.right(angle);
    turtle.forward(distance);
    turtle.right(angle);
    turtle.forward(distance);
    turtle.right(angle);
    turtle.forward(distance);
    turtle.right(angle);
    turtle.forward(distance);
    turtle.right(angle);
    turtle.forward(distance);
}
</code></pre></pre>
<p>Now, use loops to make it easier to read and less copy-paste.</p>
<pre><pre class="playground"><code class="language-rust edition2021">use turtle::Turtle;

fn main() {
    let mut turtle = Turtle::new();

    let sides = 5.0;
    let distance = 200.0;
    let angle = 360.0 / sides;
    for _ in 0..30 {
        turtle.forward(distance);
        turtle.right(angle);
    }
}
</code></pre></pre>
<p>As you can see, loops are very useful to avoid repeating. But also, don’t 
forget that the number of “loops” that happen doesn’t need to be fixed.</p>
<p>We can use variables, user input, and other stuff to determine for how long
to loop.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-some-comments"><a class="header" href="#adding-some-comments">Adding some comments</a></h1>
<p>The programs are sometimes hard to understand, and it would be nice to leave
some notes for the people reading it, so they can understand it too. 
And I bet you that you’ll forget what a program does after 3 months, 
even if you wrote it yourself. It happens to me too. 
So it’s good to have some notes on the program, so we can understand it later.</p>
<p>They can also be used to denote that some work is yet missing 
(we call these <code>TODO</code>) so it serves as a reminder for later on. 
But we all know that we will never get to do them. 
That’s how it works in reality, trust me.</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
   // Compute all the cells in a Chess Board:
   for row in 1..=8 {
       for column in 1..=8 {
           // TODO: For now just display the numbers, we'll fix this &quot;&quot;later&quot;&quot;.
           println!(&quot;Row {}, Column {}&quot;, row, column);
       }
   }
 }
</code></pre></pre>
<p>Most comments use the double slash <code>//</code>. 
When Rust sees this, it ignores any text on the right side of it, 
so we can use this to add our thoughts on the program.</p>
<p>However, if you need to comment out a lot of lines, 
adding <code>//</code> to every line can be daunting. 
VS Code has shortcuts for this (and you can customize them) so it’s easier.</p>
<!-- Shortcut for VSCode for comments - default and how to customize -->
<p>But Rust also has comment blocks. 
A comment block starts with <code>/*</code> and ends with <code>*/</code>. 
Rust will ignore everything in the middle, even if there are multiple lines.</p>
<pre><pre class="playground"><code class="language-rust edition2021">/*fn main() {
   for row in 1..=8 {
       for column in 1..=8 {
           println!(&quot;Row {}, Column {}&quot;, row, column);
       }
   }
 }*/
</code></pre></pre>
<p>Voilà. Now we no longer have any program. From Rust’s perspective, the file is empty.</p>
<p>But these comment types are a bit trickier. They cannot be nested. If you try to add a block comment on something that already contains a comment block inside, Rust will get confused.</p>
<p>Because of this, I prefer to avoid these and stick with the simple and reliable double slash (//).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-if"><a class="header" href="#what-if">What If…?</a></h1>
<p>…it is raining outside? You should get an umbrella, right?</p>
<p>This is basically a conditional: If it’s raining, get an umbrella. 
We have these in Rust and use the keyword “if”. 
The name may not sound original at all, but helps to read the program 
as if it were English.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
   let apples = 6;
   if apples &gt; 1 {
       println!(&quot;You have many apples!&quot;);
   }
 }
</code></pre></pre>
<p>This program will print <code>You have many apples!</code> only if the 
<code>apples</code> variable is bigger than one.</p>
<p>Of course, it only changes if you manually go and change the variable value. 
Don’t go that fast! We’ll see something useful soon.</p>
<p>The syntax is:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if condition { 
    // ... what to do if the condition is true ... 
} else { 
    // ... what to do if it's not ... 
}
<span class="boring">}
</span></code></pre></pre>
<p>Condition can be anything that is either true or false. Some examples:</p>
<ul>
<li><code>apples == 1</code> → if <code>apples</code> is exactly 1.</li>
<li><code>apples != 1</code> → if it’s not 1. Any other value except one will do.</li>
<li><code>apples &gt;= 1</code> → if it’s greater or equal to 1.</li>
<li><code>apples &lt; 1</code> → if it’s less than 1.</li>
<li><code>apples &lt;= 1</code> → if it’s less than or equal to 1.</li>
</ul>
<p>Notice how I told you the <code>if</code> has an else part, but I did not 
write it on the above program. That’s because it’s optional. 
If we only care about the part it’s true, the <code>else</code> is not needed.</p>
<p>However, we cannot do the reverse. You cannot have an <code>else</code> without an <code>if</code>. 
If we need to target when the condition is false, we need to reverse the 
condition, so it returns true when we need to.</p>
<p>Let’s see an example with an <code>else</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
   let apples = 1;
   if apples &gt; 1 {
       println!(&quot;You have many apples!&quot;);
   } else {
       println!(&quot;Please go to the supermarket.&quot;);
   }
 }
</code></pre></pre>
<p>Ok, enough of this. I guess it’s too simple, and we need to spice it up with…</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="for-loops-again"><a class="header" href="#for-loops-again">For loops again!</a></h1>
<p>Yay! Wait, I thought you were excited about this.</p>
<p>Let’s do something useful. This program will graph the function \(y = x^2\frac{1}{20} - 9\) in the terminal:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
   for y in -10..10 {
       for x in -30..30 {
           let value = x * x / 20 - 9;
           if value &gt;= y {
               print!(&quot; &quot;);
           } else {
               print!(&quot;#&quot;);
           }
       }
       println!();
   }
}
</code></pre></pre>
<p>As you can see, it only uses “for” and “if”. It might look complicated, 
but with a bit of work you should be able to follow it.</p>
<p>For the record, this is the output it produces:</p>
<pre><code class="language-console">$ cargo run
Finished dev [unoptimized + debuginfo] target(s) in 0.00s
    Running `target/debug/learnrust`
                                                            
                                               
                      #########              
                    #############            
                   ###############           
                  #################          
                 ###################         
                #####################        
               #######################       
              #########################      
             ###########################     
            #############################    
            #############################    
           ###############################   
          #################################  
          #################################  
         ################################### 
         ################################### 
        #####################################
        #####################################
</code></pre>
<p>You can change the formula in <code>let value = x * x / 20 - 9</code>, and it will graph 
whatever math function you like.</p>
<p>I know, there’s a lot to unpack here. I’ll go step by step. 
But first, for the avid readers, yes the function appears mirrored upside down. 
This is because the first line that is drawn first is in math the bottom one, 
and computers draw top to bottom while in math the Y axis goes from bottom to top.</p>
<p>It can be fixed, but to keep things simple I prefer to keep this bug in.</p>
<p>Let’s go first on the inner code of the loops:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let value = x * x / 20 - 9;
if value &gt;= y {
    print!(&quot; &quot;);
} else {
    print!(&quot;#&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>This computes \(x²\) by doing <code>x * x</code>, divides by 20 and then subtracts 9. 
Rust has a pow() function to do \(x²\) instead of <code>x * x</code>, but to keep 
it simple I avoided it. Anyway, this gets stored into the <code>value</code> 
variable and the <code>if</code> compares against <code>y</code>.</p>
<p>So, if it’s less than <code>y</code> prints a hash <code>#</code>, if not, it prints a space <code> </code> otherwise.</p>
<p>This is meant to fill the shape. Given the math function:</p>
<p>\[ y = \frac{x^2}{20} - 9 \]</p>
<p>It computes which <em>“squares”</em> are below the math function and uses the <code>#</code> character to fill the shape.</p>
<p>Notice how I used <code>print!</code> instead of <code>println!</code>. The lack of the <code>ln</code> 
(which stands for line) makes that print not open a new line, 
so it prints to the right like a typewriter.</p>
<p>So all that is left is to loop across all <code>x</code> and <code>y</code> squares:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   for y in -10..10 {
       for x in -30..30 {
           // ... 
       }
       println!();
   }
<span class="boring">}
</span></code></pre></pre>
<p>So using here a nested loop we iterate through negative 
and positive values for both x and y.</p>
<p>As <code>y</code> is usually the vertical axis, and the terminal prints first left-to-right
and then to-to-bottom, we need to first print an entire row; 
That’s why the <code>for y</code> appears first and the <code>for x</code> appears next.</p>
<p>After the <code>for x</code> is done, we need to move to the next line, so an 
empty <code>println!()</code> will move the cursor to the next line.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="other-types-of-loops"><a class="header" href="#other-types-of-loops">Other types of loops</a></h1>
<p>So far we have seen <code>for</code> loops. Rust has other ways of doing loops that 
sometimes are better than <code>for</code>.</p>
<h2 id="loop"><a class="header" href="#loop">Loop</a></h2>
<p>There is the infinite loop that is written by <code>loop</code>. But a program that has
an infinite loop never ends and might become stuck forever. Therefore,
when using these types of loops we need to make sure we break that loop at
some point.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut counter = 1;

loop {
    if counter &lt; 100 {
        counter *= 2;
    }
    if counter &lt; 130 {
        counter += 1;
    } else {
        // important to include a `break` to stop the loop at some point.
        break;
    }
    println!(&quot;counter = {}&quot;, counter);
}
println!(&quot;ended with counter = {}&quot;, counter);
<span class="boring">}
</span></code></pre></pre>
<h2 id="while"><a class="header" href="#while">While</a></h2>
<p>The other type of loop is <code>while</code> and does the same as <code>loop</code> but has a 
condition that must stay true to continue looping.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut counter = 1;

while counter &lt; 20 {
    counter += 1;
    println!(&quot;counter = {}&quot;, counter);
}

println!(&quot;ended with counter = {}&quot;, counter);
<span class="boring">}
</span></code></pre></pre>
<p>It also allows to retrieve a value in-place on the comparison, like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let test = &quot;Hello World!&quot;;
let mut chars = test.chars();

while let Some(c) = chars.next() {
    println!(&quot;c = {:?}&quot;, c);
}
<span class="boring">}
</span></code></pre></pre>
<p><code>text.chars()</code> returns an iterator over the characters of <code>test</code>. Every time we
call <code>chars.next()</code> it returns an <code>Option&lt;char&gt;</code> that can be either <code>Some(char)</code>
or <code>None</code>.</p>
<p>The <code>while</code> loop will keep iterating until this function returns <code>None</code>. The 
result of the <code>Some</code> is stored in <code>c</code>, and we can print each 
character individually.</p>
<p>But I should insist on using <code>for .. in</code> where possible, because it tends to be
more legible:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let test = &quot;Hello World!&quot;;

for c in test.chars() {
    println!(&quot;c = {:?}&quot;, c);
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercise-conditionals"><a class="header" href="#exercise-conditionals">Exercise: conditionals</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="turtle-improving-with-loops"><a class="header" href="#turtle-improving-with-loops">Turtle: Improving with loops</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="turtle-making-a-spiral"><a class="header" href="#turtle-making-a-spiral">Turtle: Making a spiral</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="level-apprentice-1"><a class="header" href="#level-apprentice-1">Level: Apprentice</a></h1>
<p>Now your spells are quite powerful already, and they loop around and do some
logic. This, as you have seen, creates full programs that start to make sense
and are beginning to be useful.</p>
<p>In this phase of learning you’re going to learn what is needed to finally
make useful programs. From here your programs would be good enough that you’ll
be able to make your own utilities for yourself.</p>
<p>The code might not be pretty, but you’ll have enough tools to do a lot of
interesting stuff.</p>
<p>You can consider this chapter to be learning your first fireball spell. 
Rough, but powerful and effective.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introducing-functions"><a class="header" href="#introducing-functions">Introducing Functions</a></h1>
<p>It might seem difficult to picture that sometimes the same 
piece of code needs to repeat in different places of the code, 
and it’s not a loop what I’m talking about.</p>
<p>The example programs I can add in this book have to be small, 
so we can go line by line. In reality, good useful programs have thousands of lines. 
It’s hard to make something really useful in twenty lines 
with only the basic operations we learned.</p>
<p>It might seem daunting to think about writing several thousand lines, but it is 
easier than it seems. We always start small, we keep adding pieces and after a 
few weeks it’s easy to have those thousand lines.</p>
<p>One of the applications I wrote, zzping, has nearly 7000 lines of code in it. 
And it has been only a hobby without much investment from my side. 
Programs get big very easily.</p>
<p>Having all those instructions inside the <code>fn main() {...}</code> is very hard to follow. 
It’s similar to organizing stuff in your room or in the house. 
If all items of your house were in a single big box, trying to find anything 
there is nearly impossible, so we all use different drawers, stands and boxes 
to sort the stuff, so we can locate it later.</p>
<p>In the same fashion, we split big programs into different files, so all related 
instructions that work towards a similar goal are near each other, and each file
has its own tools there.</p>
<p>We will see later on how to split into different files 
(in Rust, those are called modules), but now I want to explain how to sort 
stuff out inside a single file.</p>
<p>Imagine we’re doing some sort of program that tells the user 
interesting stuff, and it has a menu:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
   println!(&quot;Welcome to the Trivia program!&quot;);
   println!(&quot;------------------------------&quot;);
   println!(&quot;&quot;);
   println!(&quot;Please choose an option:&quot;);
   println!(&quot;&quot;);
   println!(&quot;    1. Tell a funny story&quot;);
   println!(&quot;    2. Show the multiplication table for a number&quot;);
   println!(&quot;    3. Show the dividing table for a number&quot;);
   println!(&quot;    4. Tell the future for a zodiac sign&quot;);
   println!(&quot;    5. Browse the cooking recipes&quot;);
   println!(&quot;    6. Exit the program&quot;);
   println!(&quot;&quot;);
   println!(&quot; Your option:&quot;);
 }
</code></pre></pre>
<p>As you can imagine, each of these options almost consists of its own program. 
Trying to code everything in here is going to be really confusing:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
   println!(&quot;Welcome to the Trivia program!&quot;);
   println!(&quot;------------------------------&quot;);
   println!(&quot;&quot;);
   println!(&quot;Please choose an option:&quot;);
   println!(&quot;&quot;);
   println!(&quot;    1. Tell a funny story&quot;);
   println!(&quot;    2. Show the multiplication table for a number&quot;);
   println!(&quot;    3. Show the division table for a number&quot;);
   println!(&quot;    4. Tell the future for a zodiac sign&quot;);
   println!(&quot;    5. Browse the cooking recipes&quot;);
   println!(&quot;    6. Exit the program&quot;);
   println!(&quot;&quot;);
   println!(&quot; Your option:&quot;);
   let option = 1; // TODO: Read the user input option and store it here.
   if option == 1 {
       println!(&quot;Here's a joke...&quot;)
       // TODO: Add jokes and a joke selector
   }
   if option == 2 {
       // TODO: Ask the user which number
       // ... compute and show the multiplication table
   }
   if option == 3 {
       // TODO: Ask the user which number
       // ... compute and show the division table
   }
   if option == 4 {
       // TODO: Add a database of zodiacs with their predictions
       // ... ask the user and show the matching one
   }
   if option == 5 {
       // TODO: Add a database of recipes
       // ... ask the user and show the matching one
   }
   if option == 6 {
       // TODO: Exit the program here
   }
   // TODO: Loop again to the beginning if option 6 wasn't chosen.
}
</code></pre></pre>
<p>It would be nice if we could break the program into subprograms that do specific
things, so we can call those when we need them, right?</p>
<p>That concept is exactly what a function is.</p>
<p>As usual, I’ll go back to short and stupid programs, but keep in mind the above
example where they’re useful.</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn welcome() {
   println!(&quot;Welcome adventurer!&quot;);
   println!(&quot;There are lots of treasures hidden in this place.&quot;);
   println!(&quot;Oh, and there's also a princess trapped in a castle.&quot;);  
   println!(&quot;&quot;);
   println!(&quot;You know what to do.&quot;);
}

fn main() {
   welcome();
   println!(&quot;End of program&quot;);
}
</code></pre></pre>
<p>Here we can see a “welcome” function that prints six lines of text. 
What the computer does is:</p>
<ul>
<li>It always starts from the main function.</li>
<li>Reads the <code>welcome()</code> call to the function, so it jumps to the top <code>fn welcome()</code></li>
<li>Executes the five <code>println!</code></li>
<li>The function ends on the <code>}</code>, so it goes back where it was on main.</li>
<li>Reads the next line and prints “End of program”.</li>
<li>Reaches the end of main (the <code>}</code>) and the program ends here.</li>
</ul>
<p>A function has two sides, the declaration and the call. The function declaration states what is the function name and what it does:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn your_function_name() { 
  // ... your code here for what this function does ... 
}
<span class="boring">}
</span></code></pre></pre>
<p>And then you can call it as many times you want, using:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>your_function_name();
<span class="boring">}
</span></code></pre></pre>
<p>And the key thing here is “call it as many times you want”. The function’s 
purpose <strong>is to be reused several times</strong>, so you don’t have to repeat your 
code several times.</p>
<p>The declaration part doesn’t need to be above or below the main(), it can be 
anywhere as long as it is not inside the main. </p>
<p>Placing it before or after the main is fine, the order doesn’t matter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="returning-values-from-functions"><a class="header" href="#returning-values-from-functions">Returning values from functions</a></h1>
<p>It is also possible to use a function to calculate a certain value. 
For example, we can calculate the number PI (\(\pi\)):</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn calculate_pi() -&gt; f64 {
   // https://en.wikipedia.org/wiki/Leibniz_formula_for_%CF%80
   // pi/4 = 1 - 1/3 + 1/5 - 1/7 + 1/9 - ...
   let mut pi_4 = 1.0;
   let mut divisor = 3.0;
   let steps = 20_000_000;
   for _ in 0..steps {
       pi_4 -= 1.0 / divisor;
       divisor += 2.0;
       pi_4 += 1.0 / divisor;
       divisor += 2.0;
   }
   return pi_4 * 4.0;
}
fn main() {
   let pi = calculate_pi();
   println!(&quot;pi: {}&quot;, pi);
}
</code></pre></pre>
<blockquote>
<p>Note that it’s quite hard to understand how these formulas actually compute PI.
You’re not alone, and this is not the purpose of this exercise. We’re only
focusing on a function <strong>that returns PI</strong>, and we don’t care on how it’s done.</p>
</blockquote>
<p>Again, this program might be a bit too much, 
but the important thing is in the first line:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> fn calculate_pi() -&gt; f64 {
<span class="boring">}
</span></code></pre></pre>
<p>The arrow symbol <code>-&gt;</code> indicates that this function returns a value. 
<code>f64</code> is which kind of value we want to return, which for this case is a 
floating point number (a number with decimal places). 
If we wanted to return an integer we would have used <code>i64</code>.</p>
<p>The last line of the function specifies the actual value to be returned:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   return pi_4 * 4.0;
<span class="boring">}
</span></code></pre></pre>
<p>Since this fraction series calculates \(\pi\) divided by four, we need to 
multiply it by four to get PI, and the return keyword is what signals Rust that 
it should exit the function at that point (it marks the end of it) and return
the value on the right.</p>
<p>It is worth noting that while the <code>return</code> keyword is in most other programming 
languages as well, Rust specifically has another way of writing this:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   pi_4 * 4.0
<span class="boring">}
</span></code></pre></pre>
<p>Just removing the return keyword and also removing the semicolon signals Rust 
that this is the output of that block. It behaves similar but not identical to 
return. For simplicity’s sake we’ll keep using return for now which could be 
simpler to read and understand. However, this form is actually preferred in 
Rust code. We will learn it in depth later on.</p>
<p>The next thing we should focus on is how this function is called:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let pi = calculate_pi();
<span class="boring">}
</span></code></pre></pre>
<p>Notice how it is used like it was a value. Rust will call the function, get the 
resulting number and replace here the function by the output value. 
Then it will be stored in the variable <code>pi</code>.</p>
<p>Everything else in this program is something that we already saw before. 
Let me go over a few things that might seem new:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let mut pi_4 = 1.0;
  let mut divisor = 3.0;
  let steps = 20_000_000;
  for _ in 0..steps {
<span class="boring">}
</span></code></pre></pre>
<p>We are using <code>let mut</code> here to be able to change the values of <code>pi_4</code> and 
<code>divisor</code> inside the function. Without that, Rust will not let us change 
the variable contents.</p>
<p>Another thing that might seem strange is the number <code>20_000_000</code>. 
This is just 20 million, but the underscores are placed to make it easier to read. 
They have no meaning to Rust.</p>
<p>In the for loop, you’ll notice that it says <code>0..steps</code>; so this basically makes 
the for count up to <code>steps</code>. There’s nothing special with this.</p>
<p>Finally, the for has as a variable underscore <code>_</code>. 
This is because this variable is not used. We only need N steps, but we use 
<code>divisor</code> to keep track of the position. Rust will emit warnings for unused 
variables. To avoid this, we use an underscore to signal Rust we don’t need 
this value.</p>
<p>The result of the program is:</p>
<pre><code class="language-console">pi: 3.1415926785904635
</code></pre>
<p>It’s quite close to the real thing. Of course, if you increment the number of 
steps it will get closer, but the program will take a bit to run. 
For those cases we can make our Rust program faster by adding 
the <code>--release</code> flag to cargo run:</p>
<pre><code> $ cargo run --release
   Compiling learnrust v0.1.0 (/home/deavid/git/rust/learnrust)
    Finished release [optimized] target(s) in 1.00s
     Running `target/release/learnrust`
  pi: 3.1415926785904635
</code></pre>
<blockquote>
<p>Programs are usually built in “debug” mode, which compiles faster, but the 
program runs slower. This is the preferred mode for working with our program.
But when distributing our application, the “release” mode is best, as it will
make the program perform at its best.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-arguments"><a class="header" href="#function-arguments">Function arguments</a></h1>
<p>But what if we wanted a configurable number of steps? We can do that!</p>
<p>Functions can accept data when they’re called, like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pi = calculate_pi(100);
<span class="boring">}
</span></code></pre></pre>
<p>But for this to work we need to change the function signature:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn calculate_pi(steps: i64) -&gt; f64 {
<span class="boring">}
</span></code></pre></pre>
<p>We have to specify between the parenthesis what is the variable name that will
record the input value, as well as the type. 
Since steps won’t have any decimal places, we use “i64” instead of “f64”.</p>
<p>Therefore, a more complete description on the syntax for a function is:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn function_name( input_var_name: type ) -&gt; return_type { 
    // Function code here... 
}
<span class="boring">}
</span></code></pre></pre>
<p>Where the arguments can be omitted, and the return type can be omitted as well
if we don’t use them.</p>
<p>It is possible as well to have many input values, just separating them by comma:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn function_name( input1: type1, input2: type2, input2: type2 ) { 
    // Function code here... 
}
<span class="boring">}
</span></code></pre></pre>
<p>Each input variable needs to have its own type associated. 
We’ll see more examples on this later on.</p>
<p>For now, let’s see the full program changed:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn calculate_pi(steps: i64) -&gt; f64 {
   // https://en.wikipedia.org/wiki/Leibniz_formula_for_%CF%80
   // pi/4 = 1 - 1/3 + 1/5 - 1/7 + 1/9 - ...
   let mut pi_4: f64 = 1.0;
   let mut divisor = 3.0;
   for _ in 0..steps {
       pi_4 -= 1.0 / divisor;
       divisor += 2.0;
       pi_4 += 1.0 / divisor;
       divisor += 2.0;
   }
   return pi_4 * 4.0;
 }
 fn main() {
   for n in 1..10 {
       let steps = i64::pow(10, n);
       let pi = calculate_pi(steps);
       println!(&quot;pi: {} ({} steps)&quot;, pi, steps);
   }
 }
</code></pre></pre>
<p>This program now has a loop in main() that will do 10 different 
calculations of PI at different precision levels.</p>
<p>Here’s the output:</p>
<pre><code> $ cargo run --release
   Compiling learnrust v0.1.0 (/home/deavid/git/rust/learnrust)
    Finished release [optimized] target(s) in 1.00s
     Running `target/release/learnrust`
 pi: 3.189184782277596  (10 steps)
 pi: 3.1465677471829556 (100 steps)
 pi: 3.1420924036835256 (1000 steps)
 pi: 3.1416426510898874 (10000 steps)
 pi: 3.141597653564762  (100000 steps)
 pi: 3.1415931535894743 (1000000 steps)
 pi: 3.1415927035898146 (10000000 steps)
 pi: 3.1415926585894076 (100000000 steps)
 pi: 3.1415926540880768 (1000000000 steps)
</code></pre>
<p>It’s important to run this with <code>--release</code> or it will take a bit too long to compute.</p>
<p>Also, it’s always mesmerizing to see how more and more digits 
are getting <em>“stuck in”</em> as the number of steps grows.</p>
<p>I think this variation should be self-explanatory with maybe 
the exception to this line:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>       let steps = i64::pow(10, n);
<span class="boring">}
</span></code></pre></pre>
<p>This computes \(steps = 10^n\), that is, the power of 10 raised to the “n”. 
For this we use the function pow that exists inside the <code>i64</code> type. 
The double colon operator <code>a::b</code> is used to access the functions inside other 
libraries (or any content in fact).</p>
<p>Note that this function pow accepts two numbers as input and returns a number.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-types"><a class="header" href="#data-types">Data types</a></h1>
<p>We have reached a point where I cannot continue to explain much more without 
giving you a fair bit of theory. Sorry about this, but it’s needed.</p>
<h2 id="what-are-data-types"><a class="header" href="#what-are-data-types">What are data types?</a></h2>
<p>First: what is data? Data is just the technical term for value. 
The number 5 is a value and is data, and so is 2.41 or the string “Basement”.</p>
<p>The concept of “data types” just refers to the different kinds of values. 
You see, 3+5 is 8, but “Base”+“ment” is “Basement”. 
The sign plus (+) might work differently depending on if it is text or a number.</p>
<p>Some operators like dividing (/) make sense on numbers (8/2=4) but 
don’t make any sense on texts (“Base”/“ment” = ????).</p>
<p>So the primordial thing that puts data types apart is what can be done with the 
values, what makes sense and what doesn’t; 
and also what the operations actually mean.</p>
<p>Because, you know, computers might look like really smart, but they’re actually
pretty stupid. If you do, “3”+“5” is just “35” and not “8” 
(because of the quotes, it is treated like text, so it gets concatenated when 
using the plus sign). They take everything literally, too literally. 
And we need to tell them what to do, step by step to a level that feels like 
training a monkey how to make a chocolate brownie.</p>
<p>There are tons of data types, you can construct your own, and you can also use
other people’s types. But in general, to start, we have three basic types:</p>
<ul>
<li>Numbers
<ul>
<li>Integers (which can be positive or negative, but don’t have a decimal point)</li>
<li>Floating point numbers (or floats) that actually have decimal places.</li>
</ul>
</li>
<li>Texts, generally called “strings” in programming 
(at some point later I might explain where the name “string” comes from, it’s a bit funny)</li>
<li>True/False types, called “boolean”, used to store the result of comparisons such as “apples &gt; 1”.</li>
</ul>
<p>You might be inclined to always use floating point numbers for everything, as 
they can do much more than regular integers. If they’re better, there’s no point
in using the puny integers, right?</p>
<p>Well, no. Later on I will point out the different problems that floating points
have. For now, just write 2.0 instead of 2 for every number, and you’re done.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-data-types"><a class="header" href="#rust-data-types">Rust data types</a></h1>
<p>Rust data types are however a bit more nuanced. 
You see, these values we want to store have to be actually recorded somewhere 
in your physical computer. And that will be your computer memory 
(RAM, or DDR if you prefer). 
The number 4 might not look like much, but Rust has to ask for memory from your 
computer in order to save the value somewhere, else it would be lost, 
forgotten and programs won’t run.</p>
<p>So the question that Rust faces is: how much memory is needed for this variable? 
A variable can change its value later on, for example that x=4, later on it can 
be x=99999999. It needs to grab enough memory in order to ensure that all values
you might want to put there actually do fit.</p>
<p>This is why integers are split into different sizes:</p>
<ul>
<li>i8</li>
<li>i16</li>
<li>i32</li>
<li>i64</li>
</ul>
<p>Each of those is a valid Rust type for an integer. 
And yeah, the “i” is short for integer. 
The number that it follows is the number of bits that Rust will get for them.</p>
<p>Is 8 bits a lot? Let’s see. A computer might have 4 gigabytes of RAM. 
Giga just means billion. So that’s 4,000,000,000 bytes. And a byte is just 8 bits.</p>
<p>So this means that i8 only uses 1 byte of memory. 
And if a computer has 4,000,000,000 bytes, I can surely assume it can store
a lot of those and still have plenty of space left. So yeah, it’s very tiny.</p>
<p>But this affects the range of numbers we can store. It is fine for storing 
-4, 12 or 81. But 355 is too much for an i8 and the program will fail. 
If we need to store bigger numbers, we need to use types that use more space.</p>
<p>For example, i16 can store up to 32,000.</p>
<p>But you know what? This is too complicated. Why bother? Use i64 and that’s it. 
Forget about the others for now and just use i64 for everything. 
Your computer has so much memory that it doesn’t care if a number uses 1 byte or 8.</p>
<p>An i64 can store any integer number up to roughly 9,000,000,000,000,000,000. 
Either positive or negative. Unless you want to start counting atoms, I think we 
have more than enough to work with. So again, let’s use i64 for all our integer 
numbers and forget about this conversation.</p>
<p>Rust also has unsigned numbers, which work exactly the same as the regular 
integers, but they can’t store negative numbers, Instead of “i” they go with “u” 
and work exactly the same:</p>
<ul>
<li>u8</li>
<li>u16</li>
<li>u32</li>
<li>u64</li>
</ul>
<p>Why limit ourselves to only positive? Well, they can hold double
the numbers inside. But… why? Wasn’t 9,00… or whatever enough for us…?</p>
<p>Exactly. It is enough. So again, we won’t be using these. Use i64.</p>
<p>There are two extra integer types in Rust:</p>
<ul>
<li>usize</li>
<li>isize</li>
</ul>
<p>If your computer is a 64bit one, then these are equivalent to u64 and i64. 
But these have their specific use. We will come back later to the “usize” as it 
is how computers locate things in memory. Certain things such as locating an 
item in a list/collection of numbers use “usize”.</p>
<p>I’m dumping this to you now to give an approximate picture of the data types 
that Rust has in the hopes that you’ll begin to recognize these later on. 
I’ll explain this again later on with more detail, so no need to study and 
memorize these things now.</p>
<p>Floating points, very similarly have two variants for sizes:</p>
<ul>
<li>f32</li>
<li>f64</li>
</ul>
<p>“f” for float, and 32 or 64 for the amount of memory that they use. 
And guess what, we’ll use f64 when we need decimal places and forget about f32.</p>
<p>Boolean values (bool) only have one type:</p>
<ul>
<li>bool</li>
</ul>
<p>There isn’t much secret on this type, it is quite like an integer 
that holds 0 for false and 1 for true. That is all.</p>
<p>Strings (texts) also come in two variants, but, surprise! It’s not for size!</p>
<ul>
<li>str</li>
<li>String</li>
</ul>
<p>The difference is a bit too nuanced to explain right now, so let’s just say 
they’re almost the same thing. We will use String for our variables, as it is 
simpler to use, but in some cases, Rust wants a “str” instead. They can be 
converted one to another, so it’s not a big deal.</p>
<p>As you might have noticed, they don’t have any specific size. 
So, how big can the text be inside?</p>
<p>Short answer: As long as you want.</p>
<p>They’re dynamic. Rust will request more memory when needed. 
So as long as your computer has enough memory to store the text, it will work<sup class="footnote-reference"><a href="#1">1</a></sup>. </p>
<p>And those are all types we will be using for a long, long time here. So, to recap:</p>
<ul>
<li>Integer numbers (without decimal places): i64</li>
<li>Floating point numbers (with decimal places): f64</li>
<li>Strings (text): String (with the first S in uppercase)</li>
<li>Boolean (true/false): bool</li>
<li>Locating values inside a list: usize (we’ll see this later on)</li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Oh crap, I’m sorry, I’m lying way too much… I swear I will fix this mess later on. For now, bear with me, this is the explanation you need</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="back-to-declaring-variables-with-type"><a class="header" href="#back-to-declaring-variables-with-type">Back to declaring variables… with type</a></h1>
<p>Now that we have a rough idea on types, we can do more things with the “let” keyword.</p>
<p>For example, we can tell Rust to use an i64 for our number:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   let x: i64 = 2;
<span class="boring">}
</span></code></pre></pre>
<p>That will force the selection of this type. But wait… 
if we didn’t specify a type, and Rust needs one to know how much memory to use… 
how did Rust make the previous examples work?</p>
<p>As a reminder, we did:</p>
<pre><pre class="playground"><code class="language-rust edition2021">   fn main() {
      let x;
      x = 4;
      println!(&quot;{}&quot;, x);
   }
</code></pre></pre>
<p>And we did not specify a type here. 
In fact, this could be i8, i16, i32, i64 or even u8, u16, etc. 
All these will work.</p>
<p>Which one did select Rust and why?</p>
<p>Did we care which one to use when writing this? No. And neither does Rust.</p>
<p>Rust will do something similar to what I’m telling you to do. <code>i64</code> is a 
perfectly fine type for most uses, so just go with that. Rust is probably doing 
the same thing here: It seems you want a number; does i64 work?
Ok, so that one then; that looks good<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<p>Rust does a lot of guesswork to select the type, and most of the time we don’t 
need to care about this. In a few particular times it might be confused with too 
many options that are too different, and might complain. In such cases, we need
to help it by defining the type. Aside from that we’ll avoid setting the types
and let Rust do its magic.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Note here that Rust might guess differently and prefer an i32 over an i64 
“because it’s smaller, and it still works”. As we didn’t care about which type, 
it’s pointless to try to know what Rust exactly does. 
If we want to be sure it’s an i64, we just write it down.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dbg-and-format"><a class="header" href="#dbg-and-format">dbg!() and format!()</a></h1>
<p>Printing in console is nice. But sometimes we want just to quickly see what
are the contents of a variable or operation.</p>
<p>For this we can use the <code>dbg!()</code> macro<sup class="footnote-reference"><a href="#1">1</a></sup>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let value = 123.0;
dbg!(value);

dbg!(1.5 * 3.2);
<span class="boring">}
</span></code></pre></pre>
<p>This prints:</p>
<pre><code>[src/main.rs:4] value = 123.0
[src/main.rs:6] 1.5 * 3.2 = 4.800000000000001
</code></pre>
<p>This is quite useful! Avoids writing a lot and does what we need to understand
what the code is doing at different points.</p>
<blockquote>
<p>You’ll notice that the result of the multiplication is not \(4.8\). This is
fine. Floating points have problems with precision and it shows. Soon enough
I’ll explain. Don’t worry too much.</p>
</blockquote>
<h2 id="format"><a class="header" href="#format">format!()</a></h2>
<p>Here’s another case. Sometimes we want the ability that <code>println!()</code> gives us
regarding on composing a string, but we don’t want to print it. We want to 
store it.</p>
<p>For this, we have the <code>format!()</code> macro, that works exactly as <code>println!()</code> but
instead of printing it returns the result as a string:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>let text = format!(&quot;your lucky number is {:05}. Try another day!&quot;, 7);

dbg!(text);
<span class="boring">}
</span></code></pre></pre>
<pre><code>[src/main.rs:5] text = &quot;your lucky number is 00007. Try another day!&quot;
</code></pre>
<p>Nice!</p>
<p>This can be used to compose texts and pass it to other functions.</p>
<p>You can see more examples here:</p>
<p><a href="https://doc.rust-lang.org/rust-by-example/hello/print.html">https://doc.rust-lang.org/rust-by-example/hello/print.html</a></p>
<hr />
<p><sup class="footnote-reference"><a href="#1">1</a></sup> Looks like a function, you can think of it as a function, but to be correct,
things that end with <code>!</code> are called Macros. We won’t see how to make these until
very late in (if at all), as you don’t need to make macros to code 99.999% of 
programs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="converting-types-with-explicit-conversions"><a class="header" href="#converting-types-with-explicit-conversions">Converting types with explicit conversions</a></h1>
<p>As you can imagine, it is pretty common having a mix of types. With so many data 
types it is easy to end up having an operation that needs to mix them in some
way, and Rust does not allow that.</p>
<p>We will avoid the majority of those problems by using as few types as 
possible, just i64 and f64. But it will happen at some point.</p>
<p>For example, consider a simplistic example:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   let apples: i64 = 2;
   let apple_weight: f64 = 0.35;
   let total_weight: f64 = apples * apple_weight;
<span class="boring">}
</span></code></pre></pre>
<p>In this case we could define <code>apples</code> to be a float, and it will work,
but this could appear differently where this is not so simple, 
and we need “apples” to be an integer regardless.</p>
<p>To make this work we can simply convert “apples” variable in the spot, 
right where we need it:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   let apples: i64 = 2;
   let apple_weight: f64 = 0.35;
   let total_weight: f64 = apples as f64 * apple_weight;
<span class="boring">}
</span></code></pre></pre>
<p>By adding <code>as f64</code> we’re making what is called an <em>“explicit conversion”</em>. 
Rust will convert the integer into a floating point on the spot 
and will use that on the calculation of total_weight.</p>
<p>The variable <code>apples</code> is still an integer after that line. If we keep using 
it as a float we would need to keep converting every time. 
So if it is needed in all places as a float, 
maybe it is better to just make it a float from the start.</p>
<p>Explicit conversions have their limitations though. 
It works only between some types that are easy for Rust to convert. 
You can’t use it to convert to or from strings 
(there are other conversion types for that), or between string types.</p>
<p>Doing the reverse, converting a float into an integer, 
will drop any decimal places. So <code>2.99999 as i64</code> is just <code>2</code>. 
It <strong>will not round the number</strong> to 3. 
There are other ways for rounding numbers.</p>
<p>The reason why explicit conversion works for so few cases and its behavior:
These conversions are usually supported by your CPU and are really fast. 
Rounding numbers or converting an integer into a string will take several 
iterations in your CPU to complete. Those are also very fast, 
just not as fast as the explicit conversion. Rust is trying to signal you where 
your program might be consuming more resources, which is helpful, 
but we don’t need to be obsessed with speed. 
Rust is very fast, and so is your computer (even if old).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercise-explicit-conversions"><a class="header" href="#exercise-explicit-conversions">Exercise: explicit conversions</a></h1>
<p>Now, use what you learn about doing <code>x as f64</code> to fix the following program:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 4
let y = 2.0;
let z = x / y;
dbg!(z);
<span class="boring">}
</span></code></pre></pre>
<p>We could solve in two directions:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 4
let y = 2.0;
let z = x as f64 / y;
dbg!(z);
<span class="boring">}
</span></code></pre></pre>
<p>Or:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 4
let y = 2.0;
let z = x / y as i64;
dbg!(z);
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-tiny-bit-on-strings"><a class="header" href="#a-tiny-bit-on-strings">A tiny bit on strings</a></h1>
<p>Storing and manipulating texts in a program is a bit harder to explain than numbers. 
This is because a computer does not work with text, but with numbers.</p>
<p>Surely you have heard that in a computer everything
are ones and zeros (the binary system). 
These can be combined to create big numbers, and with some tricks the CPU can 
also work natively with floating point in order to have decimal places.</p>
<p>But text is not a number, which means that Rust needs a bit of work behind the 
scenes to make these work.</p>
<p>As a basic introduction, a text is nothing more than a sequence of letters. 
The text <code>ABC</code> might be a string, but it also is a sequence of
three letters: <code>A</code>, <code>B</code> and <code>C</code>.</p>
<p>Each letter is a character. If we assign each possible character a number, we can in fact store text using numbers:</p>
<ul>
<li><code>A</code> → 65</li>
<li><code>B</code> → 66</li>
<li><code>C</code> → 67</li>
<li>…</li>
</ul>
<p>This is totally arbitrary, but there’s a standard called <em>“ASCII”</em> that defines
a table of conversions from letters to numbers. If all programs use the same 
table<sup class="footnote-reference"><a href="#1">1</a></sup>, then we can save those numbers into a file, and get the correct texts
back when another program reads the same file. </p>
<p>So a string is just a list of numbers that it is conveniently interpreted as text.</p>
<p>Instead of the ASCII table Rust by default uses UTF8 for strings. I won’t go 
into much detail here, but the world has different languages with 
different characters. Think about Chinese, Japanese, and Russian. The ASCII 
table is not good for those. UTF8 is still compatible with ASCII, 
but it allows for a character to span multiple number entries (bytes), so we 
can have in the same format any kind of writing language.</p>
<p>To keep things simple, just assume it is ASCII for now. We’ll cover UTF later on.</p>
<p>Why are texts called “strings”?
https://stackoverflow.com/questions/880195/the-history-behind-the-definition-of-a-string
(To be completed later)</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Actually they don’t, and that’s why we have so many problems with tildes,
foreign characters, and the reason why UTF exists.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simple-explanation-on-str-vs-string"><a class="header" href="#simple-explanation-on-str-vs-string">Simple explanation on &amp;str vs String</a></h1>
<p>We will use these soon, so they need a bit of an introduction. 
They both store a sequence of characters.</p>
<p>It all boils down to what I commented early on. Rust (and the computer itself) 
needs to know how big a variable is. 
But a string can change in size very abruptly.</p>
<p>Because of this, Rust cannot know the size of most strings until the program is 
actually executed. This poses a problem, because without a rigid size in memory
we cannot have variables that contain text. At most, we can have a variable 
that stores a single character, but this isn’t very useful.</p>
<p>So what do we do? Well, instead of having the text itself in a variable 
we store where the string is and its length. This is the type <code>&amp;str</code>.</p>
<p>While this is the fastest way for the computer to do this, and convenient for 
some parts of the program, it’s certainly very hard to manipulate. It’s nearly 
impossible to change the contents of a <code>&amp;str</code> variable.</p>
<p>It’s because of that inconvenience that String exists. The String type 
encapsulates and automates string changes.</p>
<p>So, in general, when a text never changes, <code>&amp;str</code> is just fine. But if we want 
to store the user’s input, String might be better.</p>
<p>In Rust these two are very easy to convert from one to another:</p>
<pre><pre class="playground"><code class="language-rust edition2021"> fn main() {
   let s1 = &quot;This is a &amp;str&quot;;
   let s1a = s1.to_owned(); // This converts &amp;str to String.
   let s2 = String::from(&quot;This is a String&quot;);
   let s2a = s2.as_str(); // This converts String to &amp;str.
 }
</code></pre></pre>
<p>We’ll go on more details later on, but for now we will basically use whatever 
type Rust is happier with. Depending on what we’re doing we will probably need 
one or the other and convert accordingly.</p>
<p>Note that there are lots of functions to create a <code>String</code> from a <code>&amp;str</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = &quot;text&quot;.to_owned();
let s2 = &quot;text&quot;.to_string();
let s3 = String::from(&quot;text&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>They all do the same. In programming, we try to avoid having two things for
the same, but in this case, Rust has to have three variants, because they can
be used in different contexts.</p>
<ul>
<li><code>x.to_owned()</code> means to create an owned version of the variable; that is, to
remove the <code>&amp;</code> character (borrow), which we will be learning soon.</li>
<li><code>x.to_string()</code> means to convert something into a string. This is equivalent
to <code>format!(&quot;{}&quot;, x)</code>.</li>
<li><code>String::from(x)</code> means to create a string from something else. It can only be
used with &amp;str, String or other types that actually represent text or at least
a character.</li>
</ul>
<p>Is any of those faster? Maybe. Probably String::from(). But I bet it cannot be
measured in 99.9% of real Rust programs. The difference is too small to actually
matter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-bit-more-detailed-explanation-on-functions"><a class="header" href="#a-bit-more-detailed-explanation-on-functions">A bit more detailed explanation on functions</a></h1>
<p>A function has always two parts, the declaration, and the call.</p>
<p>The declaration is this part with the <code>fn</code> keyword:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn one() -&gt; i64 {
    return 1;
}
<span class="boring">}
</span></code></pre></pre>
<p>Where the call is this code:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>add_one();
<span class="boring">}
</span></code></pre></pre>
<p>You can have functions declared that are not called (you’ll get a warning), but
you cannot have a function called that is not declared.</p>
<p>Also, we can call the same function as many times we want. It is the whole point
of functions to be able to be called thousands of times.</p>
<p>To execute/call a function, we write the name and follow it by parenthesis:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>add_one();
<span class="boring">}
</span></code></pre></pre>
<p>If we forget the parenthesis, the function will not be called:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>add_one;  // WRONG!
<span class="boring">}
</span></code></pre></pre>
<p>The return value of a function can be used as a regular value:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let two = 1 + one();
let three = 1 + one() + 1;
<span class="boring">}
</span></code></pre></pre>
<p>Rust will execute the code in the function, get the return value and “replace”
the function call with that value:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let two = 1 + (1);
let three = 1 + (1) + 1;
<span class="boring">}
</span></code></pre></pre>
<p>Function names are actually variables. We won’t be using this “feature” in this
book, but it’s good that you know this is possible:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let one_fn = one;

let two = one_fn() + 1;
<span class="boring">}
</span></code></pre></pre>
<p>These are called function pointers. This is why it’s important you don’t forget
the parenthesis, as the error might get you confused. Rust will understand that
you want to store the function code somewhere<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Actually they are function pointers, they point to the memory address 
where the code sits. But as usual, this goes outside what I want to explain.</p>
</div>
<h2 id="theyre-black-boxes"><a class="header" href="#theyre-black-boxes">They’re black boxes</a></h2>
<p>We need to understand functions as a black box. Something goes in, something
goes out. We don’t care that much on what happens inside when we call it.</p>
<p>You can imagine them as a microchip, that has pins for getting data in, and
pins that give data out:</p>
<pre><code>              ┌——————————————————┐
 number_1  --&gt;│                  │
              │                  │
              │  add_numbers()   │---&gt; result_number
              │                  │
 number_2  --&gt;│                  │
              └——————————————————┘
              
</code></pre>
<p>This equates to this function:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_numbers(number_1:i64, number_2:i64) -&gt; i64 {
//     │          │             │              ↳ Return value type
//     │          │             ↳ Second argument name and type
//     │          ↳ First argument name and type
//     ↳ Function name
<span class="boring">}
</span></code></pre></pre>
<p>Remember: You can have functions that don’t return a value. A function that
accepts one, two, or many arguments. Or both.</p>
<p>This function doesn’t need any arguments, and doesn’t return anything:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn help() {
<span class="boring">}
</span></code></pre></pre>
<p>This one accepts one argument but doesn’t return anything:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn manual(page: i64) {
<span class="boring">}
</span></code></pre></pre>
<p>This one doesn’t have arguments, yet has a return value:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn calculate_pi() -&gt; f64 {
<span class="boring">}
</span></code></pre></pre>
<h2 id="omitting-return"><a class="header" href="#omitting-return">Omitting “return”</a></h2>
<p>In Rust, most of the time we don’t need to add <code>return</code> to return a value.
If the last statement of the function lacks a semicolon, implies return.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_numbers(a: i64, b: i64) -&gt; i64 {
    let c = a + b;
    return c;
}
<span class="boring">}
</span></code></pre></pre>
<p>Can be simplified as:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_numbers(a: i64, b: i64) -&gt; i64 {
    let c = a + b;
    c
}
<span class="boring">}
</span></code></pre></pre>
<p>Which in turn, can be simplified again:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_numbers(a: i64, b: i64) -&gt; i64 {
    a + b
}
<span class="boring">}
</span></code></pre></pre>
<p>Nice!</p>
<h2 id="types-as-matching-shapes"><a class="header" href="#types-as-matching-shapes">Types as matching shapes</a></h2>
<p>Remember those kids toys where you have to put the rectangle on the rectangular
hole, and the circle in the circular hole?</p>
<p>Data types are somewhat like this.</p>
<p>Imagine that the types were shapes:</p>
<ul>
<li>Integers are squares: ■</li>
<li>floating points are circles: ◉</li>
<li>Strings are parallelograms: ▰</li>
</ul>
<p>Now, when you make a function, the arguments are like “sockets” you must connect:</p>
<pre><code>              ┌——————————————————┐
 number_1 ○--&gt;│                  │
              │                  │
              │  add_numbers()   │◉---&gt; result_number
              │                  │
 number_2 ○--&gt;│                  │
              └——————————————————┘             
</code></pre>
<p>A function that accepts several types would look like this:</p>
<pre><code>   ┌————————┐
--▢|        |
   |        |
--◎|        |
   |        |
--▱|        |
   └————————┘             
</code></pre>
<p>You need to provide the right shapes to that box to get it working.</p>
<p>Or in specific terms, you need to provide the exact types the function is 
asking for to be able to call it.</p>
<p>You cannot call a function that accepts a <code>f64</code> with an <code>i64</code>.</p>
<p>In the same sense, if your code is expecting an <code>i64</code> as a result, the function
must return that:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn calc_pi() -&gt; f64 {
    // code here...
    return pi;
}

fn main() {
    let pi:i64 = calc_pi(); // Error! calc_pi returns f64 but the variable is i64.
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-closures"><a class="header" href="#introduction-to-closures">Introduction to Closures</a></h1>
<p>In Rust, it is possible to create a function without using the <code>fn</code> keyword.</p>
<p>Why would we want to have a secondary way of creating these?</p>
<p>Well, sometimes we need a function for something that appears just once.</p>
<p>Sometimes these functions are very small.</p>
<p>But still, this doesn’t explain why we need a secondary way of creating functions.</p>
<p>The real reason though, is that some functions require functions to be passed 
as arguments.</p>
<blockquote>
<p><em>Wait what? You mean to call a function in a function argument?</em></p>
</blockquote>
<p>Yeah. Nope. That’s not it. I mean the function itself, the name, before being called.</p>
<p>Imagine we want a function that counts stuff. But what it counts, is up to the
caller to decide.</p>
<p>For example, given the text:</p>
<pre><code>The fox jumped over the lazy dog.
</code></pre>
<p>We want to count the letter <code>e</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn count_e(text: &amp;str) -&gt; i64 {
    let mut count = 0;
    for c in text {
        if c == 'e' {
            count += 1;
        }
    }
    count
}
<span class="boring">}
</span></code></pre></pre>
<p>Okay, good. But if we want to be able to count any character that we want?</p>
<p>Simple, add another argument!</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn count(text: &amp;str, what: char) -&gt; i64 {
    let mut count = 0;
    for c in text {
        if c == what {
            count += 1;
        }
    }
    count
}
<span class="boring">}
</span></code></pre></pre>
<p>Yeah, we don’t see the problem yet. </p>
<p>But now, imagine we want also to be able to count uppercase values.</p>
<p>What value do we give to this function, so it can compare against many values?</p>
<p>We can pass a function itself!</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn count(text: &amp;str, what: fn(char) -&gt; bool) -&gt; i64 {
    let mut count = 0;
    for c in text.chars() {
        if what(c) {
            count += 1;
        }
    }
    count
}

fn uppercase(c: char) -&gt; bool {
    if c &gt;= 'A' &amp;&amp; c &lt;= 'Z' {
        return true;
    }
    return false;
}

fn vowel(c: char) -&gt; bool {
    match c {
        'a' | 'e' | 'i' | 'o' | 'u' =&gt; true,
        _ =&gt; false,
    }
}

fn main() {
    let text = &quot;The fox Jumped over the Lazy Dog.&quot;;

    let c = count(text, uppercase);
    println!(&quot;uppercase = {}&quot;, c);
    let c = count(text, vowel);
    println!(&quot;vowels = {}&quot;, c);
}
</code></pre></pre>
<p>This prints:</p>
<pre><code>uppercase = 4
vowels = 9
</code></pre>
<p>Because we can have such functions (and the Rust library contains a few of those)
we might need to create functions just to be able to call these.</p>
<p>And it can get cumbersome.</p>
<p>For example, Rust has a function <code>char::is_alphabetic</code> that returns <code>true</code>
if the character is a letter.</p>
<p>However, we might want to reverse it:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn is_not_alphabetic(c: char) -&gt; bool {
    !c.is_alphabetic()
}

fn main() {
    let is_not_alphabetic2 = |c: char| !c.is_alphabetic();
    
    dbg!(is_not_alphabetic('0'));
    // prints --&gt; is_not_alphabetic('0') = true
    dbg!(is_not_alphabetic2('0'));
    // prints --&gt; is_not_alphabetic2('0') = true

    dbg!(is_not_alphabetic('a'));
    // prints --&gt; is_not_alphabetic('a') = false
    dbg!(is_not_alphabetic2('a'));
    // prints --&gt; is_not_alphabetic2('a') = false

}
</code></pre></pre>
<p>In the above code we can see already the new way of creating functions.</p>
<p>These are called “Closures” in Rust. In other languages these are called 
“Lambdas”.</p>
<p>A closure has the syntax:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>|argument1:type1, argument2:type2| { code; code; code; return value; }
<span class="boring">}
</span></code></pre></pre>
<p>You can have a function that accepts no arguments:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>|| { code; code; code; return value; }
<span class="boring">}
</span></code></pre></pre>
<p>And as usual, you can omit the <code>return</code> by skipping the semicolon:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>|| { code; code; code; value }
<span class="boring">}
</span></code></pre></pre>
<p>Finally, if it’s only one statement, we can skip the curly brackets altogether.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>|| value
<span class="boring">}
</span></code></pre></pre>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>|| 3.51
<span class="boring">}
</span></code></pre></pre>
<p>Or:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>|| println!(&quot;Here's a text&quot;)
<span class="boring">}
</span></code></pre></pre>
<p>These are all functions. But you need to store them into a variable or pass them
into a function in order to use them. This syntax, by itself, does nothing.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This makes sense: (gives it a name)
let f1 = || println!(&quot;Here's a text&quot;);
// This does not:
|| println!(&quot;Here's a text&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Or a more advanced example could be:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let c = count(text, |c| matches!(c, 'a'|'e'|'i'|'o'|'u'));
<span class="boring">}
</span></code></pre></pre>
<p>We just created a function that returns true for vowels in less than one line.</p>
<p>This is quite powerful, and it’s okay to feel overwhelmed on this for now.
I won’t be writing code like this, so you don’t need to truly understand all 
these for now.</p>
<p>But it’s important that we know that these exist.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project-a-simple-game-with-macroquad"><a class="header" href="#project-a-simple-game-with-macroquad">Project: A simple game with Macroquad</a></h1>
<p>Macroquad is a simple game engine aimed for beginners that only requires minimal
knowledge of Rust:</p>
<p><a href="https://crates.io/crates/macroquad">https://crates.io/crates/macroquad</a></p>
<p>We will use this game engine only for this game, then we will shift to something
more powerful. This means that in the process you’ll have to learn the API of
this to never use it again, but in fairness, it is pretty simple.</p>
<p>The alternative would be to not do this project now and keep reading theory.
But that’s not fun, and we should put the current knowledge into use, so it 
becomes the foundation for the next things that will come.</p>
<h1 id="survival-pong"><a class="header" href="#survival-pong">Survival pong</a></h1>
<p>A pong game where the player just makes the ball bounce against the wall. It 
scores for each wall hit (even top-down walls).</p>
<p>Every time the ball hits the paddle, it speeds up a bit.</p>
<p>Logically, the tactic has to be to make each shot hitting as many walls as 
possible before returning to the paddle.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="level-adept-1"><a class="header" href="#level-adept-1">Level: Adept</a></h1>
<p>Now we’re getting serious. Hope you did as many exercises as you could, because
we’re reaching a level that is high enough to compare to most books.</p>
<p>From here, you should be able to follow other books too to reinforce this 
learning. </p>
<p>We will push in this stage basically from zero to 100. I’ll get you into a
minimal base, so you will be able to do useful programs after this part.</p>
<p>Magic? Arcane? Not anymore. We’ll get understanding on most concepts in 
programming, so they will stop sounding like black magic.</p>
<p>Let’s use libraries and create programs that perfectly could run
in a production environment.</p>
<blockquote>
<p>NOTE: It’s possible that I’m pushing this section too far. I’m aware that I am
covering too much ground here. Depending on how this plays out I might split
this into two.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="not-everything-are-numbers-and-texts-structs"><a class="header" href="#not-everything-are-numbers-and-texts-structs">Not everything are numbers and texts: Structs</a></h1>
<p>So far we have seen the basic building blocks for almost everything. Functions,
conditions (if), loops (for) and some data types. This will get us already 
very far.</p>
<p>But! For today’s standards, we need a bit more knowledge. One of the pieces that
we have missing and is still critical are structs.</p>
<p>Do not worry. They’re very easy to understand and natural. Structs are basically
composite types. This is, a data type that contains different kinds of data.</p>
<p>For what would we need such a strange thing? Those programmers… are crazy. We
love making up complicated stuff. Hah! Got you! You were thinking this, right?</p>
<p>Anyway, trust me they’re super useful. Let’s assume we want to track points in
2D space. A point in 2D has two coordinates: \(x, y\)</p>
<p>For this, we could write something like:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 0.0;
let y = 0.0;
<span class="boring">}
</span></code></pre></pre>
<p>And we’re done. No need for structs.</p>
<p>Okay, but we want 5 points. Now what?</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let point1_x = 0.0;
let point1_y = 0.0;

let point2_x = 0.0;
let point2_y = 0.0;

let point3_x = 0.0;
let point3_y = 0.0;

let point4_x = 0.0;
let point4_y = 0.0;

let point5_x = 0.0;
let point5_y = 0.0;
<span class="boring">}
</span></code></pre></pre>
<p>Done! Super easy.</p>
<p>But now let’s say we want a function that accepts a point and moves it a certain
amount:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn move_point(mut px: f64, mut py:f64, dx:f64, dy:f64) -&gt; (f64, f64) {
    px += dx;
    py += dy;
    return (px, py);
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Note that this function returns two values. We haven’t seen this yet.</p>
</blockquote>
<p>And now we want to move a point a few units:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (point1_x, point1_y) = move_point(5.0, 0.0, point1_x, point1_y);
<span class="boring">}
</span></code></pre></pre>
<p>Still feels good this kind of coding? Doesn’t it feel clunky?</p>
<p>Wait! There was a mistake in the above code. We passed <code>5.0</code> as the distance
where we should have passed the point. The arguments are in the wrong order!</p>
<p>This, my friend, wouldn’t have occurred with clever uses of structs.</p>
<p>Same idea, but with structs:</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Point2D {
    x: f64,
    y: f64,
}

struct Vector2D {
    dx: f64,
    dy: f64,
}

fn move_point(mut point: Point2D, distance: Vector2D) -&gt; Point2D {
    point.x += distance.dx;
    point.y += distance.dy;
    return point;
}

fn main() {
    let mut p1 = Point2D{x: 0.0,y: 0.0};
    let p2 = Point2D{x: 3.0,y: 0.0};

    let dist = Vector2D{dx: 5.0, dy: 0.0}
    p1 = move_point(p1, dist);
}
</code></pre></pre>
<p>Now we’re talking. Wait, too much? Ok, let’s break it down.</p>
<p>First, we define a new data type called <code>Point2D</code>, which is a struct:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point2D {
    x: f64,
    y: f64,
}
<span class="boring">}
</span></code></pre></pre>
<p>It contains two members: <code>x</code> and <code>y</code>. Both are <code>f64</code> (number with decimals).</p>
<p>With this, we can already create our values of type <code>Point2D</code>.</p>
<p>So, if we did before:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let p: f64;
<span class="boring">}
</span></code></pre></pre>
<p>We can now do:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let p: Point2D;
<span class="boring">}
</span></code></pre></pre>
<p>Because that’s now a user type, and it acts similar to all other types.</p>
<p>To construct it, we simply specify the values of the contents:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let p2 = Point2D{x: 3.0,y: 0.0};
<span class="boring">}
</span></code></pre></pre>
<p>That creates a point <code>p2</code> that sits at <code>3,0</code>.</p>
<p>To access the contents, just use the dot operator:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;x: {}, y: {}&quot;, p2.x, p2.y);
<span class="boring">}
</span></code></pre></pre>
<p>To change the value, you can use the same trick with the dot:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut p1 = Point2D{x: 0.0,y: 0.0};

p1.x = 10.0;

println!(&quot;x: {}, y: {}&quot;, p1.x, p1.y);
<span class="boring">}
</span></code></pre></pre>
<p>Or, if you want, you can also replace the point as a whole instead:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut p1 = Point2D{x: 0.0,y: 0.0};
println!(&quot;x: {}, y: {}&quot;, p1.x, p1.y);

p1 = Point2D{x: 20.0,y: 0.0};

println!(&quot;x: {}, y: {}&quot;, p1.x, p1.y);
<span class="boring">}
</span></code></pre></pre>
<p>I also did the same for something called vector:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Vector2D {
    dx: f64,
    dy: f64,
}
<span class="boring">}
</span></code></pre></pre>
<p>A vector can be used to specify distances or relative positions. While point
is absolute. Other than that, it’s the same thing. Works exactly the same.</p>
<p>So why? If they’re effectively the same thing; both have \(x, y\) and use the
same type, why bother on creating another one? Couldn’t we use the same Point2D
for everything?</p>
<p>Of course! That would work. But it would work… <em>too much</em>.</p>
<p>The issue is that they aren’t technically the same thing. A point is like a 
position in GPS (30ºN, 20ºW), while a vector is a 
distance + length (200 km north-east).</p>
<p>If we confuse those two, we can end with:</p>
<ul>
<li>A position that basically is on the North Pole. (At the zero position)</li>
<li>A vector that says: travel 300,000 km south.</li>
</ul>
<p>Both of which are very wrong.</p>
<p>Remember what happened on the function before where we confused both parts?
Well, not gonna happen now:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn move_point(point: Point2D, distance: Vector2D) -&gt; Point2D {
    point.x += distance.dx;
    point.y += distance.dy;
    return point;
}
<span class="boring">}
</span></code></pre></pre>
<p>This function accepts first a point, then a vector. If you accidentally reverse
them, Rust is not going to accept the program and error out.</p>
<p>So we have now two types that are almost the same thing but can’t be intermixed.</p>
<p>This is <strong>very</strong> useful. 
The amount of errors that get caught this way is tremendous.</p>
<p>Using only one type (point) for everything would at least protect us from mixing
accidentally \(x\) and \(y\) coordinates.</p>
<p>But using two types, ensures that the code stays error-free (mostly).</p>
<p>Structs not only are useful to enforce type-safety. They also are needed to get
more complex types working.</p>
<p>For example, in an invoicing application you might want to store items.</p>
<p>So we could do:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>struct Item {
    name: String,
    price: f64,
    provider: String,
    observations: String,
    obsolete: bool,
    stock: f64,
    min_stock: f64,
    max_stock: f64,
}
<span class="boring">}
</span></code></pre></pre>
<p>And I think this looks very convenient to use, instead of simple variables.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struct-specific-functions-really"><a class="header" href="#struct-specific-functions-really">Struct-specific functions, really?</a></h1>
<p>Really. Remember this function?</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn move_point(mut point: Point2D, distance: Vector2D) -&gt; Point2D {
    point.x += distance.dx;
    point.y += distance.dy;
    return point;
}
<span class="boring">}
</span></code></pre></pre>
<p>Turns out that it acts on points, and it only makes sense on points. So we
can make this function be part of the struct itself.</p>
<p>The idea is that, instead of writing:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>p1 = move_point(p1, d1);
<span class="boring">}
</span></code></pre></pre>
<p>We could write:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>p1 = p1.move_point(d1);
<span class="boring">}
</span></code></pre></pre>
<p>Which looks way nicer. And because “point” is implied, we can rename it:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>p1 = p1.move(d1);
<span class="boring">}
</span></code></pre></pre>
<p>And it’s way more natural now.</p>
<p>So, how we make this happen?</p>
<p>Implementing the struct. There’s the keyword <code>impl</code> and we just do:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Point2D {
    // Stuff here..
}
<span class="boring">}
</span></code></pre></pre>
<p>And inside, we put the function:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Point2D {
    fn move_point(mut point: Point2D, distance: Vector2D) -&gt; Point2D {
        point.x += distance.dx;
        point.y += distance.dy;
        return point;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The first parameter, we call it <code>Self</code> to make the <code>p.move_point</code> magic happen:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Point2D {
    fn move_point(point: Self, distance: Vector2D) -&gt; Point2D {
        point.x += distance.dx;
        point.y += distance.dy;
        return point;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now rename the function to <code>move</code>, because “point” is implied, and voilà:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Point2D {
    fn move(point: Self, distance: Vector2D) -&gt; Point2D {
        point.x += distance.dx;
        point.y += distance.dy;
        return point;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This is all we need to get the fancy stuff in. And the cool part is that these
functions don’t pollute our other code. They’re encapsulated in the type.</p>
<p>If you want to move a point, or do something to a point, you look into the 
functions that are implemented for the point. Which makes sense, right?</p>
<p>Basically we look, and ask: what do points do? And the list of functions tells
us the capabilities of this new type.</p>
<p>Also, if we want we can also call this function explicitly:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>p = p.move(d1);

p = Point2D::move(p, d1); // Exactly the same as the previous line.
<span class="boring">}
</span></code></pre></pre>
<p>Why would we want to do this? Well, right now we don’t. It’s longer, uglier, and
harder to read. When possible, we will use the shorter form.</p>
<p>But this is the key: when possible. Sometimes is not possible, or very 
inconvenient. That’s when this form will come in handy.</p>
<h2 id="a-bit-of-keywords"><a class="header" href="#a-bit-of-keywords">A bit of keywords</a></h2>
<p>When a struct has a variable inside, it is called a <strong>member</strong>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point {
    x: f64,  // &lt;-- this is a member of Point
}
<span class="boring">}
</span></code></pre></pre>
<p>When a function exists inside the implementation of a struct, it is called a
<strong>method</strong>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Point {
    fn move(mut p: Self, d: f64) {  // &lt;-- this is a method of Point
        p.x += d;
        return p;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now you know. Be sure to use these terms as much as possible to avoid those weird
looks from senior devs that seem that want to kill someone. “Have you heard? They
just called a method a ‘function’… A function! How silly is that?”</p>
<p>Also be sure to ask for a pay rise because of this too.<sup class="footnote-reference"><a href="#1">1</a></sup></p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>For those that haven’t caught on the joke, almost all developers are very
snob towards naming things. And they act like these have nothing to do, 
completely different. Furthermore, we keep crafting new names for the same 
thing, up to the point where the same concept has like 20 names. But it feels so
special! I wonder what would happen when they ran out of English words to use<sup class="footnote-reference"><a href="#2">2</a></sup>.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Wait, I do know. See <a href="https://acronyms.thefreedictionary.com/Too+Many+Three+Letter+Acronyms">TMTLA</a>.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="oop-more-like-op"><a class="header" href="#oop-more-like-op">OOP? More like OP.</a></h1>
<p>Have you heard of OOP? In the 90s, Object-Oriented Programming was quite a thing.
Everyone wanted OOP, more OOP. OOP everywhere.</p>
<p>Well, guess where are we now… everything is OOP.</p>
<p><img src="L04adept/../img/oop_everywhere.png" alt="OOP, OOP everywhere" /></p>
<p>To the point that a “Hello World” program in Java requires prior OOP knowledge
to understand it. It is a bit sad and funny at the same time.</p>
<p>Thankfully Rust hasn’t followed this trend, and we managed to stay out of OOP
(for the most part) until now.</p>
<p>But we just saw Structs and methods. And Sir/Madam, this is already OOP.</p>
<p>Java people will tell you (and me) that Rust doesn’t have OOP, and definitely,
what I described here is not OOP by a long, long shot. Never, ever!</p>
<p>Whatever. It is Object-Oriented Programming.</p>
<p>The basics of OOP is that you have something called “Objects” (structs or class), 
and you can spawn many of them. An object has members (variables) and methods 
(functions) associated with them.</p>
<p>That, you already learned.</p>
<p>There’s lots more to OOP, like inheritance (which Rust doesn’t have), access 
permissions, interfaces, etc. Depends on who defines it, they will say OOP must
have more or less things.</p>
<p>But if you ask me, OOP are structs, members, and methods. That’s it. Everything
else is language-dependent.<sup class="footnote-reference"><a href="#1">1</a></sup></p>
<p>You’ll learn later on about Rust Traits, that are similar to Java interfaces. 
Also, quite a huge thing in OOP.</p>
<p>Bottom line is that you know already the basics, don’t let the OOP herd tell you
otherwise.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>And they will say I have no idea about OOP, coding or whatever. And I’m
fine with that.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enums"><a class="header" href="#enums">Enums!</a></h1>
<p>We just saw structs, where we could have a type that contains many things at 
a single time. Structs are one of the basic blocks of programming. Enums are
probably their other half.</p>
<p>Consider the following, what if instead of storing many things at a time, we
wanted to store one of several options?</p>
<p>For example, a type that could be either an integer or a string. But not both.</p>
<p>The usefulness of this, as usual, is hard to see initially. But examples will
follow soon!</p>
<h2 id="a-form-with-options"><a class="header" href="#a-form-with-options">A form with options</a></h2>
<p>Something that is easy to relate are real-world forms. Imagine you were trying
to get the bank to lend money to you, and they lend you a form.</p>
<p>In the form, the following appears:</p>
<blockquote>
<p>What is your current status?</p>
<ul>
<li>(_) Are you working?
<ul>
<li>Name of the company [_______]</li>
<li>Field / Type of company [______]</li>
<li>Type of contract?
(<em>) Permanent full time
(</em>) Permanent part-time
(_) Contractor</li>
</ul>
</li>
<li>(_) Are you studying?
<ul>
<li>Field of study [______]</li>
<li>Years in school [__]</li>
</ul>
</li>
<li>(_) Other, not studying or working.
<ul>
<li>Please specify [________]</li>
</ul>
</li>
</ul>
</blockquote>
<p>Or this:</p>
<blockquote>
<p>Marital Status:</p>
<ul>
<li>(_) Single</li>
<li>(_) Married</li>
<li>(_) Other</li>
</ul>
</blockquote>
<p>These “single choice” options can be represented as Enums.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum MaritalStatus {
    Single,
    Married,
    Other,
}
<span class="boring">}
</span></code></pre></pre>
<p>Then in code, we can choose one of the three options:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let status1 = MaritalStatus::Single;
let status2 = MaritalStatus::Married;
let status3 = MaritalStatus::Other;
<span class="boring">}
</span></code></pre></pre>
<p>Of course, you can put as many options as you want!</p>
<p>But, for “Other” we don’t really know what happened here, so we want to have
the user to specify what they meant by “Other”:</p>
<blockquote>
<p>Marital Status:</p>
<ul>
<li>(_) Single</li>
<li>(_) Married</li>
<li>(X) Other  [_________________]</li>
</ul>
</blockquote>
<p>In Rust, we do:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum MaritalStatus {
    Single,
    Married,
    Other(String),
}
<span class="boring">}
</span></code></pre></pre>
<p>Now, if we specify “Other” we need to put text with it:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let status3 = MaritalStatus::Other(&quot;divorced&quot;.to_string());
<span class="boring">}
</span></code></pre></pre>
<p>You can also have names and multiple values inside too:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum MaritalStatus {
    Single,
    Married,
    Other{ status: String, observations: String},
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let status3 = MaritalStatus::Other {
    status: &quot;divorced&quot;.to_string(),
    observations: &quot;in 2004&quot;.to_string(),
};
<span class="boring">}
</span></code></pre></pre>
<p>More complex enums are possible, as you can compose them with structs:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum ContractType {
    PermFullTime,
    PermPartTime,
    Contractor,
}

struct Work {
    company_name: String,
    field: String,
    contract_type: ContractType,
}

struct Study {
    field: String,
    years: i64,
}

enum CurrentStatus {
    Work,
    Study,
    Other { specify: String },
}
<span class="boring">}
</span></code></pre></pre>
<p>This reflects the earlier form:</p>
<blockquote>
<p>What is your current status?</p>
<ul>
<li>(_) Are you working?
<ul>
<li>Name of the company [_______]</li>
<li>Field / Type of company [______]</li>
<li>Type of contract?
(<em>) Permanent full time
(</em>) Permanent part-time
(_) Contractor</li>
</ul>
</li>
<li>(_) Are you studying?
<ul>
<li>Field of study [______]</li>
<li>Years in school [__]</li>
</ul>
</li>
<li>(_) Other, not studying or working.
<ul>
<li>Please specify [________]</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="enums-in-other-languages"><a class="header" href="#enums-in-other-languages">Enums in other languages</a></h2>
<p>In C++, Java and most other languages, enums are much simpler and can’t do
most of what Rust can.</p>
<p>In fact, they’re just a fancy way of creating constant values associated to
numbers.</p>
<p>Imagine we’re writing a library to open files, and we have a file mode:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum FileMode {
    Read,       // -&gt; 0
    Write,      // -&gt; 1
    ReadWrite,  // -&gt; 2
    Create,     // -&gt; 3
    Append,     // -&gt; 4
}
<span class="boring">}
</span></code></pre></pre>
<p>These are very similar to creating constants associated to numbers:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const READ: u16      = 0;
const WRITE: u16     = 1;
const READWRITE: u16 = 2;
const CREATE: u16    = 3;
const APPEND: u16    = 4;
<span class="boring">}
</span></code></pre></pre>
<p>Having an enum makes the creation simpler, and groups everything together nicely.</p>
<p>It starts counting at zero, but we can assign a particular number if we want. It
will continue counting from there:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum FileMode {
    Read = 12,  // -&gt; 12
    Write,      // -&gt; 13
    ReadWrite,  // -&gt; 14
    Create,     // -&gt; 15
    Append,     // -&gt; 16
}
<span class="boring">}
</span></code></pre></pre>
<p>If we have two numbers or more assigned, it works too:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum FileMode {
    Read = 12,  // -&gt; 12
    Write,      // -&gt; 13
    ReadWrite,  // -&gt; 14
    Create = 20,// -&gt; 20
    Append,     // -&gt; 21
}
<span class="boring">}
</span></code></pre></pre>
<p>In Rust, you can extract the actual number by casting to integer:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>dbg!(FileMode::ReadWrite as u16);
<span class="boring">}
</span></code></pre></pre>
<p>Another example:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Numbers {
    One = 1,        // -&gt;  1
    Two,            //     2
    Three,          //     3
    Four,           //     4

    FourtyTwo = 42, // -&gt; 42
    FourtyThree,    //    43
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="other-examples"><a class="header" href="#other-examples">Other examples</a></h2>
<p>Imagine a datatype called <code>When</code> that could take any of the following:</p>
<ul>
<li>“Tomorrow”: As in, the meeting will be tomorrow.</li>
<li>12 (hours): Even will happen in 12 hours.</li>
</ul>
<p>In a struct, the problem is that we must have two fields and one must remain
empty:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct When {
    name String,
    hours i64,
}
<span class="boring">}
</span></code></pre></pre>
<p>However, Rust doesn’t allow them to be empty. So we might be compelled to use
zero as empty or the empty name as not set. But this isn’t a good practice.
Using special values with special meanings is a bad idea in programming. We had
a long history with special values, and it usually ends in bugs.</p>
<p>Here’s where an Enum helps:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum When {
    name(String),
    hours(i64),
}
<span class="boring">}
</span></code></pre></pre>
<p>This can only take one of the values. Either is name or is hours.</p>
<p>We use them like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tomorrow = When::name(&quot;tomorrow&quot;.to_string());
let hours_3 = When::hours(3);
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>C++ has something similar to this, called union. But it’s not safe to use. 
Rust does have union as well and trust me, you don’t want to use unions unless
you really, really… really know what you’re doing.</p>
</blockquote>
<p>They also are useful to define names, for example a list of operation modes:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum OperationMode {
    Read,
    ReadWrite,
    Append,
    Create,
    SelfDestruct,
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Don’t confuse Rust enums with C++/Java enums. In these languages enums are 
useful only to associate a number to a name. Rust enums are way more powerful.</p>
</blockquote>
<p>You might say: “Well, nice, but I don’t see myself using this ever. How is this
a critical thing to know for a beginner?”</p>
<p>And the answer is that Rust itself is plagued with two very popular enums. 
You can’t avoid it. You’ll have enums in your code, want it or not.</p>
<p>These enums are <code>Option&lt;T&gt;</code> and <code>Result&lt;T&gt;</code>. I’ll discuss them now.</p>
<h2 id="option"><a class="header" href="#option">Option</a></h2>
<p>Option is basically:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option {
    Some(value),
    None,
}
<span class="boring">}
</span></code></pre></pre>
<p>And it is used when a value can be empty. But truly empty. Missing. Nil. Gone.</p>
<p>Because, you see, this is the empty string:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let text = &quot;&quot;.to_string();
<span class="boring">}
</span></code></pre></pre>
<p>But it’s not missing. It’s an empty string. The value is not empty; it contains
an empty string. Weird, hah!</p>
<p>You want an empty value?</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let text: Option&lt;String&gt; = None;
<span class="boring">}
</span></code></pre></pre>
<p>This one is empty.</p>
<p>And we can use this to have optional parameters in a function or a struct:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct User {
    username String,
    real_name Option&lt;String&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="result"><a class="header" href="#result">Result</a></h2>
<p>The other enum Result, is similar to this:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result {
    Ok(value),
    Err(error),
}
<span class="boring">}
</span></code></pre></pre>
<p>This is used to have fallible operations. If something fails, it will return an
<code>Err(error)</code>. The <code>error</code> inside contains details on what failed. If it works,
returns <code>Ok(value)</code> where <code>value</code> contains the data we needed.</p>
<p>For example, consider a function to divide:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn divide(a: f64, b: f64) -&gt; f64 {
    return a / b;
}
<span class="boring">}
</span></code></pre></pre>
<p>However, divide by zero is an error. To be able to communicate this error we can
do:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn divide(a: f64, b: f64) -&gt; Result&lt;f64&gt; {
    if b == 0 {
        return Err(DivideByZeroError);
    }
    return Ok(a / b);
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="unwrap"><a class="header" href="#unwrap">Unwrap</a></h1>
<p>As commented, Rust libraries are full of <code>Option</code> and <code>Result</code>. So it’s very
easy to find something that returns these things.</p>
<p>For example, if we want to parse a string into a number:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let num: i64 = &quot;1235&quot;.parse();
<span class="boring">}
</span></code></pre></pre>
<p>This doesn’t work because <code>parse()</code> will return a <code>Result</code> and not an <code>i64</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let num: Result&lt;i64&gt; = &quot;1235&quot;.parse();
<span class="boring">}
</span></code></pre></pre>
<p>But this is inconvenient. If we know that the result is going to be Ok, we
can use unwrap:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result_num: Result&lt;i64&gt; = &quot;1235&quot;.parse();
let num: i64 = result_num.unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>Or, in one line:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let num: i64 = &quot;1235&quot;.parse().unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>The problem with <code>unwrap()</code> is that <strong>will make the program crash</strong> if the result
is an error. So be careful when using this in places that are not guaranteed to
do as expected.</p>
<p>If you are okay with making the program crash at that point, consider using
<code>expect()</code> instead, which does the same but allows you to provide a message:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let num: i64 = &quot;1235&quot;.parse().expect(&quot;failed to parse credit card number&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>However, if making the program crash is not a good idea, you have to handle the
error:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result_num: Result&lt;i64&gt; = &quot;1235&quot;.parse();
match result_num {
    Ok(num) =&gt; {
        // .. handle here the parsed number ..
    },
    Err(e) =&gt; {
        // .. handle the error ..
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Rust forces you to choose what to do with the errors. There’s no “default action”
but instead, compiler errors and warnings until you decide to <code>unwrap</code> or handle
it. If you don’t decide, you’ll get complaints.</p>
<p>Oh, and this works with option too!</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// TODO: divide was returning a result - find another example!
let result_num: Option&lt;f64&gt; = divide(3.0, 1.2);
match result_num {
    Some(num) =&gt; {
        // .. handle here the parsed number ..
    },
    None =&gt; {
        // .. 
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="understanding-rust-enums-internals"><a class="header" href="#understanding-rust-enums-internals">Understanding Rust Enums internals</a></h2>
<blockquote>
<p>WARN: Technical info ahead! This describes how things work in memory 
internally. This section is not required to understand, and feel free to skip.
But for some readers, this might give some insight and understanding on Enums.
Don’t obsess into understanding everything; just a general overview here is fine.</p>
</blockquote>
<p>In C++ (and Rust) we have something called “unions”. A union is a type where
all contents will be stored in the same place in memory.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>union MyData {
    integer: i64,
    float: f32,
    text: [char; 20],
}
<span class="boring">}
</span></code></pre></pre>
<p>These contents will be put one on top of the other, overlapping the same region
in memory.</p>
<p>If we did a struct like that:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyData {
    integer: i64,
    float: f32,
    text: [char; 20],
}
<span class="boring">}
</span></code></pre></pre>
<p>In the memory we will have:</p>
<pre><code>  integer float        text
[________][____][____________________]
</code></pre>
<p>All variables will be packed one after another.</p>
<p>However, if we were only going to use one of those at a time, we would be 
wasting a lot of memory of the computer.</p>
<p>Unions instead put everything in the same place:</p>
<pre><code>[________] integer
[____] float
[____________________] text
</code></pre>
<p>Or, more accurately:</p>
<pre><code>float integer text
[____]___]___________]
</code></pre>
<p>There are bytes in memory that will be shared across the float, the integer, 
and the text. Because of this, they use only the memory needed to hold the
largest variable that they can contain.</p>
<p>This makes unions very dangerous as if you write text and then read float you’ll
get back basically garbage.</p>
<p>That’s why, in Rust, reading unions is unsafe.</p>
<p>But if we knew what field we wrote, then we could actually read it without risk 
of getting back garbage.</p>
<p>Imagine we had constants to specify which field it is:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const FIELD_FLOAT: u8 = 0;
const FIELD_INTEGER: u8 = 1;
const FIELD_TEXT: u8 = 2;
<span class="boring">}
</span></code></pre></pre>
<p>And then we store this along with the union, inside a struct:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>union MyData {
    integer: i64,
    float: f32,
    text: [char; 20],
}

struct MyDataSafe {
    field_written: u8,
    data: MyData,
}
<span class="boring">}
</span></code></pre></pre>
<p>Now, as long as we always keep the <code>field_written</code> up to date, we know which one
was used, so we can read confidently <code>data</code> without risk of getting back 
corrupted values.</p>
<p>We could write an implementation like this to ensure this is the case:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl MyDataSafe {
    pub fn write_integer(&amp;mut self, i: i64) {
        self.field_written = FIELD_INTEGER;
        self.data.integer = i;
    }
    pub fn write_float(&amp;mut self, f: f32) {
        self.field_written = FIELD_FLOAT;
        self.data.float = f;
    }
    pub fn write_text(&amp;mut self, t: [char; 20]) {
        self.field_written = FIELD_TEXT;
        self.data.text = t;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>And we could read “safely”:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl MyDataSafe {
    pub fn read_integer(&amp;self) -&gt; i64 {
        if self.field_written != FIELD_INTEGER {
            panic!(&quot;wrong field type&quot;);
        }
        unsafe {self.data.integer}
    }
    pub fn write_float(&amp;self) -&gt; f32 {
        if self.field_written != FIELD_FLOAT {
            panic!(&quot;wrong field type&quot;);
        }
        unsafe {self.data.float}
    }
    pub fn write_text(&amp;self) -&gt; [char; 20] {
        if self.field_written != FIELD_TEXT {
            panic!(&quot;wrong field type&quot;);
        }
        unsafe {self.data.text}
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Notice two things here. First, when we created the struct:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyDataSafe {
    field_written: u8,
    data: MyData,
}
<span class="boring">}
</span></code></pre></pre>
<p>The layout in memory is:</p>
<pre><code>   float integer text
[_][____]___]___________]
 ^    
 --- field_written
</code></pre>
<p>Second, those constants:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const FIELD_FLOAT: u8 = 0;
const FIELD_INTEGER: u8 = 1;
const FIELD_TEXT: u8 = 2;
<span class="boring">}
</span></code></pre></pre>
<p>Are actually a regular C++ enum:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Field {
    Float,
    Integer,
    Text,
}
<span class="boring">}
</span></code></pre></pre>
<p>And the struct:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyDataSafe {
    field_written: u8,
    data: MyData,
}
<span class="boring">}
</span></code></pre></pre>
<p>Is actually an equivalent of a Rust Enum!</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Field {
    Float(f32),
    Integer(i64),
    Text([char; 20]),
}
<span class="boring">}
</span></code></pre></pre>
<p>That’s what it actually is! Rust enums are kind of “safe C++ style unions”.</p>
<p>They use only the memory needed for the biggest value possible of all options,
and they’re safe. Plus an extra byte or two to hold which variant are we talking
about.</p>
<blockquote>
<p>In some cases, Rust is “too smart” and it’s able to omit the extra byte needed
to store the variant by using some tricks when compiling. But that is outside
what I want to cover here.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="match"><a class="header" href="#match">Match!</a></h1>
<p>Have you ever seen code like this?</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>let choice = 1;

if choice == 1 {
    guess_game();
} else if choice == 2 {
    convert_units();
} else if choice == 3 {
    test_unwrap();
} else if choice == 4 {
    quit();
}
<span class="boring">}
</span></code></pre></pre>
<p>Have you wondered if that could be written in a clearer way?</p>
<p>Then you’re in luck! Presenting the <code>match</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let choice = 1;
match choice {
    1 =&gt; guess_game(),
    2 =&gt; convert_units(),
    3 =&gt; test_unwrap(),
    4 =&gt; quit(),
    _ =&gt; {},
}
<span class="boring">}
</span></code></pre></pre>
<p>As you can see, <code>match</code> has a beautiful syntax. Concise, yet powerful, that goes
to the point.</p>
<p>What <code>match</code> does is exploring different options that a value can take. So, if
we do:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let choice: i64 = 1;
match choice {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>It is going to consider what values <code>choice</code> can take. Since it is an <code>i64</code>, it
can take billions of different numbers, either positive or negative, and for
each one we can specify what to do in each case.</p>
<p>But it does have a catch, as <code>match</code> requires us to consider <strong>all</strong> 
possibilities. That is, we need to cover all possible numbers and specify an
action for it.</p>
<p>To avoid specifying all options one by one, we can have a default by using the
underscore <code>_ =&gt; ...</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let choice: i64 = 1;
match choice {
    1 =&gt; do_something(),
    _ =&gt; panic!(&quot;Invalid option!&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<p>It can understand ranges too:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let choice: i64 = 1;
match choice {
    1 =&gt; do_something(),
    2..=10 =&gt; panic!(&quot;This option is not supported yet&quot;),
    _ =&gt; panic!(&quot;Invalid option!&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<p>And it can understand enums too!</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Choice {
    GuessGame,
    ConvertUnits,
    TestUnwrap,
    Quit,
    InvalidChoice,
}

let choice = Choice::GuessGame;
match choice {
    Choice::GuessGame =&gt; guess_game(),
    Choice::ConvertUnits =&gt; convert_units(),
    Choice::TestUnwrap =&gt; test_unwrap(),
    Choice::Quit =&gt; quit(),
    Choice::InvalidChoice =&gt; {},
}
<span class="boring">}
</span></code></pre></pre>
<p>And this is useful to handle errors:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let input_number = &quot;12345&quot;; // provided by user
let res_number:Result&lt;i64&gt; = input_number.parse();

match res_number {
    Ok(number) =&gt; println!(&quot;your number is {}&quot;, number),
    Err(e) =&gt; println!(&quot;There was an error parsing your number: {:?}&quot;, e),
}
<span class="boring">}
</span></code></pre></pre>
<p>A bit more advanced usage could be:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let input_number = &quot;12345&quot;; // provided by user
let number:i64 = match input_number.parse() {
    Ok(number) =&gt; number,
    Err(e) =&gt; {
        println!(&quot;There was an error parsing your number: {:?}&quot;, e);
        return;
    }
};

println!(&quot;your number is {}&quot;, number);
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="floating-point-gotchas"><a class="header" href="#floating-point-gotchas">Floating point gotchas</a></h1>
<p>Let’s begin saying that, in math:</p>
<p>\[ 1.1 + 1.1 + 1.1 = 3.3 \]</p>
<p>That is obvious.</p>
<p>But in computers:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 1.1;
let b = 3.3;

let c = a + a + a;

println!(&quot;b = {}&quot;, b);
println!(&quot;c = {}&quot;, c);
println!(&quot;b == c? -&gt; {}&quot;, b == c);
println!(&quot;b - c = {}&quot;, b - c);

<span class="boring">}
</span></code></pre></pre>
<p><code>b</code> is not equal to <code>c</code>. The difference is <code>-0.0000000000000004440892098500626</code>.</p>
<p>Of course, this is wrong. The difference should have been zero. But this is not
how computers work.</p>
<p>Surprised? We thought computers were stupid glorified calculators, but they 
can’t even get a simple sum right.</p>
<p>This is because how decimals work in a computer when using floating points. 
They use base 2 (ones and zeros) to represent the numbers, and when we have a
number that has a decimal point, this becomes a problem.</p>
<blockquote>
<p>If you’re not interested on the explanation, just remember that you cannot
expect any two floats to be equal. You have to check if they are 
“close enough”. Also, before converting them to integer, you first have to
round them. You might think you have 295.0 but in reality it might be 
294.999999999996, and if you just cut the decimals instead of rounding you
get 294 instead of 295. It feels stupid, because it is.</p>
</blockquote>
<p>We need to understand that not all numbers can be written down.</p>
<p>Yes, let that sink in. There are numbers you can’t write.</p>
<p>For example \(\pi\), we can write <code>3.1415</code> but doesn’t matter for how long we
try, it will never be the real \(\pi\). Because it’s irrational.</p>
<p>But on the real numbers it also happens. Even in the rational ones (fractional).</p>
<p>A common example is \(10 / 3\):</p>
<p>\[\frac{10}{3}=3.333333333…\]</p>
<p>It doesn’t matter how long you keep writing, you cannot write it down.</p>
<p>Why?</p>
<p>Well, our system is decimal, base 10. And \(10 = 2 × 5\).</p>
<p>This means we can only represent fractions that divide by multiples of 2 and 5.</p>
<p>So, for example the following fractions are representable:</p>
<p>\[\frac{1}{25}\]</p>
<p>\[\frac{6}{2560}\]</p>
<p>But \(1/3\) is not, because 3 is a prime, and our decimal system doesn’t 
include 3 as a factor.</p>
<p>Now, for a computer that is using a binary system the only factor is 2.</p>
<p>This means that when a number is the result of dividing by 5, we can probably
represent, but the computer cannot.</p>
<p>The number 1.1 is in reality:</p>
<p>\[\frac{11}{2 × 5}\]</p>
<p>The computer can represent \(11/2=5.5\) but not \(11/10=1.1\).</p>
<p>That will lead to infinite decimals, but a <code>f64</code> will cut at some point. And
there you have your imprecision. While your written number comes with full
precision, the one written by the computer can’t get that level of precision
regardless of having 20 or 500 decimal places.</p>
<p>Do you think it’s lame?</p>
<p>Try writing down:</p>
<p>\[\frac{100}{29}\]
\[\frac{100}{53}\]
\[\frac{100}{97}\]</p>
<p>Were you able to do it? No?</p>
<p>Lame!</p>
<p>Well, that’s how your computer feels. Please be respectful. 
They only have base 2 to work with.</p>
<h2 id="is-this-a-rust-problem"><a class="header" href="#is-this-a-rust-problem">Is this a Rust problem?</a></h2>
<p>No, it is a hardware problem. All languages suffer from this. Some of them are
better than others at hiding this fact.</p>
<p>There exist “Decimal” implementations in some languages including Rust that
use base 10 and get rid of this problem entirely.</p>
<p>But those are much slower, but used in financial applications to prevent errors.</p>
<h2 id="why-this-wasnt-addressed"><a class="header" href="#why-this-wasnt-addressed">Why this wasn’t addressed?</a></h2>
<p>When they created floating points, computers were very slow and memory was very
limited. Adding support for base 10 decimal numbers would have been near 
impossible and most of the programs of the era wouldn’t have enough resources to
run.</p>
<p>Also, floats were invented for scientific purposes, like sending people to the
moon. In this case, high precision was better than having base 10. Because even
if they can’t fully represent some numbers, overall they give better precision
to numbers that arise from physics calculations.</p>
<p>So they went with that, and we’re stuck with them forever. Nowadays, the 
majority of the applications would benefit from base 10, and there is more than
enough resources to run them in this manner. Yet we keep doing this in software.</p>
<p>I guess that everyone got used to this, and no one cares anymore.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Comparing if two floats are equal: bad.</p>
<p>Comparing if two floats are not equal: very bad.</p>
<p>Converting to integer without rounding: super-mega bad.</p>
<h3 id="what-to-do-instead"><a class="header" href="#what-to-do-instead">What to do instead?</a></h3>
<p><strong>Comparing if two floats are equal:</strong></p>
<p>Instead, check if the difference between them is very small:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 1.1;
let b = 1.1;

if (a-b).abs() &lt; 0.00000001 {
    // equal
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>Comparing if two floats are not equal:</strong></p>
<p>Instead, check if the difference between them is bigger than a very small number:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 1.1;
let b = 1.1;

if (a-b).abs() &gt; 0.00000001 {
    // not equal
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>Converting to integer without rounding:</strong></p>
<p>Please round first:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a:f32 = 294.999999999;
let b:i64 = a.round() as i64;
<span class="boring">}
</span></code></pre></pre>
<h2 id="other-problems"><a class="header" href="#other-problems">Other problems</a></h2>
<h3 id="not-a-number"><a class="header" href="#not-a-number">Not A Number?</a></h3>
<p>See 0/0.</p>
<h3 id="infinity"><a class="header" href="#infinity">Infinity?</a></h3>
<p>See 1/0 and -1/0.</p>
<h3 id="positive-and-negative-zeros"><a class="header" href="#positive-and-negative-zeros">Positive and negative zeros?</a></h3>
<p>See \(1 × 0\) and \(-1 × 0\)</p>
<h3 id="not-sortable"><a class="header" href="#not-sortable">Not sortable</a></h3>
<p>In Rust, if you have data in a table that are floats, and you want to sort this
data, you can’t.</p>
<p>Because of <code>NaN</code>, floats cannot be sorted. But they can be partially sorted.</p>
<h3 id="not-infinitely-big"><a class="header" href="#not-infinitely-big">Not infinitely big</a></h3>
<h3 id="loss-of-precision-at-very-big-numbers"><a class="header" href="#loss-of-precision-at-very-big-numbers">Loss of precision at very big numbers</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules---splitting-files"><a class="header" href="#modules---splitting-files">Modules - splitting files</a></h1>
<p>Having all the program into a single file stops being convenient as the program
gets bigger and bigger. One hundred lines are fine, 1000 maybe, but 5000 is 
definitely too big to handle.</p>
<p>The problem is as the file grows we easily lose track of things, in which parts 
they were and so on.</p>
<p>The whole folder that <code>cargo new</code> created for us is called a project. So if we
recall when we created the initial project:</p>
<pre><code class="language-console">$ cargo new learnrust
     Created binary (application) `learnrust` package
</code></pre>
<p>But so far we have been adding different binaries, and with that we have been 
creating different files.</p>
<pre><code class="language-console">src
├── bin
│   ├── enums2.rs
│   ├── enums.rs
│   ├── hashmap.rs
│   ├── print.rs
│   ├── sample1.rs
│   ├── structs.rs
│   ├── turtle_loops.rs
│   ├── turtle_vars.rs
│   └── variables.rs
└── main.rs
</code></pre>
<p>However, these are not modules! Those are binaries.</p>
<p>Modules can be reused between different files while binaries can only be 
compiled as full programs. We cannot get a function from a binary into a 
different one.</p>
<p>To share functionality we need to move it into modules.</p>
<p>For example, let’s say we need something to be reused. Maybe we want a file that
contains units of measure.</p>
<p>So we’ll create a new file called <code>src/units.rs</code>.</p>
<p>And we add a few units of length. Or all of them now that we’re on this:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum LengthUnit {
    Kilometer,
    Meter,
    Millimeter,
    Inch,
    Angstrom,
    Mile,
    Furlong,
    Chain,
    Rod,
    Fathom,
    Yard,
    Foot,
    Parsec,
    LightYear,
    AstronomicalUnit,
}

<span class="boring">}
</span></code></pre></pre>
<p>Yay! We got a new module. Or do we?</p>
<p>So in order to be a full module we should be importing this from another file.</p>
<p>For <code>src/main.rs</code> we can add the following line at the top:</p>
<pre><pre class="playground"><code class="language-rust edition2021">mod units; // &lt;-- this line!

fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>This will declare the module. Now we can use <code>units::LengthUnit</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">mod units;

fn main() {
    println!(&quot;Hello, world!&quot;);

    let m = units::LengthUnit::LightYear;
    dbg!(m);
}
</code></pre></pre>
<p>This is difficult to type down, so we can add a <code>use</code> line to bring <code>LengthUnit</code>
into scope:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use units::LengthUnit;
<span class="boring">}
</span></code></pre></pre>
<p>Then we can just do:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let m = LengthUnit::LightYear;
<span class="boring">}
</span></code></pre></pre>
<p>And that’s it! We’re sharing code across files.</p>
<p>We just did a simple enum, but it can be constants, structs, functions, whatever.</p>
<h2 id="adapting-for-binaries-in-srcbin"><a class="header" href="#adapting-for-binaries-in-srcbin">Adapting for binaries in src/bin</a></h2>
<p>For the programs that we have inside the <code>src/bin/</code> folder this does not work
as Rust is expecting the modules to also live in <code>src/bin/</code>.</p>
<p>Unless you want to have a messy code where all the files are on this folder, we
need a way to tell Rust to read in the parent folder instead.</p>
<p>To fix this, we need to create a file named <code>src/lib.rs</code> (in the parent folder).</p>
<p>In this file we will have only the following lines:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod units;
pub use units::LengthUnit;
<span class="boring">}
</span></code></pre></pre>
<p>This will enable us to use the modules in the whole package.</p>
<p>Let’s create a new binary for testing this. We will call this
<code>src/bin/conversor.rs</code>.</p>
<p>Remember to update <code>Cargo.toml</code> to add this binary.</p>
<p>As usual, we need a <code>fn main()</code> to start a new binary: </p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    // ...
}
</code></pre></pre>
<p>Notice how <code>conversor.rs</code> does need a main, but <code>units.rs</code> does not.</p>
<p>Now we can bring to scope what we want. Feel free to choose the line you prefer:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use learnrust::units;
use learnrust::LengthUnit;
<span class="boring">}
</span></code></pre></pre>
<p>In my case, I think I’ll settle with <code>use learnrust::LengthUnit;</code> as it’s more
convenient.</p>
<pre><pre class="playground"><code class="language-rust edition2021">use learnrust::LengthUnit;

fn main() {
    let furlong = LengthUnit::Furlong;
    dbg!(furlong);
}
</code></pre></pre>
<p>Let’s try <code>cargo run --bin conversor</code>:</p>
<pre><code class="language-console">$ cargo run --bin conversor
    Finished dev [unoptimized + debuginfo] target(s) in 0.04s
     Running `target/debug/conversor`
[src/bin/conversor.rs:5] furlong = Furlong
</code></pre>
<p>Yay! This works!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-are-those-other-data-types-for"><a class="header" href="#what-are-those-other-data-types-for">What are those other data types for?</a></h1>
<p>So we talked earlier about Rust data types, and we’re just using a few. 
Why do they exist? Let’s put them together here:</p>
<table><thead><tr><th>Type</th><th>Min</th><th>Max</th></tr></thead><tbody>
<tr><td>u8</td><td>0</td><td>255</td></tr>
<tr><td>u16</td><td>0</td><td>65535</td></tr>
<tr><td>u32</td><td>0</td><td>4294967296</td></tr>
<tr><td>u64</td><td>0</td><td>1.84 * 10^19</td></tr>
</tbody></table>
<table><thead><tr><th>Type</th><th>Min</th><th>Max</th></tr></thead><tbody>
<tr><td>i8</td><td>-128</td><td>127</td></tr>
<tr><td>i16</td><td>-32768</td><td>32767</td></tr>
<tr><td>i32</td><td>-2147483648</td><td>2147483647</td></tr>
<tr><td>i64</td><td>-9.22 * 10^18</td><td>9.22 * 10^18</td></tr>
</tbody></table>
<p>Examples:</p>
<ul>
<li>u8 is generally used to represent characters in the ASCII table, and also bytes in a file in disk.</li>
<li>u16 is used for storing UTF16 characters, which are 2 byte long.</li>
<li>u32 can be used to store colors of pixels of an image (Red, Green, Blue and Alpha)</li>
</ul>
<p>While a single number might be small in comparison to the amount of memory a 
computer has, some programs are in fact “number crunching programs”, where 
millions or even billions of numbers need to be processed very fast. When you 
have so much data, compacting it on the smallest possible representation will 
save memory and/or disk space.</p>
<p>That is why, for what we’re doing in this guide we don’t care that much 
and use i64 for everything. All in all these are toy programs. Our toy 
programs don’t do much and the difference in memory used is roughly zero.</p>
<p>In real life, things are different. Say you want to read a JPG photo from 
your phone camera and do some process on it, like enhancing the photo. A photo 
can easily be 16 million pixels, and if for each pixel we use an i64 for each 
color (Red, Green and Blue), we would be wasting a lot of memory.</p>
<p>A program that plays chess by itself has to consider billions of chess 
possibilities, in this case it is also important to keep each representation as 
compact as possible.</p>
<p>On the other hand, there are also the two float types, f32 and f64. 
The difference between them is not the maximum or minimum number like integers, 
but the amount of significant digits they can carry. f32 can record 6 digits 
correctly (and a few extra ones) while f64 can record more than 12.</p>
<!-- TODO: in fact, f64 can represent bigger numbers than f32, but not that this does matter here... -->
<p>Floating point numbers are used specially on scientific problems. Depending on 
the problem at hand an f64 might be required, while in others f32 might be better 
as it has enough precision, but it is smaller, allowing for much complex simulations.</p>
<p>Graphics cards use a lot of floating point numbers to draw scenes for a game. 
If the precision is not high enough it might lead to jitter: <a href="https://www.youtube.com/watch?v=jsLiDQyyBXk">https://www.youtube.com/watch?v=jsLiDQyyBXk</a></p>
<p>I hope this helps to understand why these types exist, and why we aren’t using them for now.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project-a-simple-game-with-ggez"><a class="header" href="#project-a-simple-game-with-ggez">Project: A simple game with ggez</a></h1>
<p>Now that we know a bit about structs, enums and similar stuff, we’re ready for
our next game.</p>
<p>As expected, we will change the game engine to something more appropriate: ggez</p>
<p><a href="https://crates.io/crates/ggez">https://crates.io/crates/ggez</a></p>
<p>In comparison with Macroquad that we have seen before, this one uses structs. 
Because of this we can organize our code much better and make a game that can 
grow in features without getting too convoluted.</p>
<h2 id="space-recycler"><a class="header" href="#space-recycler">Space-recycler</a></h2>
<p>A horizontal shooter game (ship) where the goal is to avoid asteroids while
collecting as much trash as possible.</p>
<p>For extra difficulty, we’ll have different recycling bins and the player
has to put each item in the right bin. Because this is a game about recycling!</p>
<p>This is a complex project, and it will take quite a bit of time to complete.
It took me around 20 hours to figure out everything, so I guess for someone
that is still learning it could take 1-2 weeks.</p>
<p>But no worries, I will be assisting, so hopefully that cuts back as much 
time as possible.</p>
<h2 id="creating-the-new-project"><a class="header" href="#creating-the-new-project">Creating the new project</a></h2>
<p>As this is a complete game, we will have it in its own crate (or folder). 
We’ll begin by creating it:</p>
<pre><code class="language-console">$ cargo new spacerecycler
</code></pre>
<p>We can add already the dependencies we will need in <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]
name = &quot;spacerecycler&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]
ggez = &quot;0.7.0&quot;
rand = &quot;0.8&quot;

[profile.dev.package.&quot;*&quot;]
opt-level = 2
</code></pre>
<p>That would add <code>ggez</code> at version 0.7 and <code>rand</code> at 0.8.</p>
<p>The part for <code>[profile.dev.package.&quot;*&quot;]</code> is important. That tells Rust how
to compile the dependencies when in debug mode. <code>opt-level = 2</code> enables the
optimizer at the same level as for release.</p>
<p>Effectively this makes a debug build to have the libraries compiled as optimized
as possible. And it’s important because <code>ggez</code> and all the dependencies that it
pulls are related to graphics. And graphics are intensive operations. While
developing, we will need those to be as fast as possible.</p>
<p>However, our code will be still compiled fully in debug mode. This means that
compilation times will be fast, and it will detect most of the errors at runtime
properly.</p>
<p>For now, proceed to build it. This will take a long time so make a cup of tea:</p>
<pre><code class="language-console">$ cargo build
</code></pre>
<p>This will download a lot of libraries and compile them. Because of the amount
of stuff that needs to be built, expect 10 minutes of compilation time.</p>
<p>Remember, these dependencies will be built in almost release mode. Building in
release takes more time.</p>
<p>Once it is built, we can go ahead and start some coding.</p>
<h2 id="the-first-window"><a class="header" href="#the-first-window">The first window</a></h2>
<p>The setup phase is a bit large, so please trust me for a minute.</p>
<p>On <code>main.rs</code> copy the following contents:</p>
<pre><pre class="playground"><code class="language-rust edition2021">mod game;

use ggez::conf::{NumSamples, WindowMode, WindowSetup};
use ggez::event;
use ggez::ContextBuilder;

use game::SpaceRecyclerGame;

const WIDTH: f32 = 1200.0;
const HEIGHT: f32 = 600.0;
const MARGIN_W: f32 = 15.0;

fn main() {
    let window_cfg = WindowSetup {
        title: &quot;Space Recycler&quot;.to_owned(),
        vsync: false,
        samples: NumSamples::Four,
        ..Default::default()
    };
    let window_mode = WindowMode {
        width: WIDTH,
        height: HEIGHT,
        maximized: false,
        resizable: false,
        visible: true,
        resize_on_scale_factor_change: false,
        ..Default::default()
    };

    // Make a Context.
    let (mut ctx, event_loop) = ContextBuilder::new(&quot;space_recycler&quot;, &quot;Cool Game Author&quot;)
        .window_setup(window_cfg)
        .window_mode(window_mode)
        .build()
        .expect(&quot;aieee, could not create ggez context!&quot;);

    // Create an instance of your event handler.
    // Usually, you should provide it with the Context object to
    // use when setting your game up.
    let space_recycler = SpaceRecyclerGame::new(&amp;mut ctx).expect(&quot;Error intializing game&quot;);

    // Run!
    event::run(ctx, event_loop, space_recycler);
}
</code></pre></pre>
<p>We need to create another file <code>game.rs</code> with the following:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct SpaceRecyclerGame {
    // Your state here...
}

impl SpaceRecyclerGame {
    pub fn new(_ctx: &amp;mut Context) -&gt; SpaceRecyclerGame {
        // Load/create resources such as images here.
        MyGame {
            // ...
        }
    }
}

impl EventHandler for SpaceRecyclerGame {
    fn update(&amp;mut self, _ctx: &amp;mut Context) -&gt; GameResult&lt;()&gt; {
        // Update code here...
        Ok(())
    }

    fn draw(&amp;mut self, ctx: &amp;mut Context) -&gt; GameResult&lt;()&gt; {
        graphics::clear(ctx, Color::BLACK);
        // Draw code here...
        graphics::present(ctx)
    }
}
<span class="boring">}
</span></code></pre></pre>
<!-- TODO: test this and rename for a system that routes for menu + game -->
<p>If we execute <code>cargo run</code> now, that should present us with a black screen.</p>
<p>The compilation time now it should be quite fast.</p>
<p>There’s a lot here. Let’s dissect step by step.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="level-master-1"><a class="header" href="#level-master-1">Level: Master</a></h1>
<p>Well, well… here we are.</p>
<p>Look what you’ve done so far. Those programs look quite like the real deal!</p>
<p>Yet, the journey continues. Now it’s time to get in-depth to what coding is.</p>
<p>With this part, you should be ready to get a job in programming or contribute
in the Rust community.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="borrowing"><a class="header" href="#borrowing">Borrowing</a></h1>
<p>This is most probably the most difficult concept in Rust. Borrowing is very 
specific to Rust only, and it’s the main reason so many people abandon learning 
Rust. And also it is why so many people say Rust is difficult.</p>
<p>Learning this is what sets apart developers from Rust Developers.</p>
<p>Are you ready?</p>
<ul>
<li>When you see things like <code>x</code>, <code>y</code>, <code>f64</code>, etc. It means that you own the 
variable, meaning that you can do whatever: read, write and free their memory.</li>
<li>If you see <code>&amp;x</code>, <code>&amp;y</code>, <code>&amp;f64</code>, etc. Means that you don’t own it, it was lent
to you temporarily. You can only read their contents, but most of the time you
can also copy the contents elsewhere too.</li>
<li>Finally, if you see <code>&amp;mut x</code>, <code>&amp;mut y</code>, <code>&amp;mut f64</code>, etc. Is as before, but
you can also write to them. With these you can do mostly everything except
free their memory.</li>
</ul>
<p>That’s it. <code>&amp;</code> is read-only access, <code>&amp;mut</code> is read and write access, and if 
nothing appears, it’s full access.</p>
<p>Wait, you thought this was going to be more difficult? I wonder why.</p>
<p>Ok, jokes aside, now comes the difficult part.</p>
<p>Rust will ensure the correctness of our programs in a way that feels “too much”,
it will analyze and prove correctness to a level that no other language that I
know does.</p>
<p>This makes the Rust compiler very picky. There’s lots of stuff that it doesn’t
like. And it’s hard to make the compiler happy.</p>
<p>Maybe you experienced this already. Or maybe I did a good job up to now keeping
you away from this. Now it’s time to start introducing (very gently) to 
Ownership and Borrowing in Rust.</p>
<p>When we store a value into a variable, it uses some amount of memory 
of the computer. It seems kinda obvious that 100 numbers will use more memory
than 5 numbers.</p>
<p>And memory needs to be freed. Because if we keep asking for memory and never
returning it, our computer might run out of memory at some point.</p>
<p>Therefore, Rust must allocate (ask for memory) when we put a new variable, and
it must free the memory when it’s no longer needed.</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn some_function() {
    let x: i64 = 12345; // &lt;-- memory gets allocated here.
    println!(&quot;using the variable: {}&quot;, x);
} // &lt;-- memory gets freed here, when the function ends.

fn main() {
    some_function();
}
</code></pre></pre>
<p>Now, this is the basic of what Ownership means: when we create something, we 
own it, and we’re responsible for freeing it when we’re done with it.</p>
<p>Rust does this for us in a very natural way. So much that we could ignore
this up to this point.</p>
<p>The problem with this approach is that, when we pass a variable to a function,
the function now owns that variable. And this means that the function will
free this variable when it ends, we could not use it anymore.</p>
<p>Sounds weird, but it will seem clear here:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn print(x: i64) { // &lt;-- x ownership is captured when calling the function.
    println!(&quot;Value is: {}&quot;, x);
} // &lt;-- memory gets freed here, when the function ends.

fn some_function() {
    let x: i64 = 12345; // &lt;-- memory gets allocated here.
    print(x); // &lt;-- we call the function, but 'x' is now owned by 'print'.
    println!(&quot;using the variable: {}&quot;, x); // &lt;-- 'x' no longer exists!!
}

fn main() {
    some_function();
}
</code></pre></pre>
<p>But —I hear you asking—, if I run the above code it works.</p>
<p>Yeah, I know. But this one does not:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn print(x: String) { // &lt;-- x ownership is captured when calling the function.
    println!(&quot;Value is: {}&quot;, x);
} // &lt;-- memory gets freed here, when the function ends.

fn some_function() {
    let x: String = &quot;text&quot;.to_string(); // &lt;-- memory gets allocated here.
    print(x); // &lt;-- we call the function, but 'x' is now owned by 'print'.
    println!(&quot;using the variable: {}&quot;, x); // &lt;-- 'x' no longer exists!!
}

fn main() {
    some_function();
}
</code></pre></pre>
<p>Some data types are so simple that Rust can just copy them around. But text
in the other hand, is a bit more complicated and that trick no longer works<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<p>Now, to make this work is pretty easy. Because <code>print()</code> is only reading, we
only need read-only access. We can use the ampersand to borrow temporarily
the variable:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn print(x: &amp;String) { // &lt;-- we only get a &quot;reference&quot; to 'x'. We don't own it.
    println!(&quot;Value is: {}&quot;, x);
} 

fn some_function() {
    let x: String = &quot;text&quot;.to_string(); // &lt;-- memory gets allocated here.
    print(&amp;x); // &lt;-- now we only lent 'x'. We keep ownership.
    println!(&quot;using the variable: {}&quot;, x); // &lt;-- 'x' does exist here and works.
} // &lt;-- 'x' memory gets freed here.

fn main() {
    some_function();
}
</code></pre></pre>
<p>As you can see, I only added two <code>&amp;</code> in the code, and we don’t have the 
problem anymore.</p>
<p>Now we also have <code>&amp;mut</code>, and this one is fascinating. It allows us to
do this:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn add_five(x: &amp;mut i64) { 
    x += 5
} 

fn some_function() {
    let x: i64 = 100; 
    println!(&quot;x = {}&quot;, x); 
    add_five(&amp;mut x); 
    println!(&quot;x = {}&quot;, x); 
    add_five(&amp;mut x); 
    println!(&quot;x = {}&quot;, x); 
}

fn main() {
    some_function();
}
</code></pre></pre>
<p>Because <code>add_five</code> receives a mutable reference, when we change it, we will see
the changes appear on <code>some_function</code>.</p>
<p>I think you can see this is super useful, and our functions got now superpowers!</p>
<p>Let’s step this up a little.</p>
<p>Turns out you can also store references like <code>&amp;x</code> or <code>&amp;mut x</code>. And for what 
reason do we want to do this? Well… it’s too early to explain. Let’s just say
that it is possible, and you don’t want to do this.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 5;
let y = &amp;mut x;
*y = 3;
println!(&quot;x = {}&quot;, x);
<span class="boring">}
</span></code></pre></pre>
<p>Also in structs:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Thingy {
    x: &amp;mut i64,
    y: &amp;f64,
}
<span class="boring">}
</span></code></pre></pre>
<p>But this must be written as:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Thingy&lt;'a&gt; {
    x: &amp;'a mut i64,
    y: &amp;'a f64,
}
<span class="boring">}
</span></code></pre></pre>
<p>The point is: it is possible. And I need you to know that this can be done to 
understand the next explanation.</p>
<p>But at your current level, if you see yourself coding something like that, 
simply back off and find a way to avoid storing references <code>&amp;var</code> <code>&amp;mut var</code>. 
They’re very painful to work with.</p>
<p>Now, this means that there may exist several pieces of code that have access
to the same variable at the same time via different methods.</p>
<p>And this is a problem.</p>
<p>If one part of a program is using a variable and another part, inadvertently is
changing the variable… well, it can end very badly.</p>
<p>For this reason, Rust limits how ownership and references can coexist, and how 
many we can have.</p>
<ul>
<li>Ownership (<code>var</code>): There can be only one owner at a time. When we call a function, we 
transfer the ownership of the variables unless they are references <code>&amp;x</code> <code>&amp;mut x</code>.</li>
<li>Mutable reference (<code>&amp;mut var</code>): There must be at most one <code>&amp;mut var</code> at any time.
And while it exists, the original variable cannot be read or written (more or less).</li>
<li>Shared reference (<code>&amp;var</code>): There can be many, but they cannot coexist with <code>&amp;mut var</code>.</li>
</ul>
<p>In other words, there must be always one owner, and one writer. Readers can be 
many, as long as there aren’t anyone writing.</p>
<p>The ownership system in Rust can be related with having a car:</p>
<ul>
<li><code>var</code>: You own a car, therefore you can choose to dispose of it at any time.</li>
<li><code>&amp;mut var</code>: You send the car to a mechanic, they can do changes to your car, 
but you cannot use it meanwhile. And you cannot dispose of it while is on 
the mechanic.</li>
<li><code>&amp;var</code>: You let others see your parked car, but not touch it. Many can see 
your car at the same time, but meanwhile you cannot use it or send it to the
mechanic.</li>
</ul>
<p>Which roughly translates into:</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Car {
    horses: i64,
    air_conditioner: bool,
}

fn buy_cheap_car() -&gt; Car {
    return Car{horses: 60, air_conditioner: false};
}

impl Car {
    // &quot;self&quot; here transfers ownership. And this function will free the variable.
    fn dispose(self) {
        println!(&quot;Bye car! {} horses, A/C:{}&quot;, self.horses, self.air_conditioner);
    }
    // &quot;&amp;mut self&quot; gives exclusive write access.
    fn upgrade_ac(&amp;mut self) {
        self.air_conditioner = true;
    }
    fn upgrade_engine(&amp;mut self) {
        self.horses += 10;
    }
    // &quot;&amp;self&quot; gives shared read access.
    fn admire(&amp;self) {
        println!(
            &quot;Woo, nice car with {} horses and {} A/C&quot;, 
            self.horses, 
            self.air_conditioner
            );
    }
}

fn main() {
    let mut mycar = buy_cheap_car();
    let admirer1 = &amp;mycar;
    admirer1.admire();
    
    let mechanic = &amp;mut mycar;
    mechanic.upgrade_ac();

    let admirer1 = &amp;mycar;
    let admirer2 = &amp;mycar;
    // mechanic can't be used here.
    admirer1.admire();
    admirer2.admire();

    let mechanic = &amp;mut mycar;
    mechanic.upgrade_engine();

    let admirer1 = &amp;mycar;
    let admirer2 = &amp;mycar;
    admirer1.admire();
    admirer2.admire();

    mycar.dispose();
    // Car no longer exists, this won't work:
    // let admirer1 = &amp;mycar;
    // admirer1.admire();
}
</code></pre></pre>
<p>I know that at this point this will feel confusing. It’s a lot to unpack.</p>
<p>And I guess you have questions like:</p>
<ul>
<li>Why should I use this?</li>
<li>Seems complicated.</li>
<li>Why not use <code>&amp;mut</code> all the time? Or just the regular <code>var</code>.</li>
<li>Is this to put restrictions on the code?</li>
</ul>
<p>No, no… forget about all those thoughts. </p>
<p>It’s not something we want to use, it’s something that we will need to use.
Meaning, that the usage will be apparent soon enough. Don’t overthink it.</p>
<p>We’re trying to solve a problem here. The problem is sharing variables across
many pieces of code.</p>
<p>Before, we were doing lots of things like:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let p: Point2D;
// (...)
p = p.move(distance_vector);
<span class="boring">}
</span></code></pre></pre>
<p>But this is inconvenient. And we would like to just write:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let p: Point2D;
// (...)
p.move(distance_vector);
<span class="boring">}
</span></code></pre></pre>
<p>And that should update the point. </p>
<p>For that, we want to use <code>&amp;mut self</code> instead. So, we had:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Point2D {
    fn move(mut p: Self, v: Vector2D) { 
        p.x += v.dx;
        p.y += v.dy;
        return p;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>With what we learned, we can do:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Point2D {
    fn move(&amp;mut self, v: Vector2D) { 
        self.x += v.dx;
        self.y += v.dy;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>And now that updates the point. Nice.</p>
<p>Still one problem. If we do:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut p1 = Point2D{x: 10.0, y: -5.0};
let mut p2 = Point2D{x: 5.0, y: 15.0};
let distance_vector = Vector2D{dx: 50.0, dy:0.0};
// (...)
p1.move(distance_vector);
p2.move(distance_vector);
<span class="boring">}
</span></code></pre></pre>
<p>The second move, for <code>p2</code> won’t work. The problem is that <code>move</code> is taking
ownership of <code>distance_vector</code>, so we lose the variable.</p>
<p>But we don’t need ownership just for reading the contents, do we?</p>
<p>So let’s update that:</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Point2D {
    x: f64,
    y: f64,
}

struct Vector2D {
    dx: f64,
    dy: f64,
}

impl Point2D {
    // Added ampersand         v---- here
    fn translate(&amp;mut self, v: &amp;Vector2D) { 
        self.x += v.dx;
        self.y += v.dy;
    }
}

fn main() {
    let mut p1 = Point2D{x: 10.0, y: -5.0};
    let mut p2 = Point2D{x: 5.0, y: 15.0};
    let distance_vector = Vector2D{dx: 50.0, dy:0.0};
    // Added ampersand
    //           v---- here
    p1.translate(&amp;distance_vector);
    p2.translate(&amp;distance_vector);
}
</code></pre></pre>
<p>With just that single <code>&amp;</code> character, now it works.</p>
<p>I’ll leave this here. Take it as an introduction into borrowing and ownership. 
Later on we will revisit this topic a bit more in-depth. So if it’s not fully
clear, don’t worry!</p>
<p>Also, we’re reaching a point where you can already read (and probably write) 
what could be production-ready Rust code. This is (almost) what real code looks
like. You’re getting close to be able to start your own applications!</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>If you ever asked yourself why all code samples and exercises I wrote 
almost always had number variables, this is the reason. They’re easier to work 
with and avoids these problems.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="level-grand-master-1"><a class="header" href="#level-grand-master-1">Level: Grand Master</a></h1>
<p>Last steps! This section is what makes a programmer a great one!</p>
<p>Will go through the most complex parts of coding and see
more challenging programs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-a-garbage-collector"><a class="header" href="#what-is-a-garbage-collector">What is a Garbage Collector?</a></h1>
<p>It’s something that Rust doesn’t have. Have a good day!</p>
<p>Garbage Collector is about memory allocation. In C &amp; C++ memory needs to be 
manually requested and freed. Because this is very dangerous, most other 
languages automatically allocate and free.</p>
<p>Allocating is “easy”, as the first use is allocating. But automatic free is hard, 
because you need to ensure that no parts of the program can access that variable anymore.</p>
<p>So a Garbage Collector is a system that can track when variables go out of scope 
(unreachable) in order to free the memory. There are lots of types of GCs 
(each language might use a different approach), but they tend to have 
performance penalties, memory over-consumption and may temporarily halt all 
threads of the program to do the free.</p>
<ul>
<li>In Python, the GC prevents Python from running several threads of python 
code in parallel. So most python code, even if it uses threads, 
effectively is single-threaded because of the GC.</li>
<li>In Java, the GC tends to free memory very late, causing bloat, 
a lot of memory consumption.</li>
<li>In Go, the GC causes micro-pauses. All threads suddenly stop for 
a few milliseconds to clean up.</li>
<li>In Rust, there’s no GC. Instead, the automatic free is computed at compile 
time (by static analysis). So no bloat, no performance penalty.</li>
<li>C &amp; C++, there’s no GC, you do it manually, and a mistake causes memory 
corruption and segfaults.</li>
</ul>
<p>Rust is kind of a compiler assisted C++. Automatic like Python, but if the 
compiler cannot prove your program is correct (even if the program in 
fact <strong>IS</strong> correct), it will reject it and won’t compile. </p>
<p>So the drawback from Rust approach is the added difficulty of learning 
Ownership &amp; Borrowing (which I talk about in my blog post)
….</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="level-legendary-1"><a class="header" href="#level-legendary-1">Level: Legendary</a></h1>
<p>Wait, do you want more?</p>
<p>Maybe you already surpassed the teacher.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendices"><a class="header" href="#appendices">Appendices</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-a-license-of-this-book"><a class="header" href="#appendix-a-license-of-this-book">Appendix A. License of this book</a></h1>
<p>This text is licensed under the Creative Commons license 
“Attribution 4.0 International (CC BY 4.0)” which can be read here:</p>
<p><a href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</a></p>
<p><a href="https://creativecommons.org/licenses/by/4.0/legalcode">https://creativecommons.org/licenses/by/4.0/legalcode</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-b-caveats-and-challenges-in-this-book"><a class="header" href="#appendix-b-caveats-and-challenges-in-this-book">Appendix B. Caveats and challenges in this book</a></h1>
<p>This book is intended to people with no previous experience in coding at all 
and attempts to teach programming in a very approachable way.</p>
<p>Because of this, a lot of information is hidden, misrepresented, or 
factually incorrect. It is needed to hide and oversimplify stuff, so new 
learners don’t get overloaded with information. This also helps the reader 
to create their own programs very early on without needing 
to have a proper understanding, which can come in later on.</p>
<p>Other books might put a lot of theory in front to give a good understanding 
of what is coming next, but theory is indeed boring until it’s put into use. 
In this book I try to push down the theory as far as possible.</p>
<p>If this approach is good or bad it’s certainly subjective. But as everyone else 
goes for a more academic way, and there is almost no one that does something 
like I do in this book, I think it’s good to add more choices for learning.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-c-exercises-and-solutions"><a class="header" href="#appendix-c-exercises-and-solutions">Appendix C. Exercises and Solutions</a></h1>
<!-- TODO: There should be some exercises for the reader and put the solutions here. 
Ideally, place the solutions in random order to avoid the reader from 
inadvertently reading the next solution to their problem.  -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-d-proposed-projects"><a class="header" href="#appendix-d-proposed-projects">Appendix D. Proposed projects</a></h1>
<p>Some ideas to build as a beginner!</p>
<ul>
<li>Unit convertor - changes cm to m, yards to miles, °C to °F, etc.</li>
<li>Expense tracker / Lending tracker (see how much you owe to your friends and settle)</li>
<li>Horizontal Shooter game (maybe about cleaning space and recycling)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-e-rust-compared-to-other-languages"><a class="header" href="#appendix-e-rust-compared-to-other-languages">Appendix E. Rust compared to other languages</a></h1>
<ul>
<li>
<p>Rust has structs and impl.</p>
<ul>
<li>C++, Java, Python, JavaScript have classes.</li>
<li>C doesn’t have classes, but it has structs.
<ul>
<li>However, no function methods can be placed.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Rust has generics</p>
<ul>
<li>C++ and Java have it too.</li>
<li>C and Python do not.
<ul>
<li>Python doesn’t need it.</li>
</ul>
</li>
<li>Go is adding them.</li>
</ul>
</li>
<li>
<p>Rust has traits</p>
<ul>
<li>Java and Go have interfaces.</li>
</ul>
</li>
</ul>
<h2 id="features-unique-to-rust"><a class="header" href="#features-unique-to-rust">Features unique to Rust</a></h2>
<ul>
<li>
<p>The fact that by default variables are not mutable. In other languages you
have to specify “const” to get the opposite effect.</p>
</li>
<li>
<p>Move by default instead of Copy.</p>
</li>
<li>
<p>Ownership and Borrowing.</p>
</li>
<li>
<p>No Garbage Collector and no manual memory management (At the same time)</p>
<ul>
<li>C/C++ have no GC, but manual memory allocation.</li>
<li>Almost every other language has a GC.</li>
</ul>
</li>
</ul>

                </main>

                <nav class="nav-wrapper" aria-label="Page navigation">
                    <!-- Mobile navigation buttons -->


                    <div style="clear: both"></div>
                </nav>
            </div>
        </div>

        <nav class="nav-wide-wrapper" aria-label="Page navigation">

        </nav>

    </div>

    <!-- Livereload script (if served using the cli tool) -->
    <script type="text/javascript">
        const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
        const socket = new WebSocket(wsAddress);
        socket.onmessage = function (event) {
            if (event.data === "reload") {
                socket.close();
                location.reload();
            }
        };

        window.onbeforeunload = function () {
            socket.close();
        }
    </script>



    <script type="text/javascript">
        window.playground_copyable = true;
    </script>


    <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

    <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
    <script src="book.js" type="text/javascript" charset="utf-8"></script>

    <!-- Custom JS scripts -->

    <script type="text/javascript">
        window.addEventListener('load', function () {
            MathJax.Hub.Register.StartupHook('End', function () {
                window.setTimeout(window.print, 100);
            });
        });
    </script>

</body>

</html>