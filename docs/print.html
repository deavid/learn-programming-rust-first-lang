<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Learn programming with Rust as a first language</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded "><a href="001A_first_language.html"><strong aria-hidden="true">1.</strong> Your first programming language</a></li><li class="chapter-item expanded "><a href="002A_books.html"><strong aria-hidden="true">2.</strong> Related books</a></li><li class="chapter-item expanded "><a href="003A_setup.html"><strong aria-hidden="true">3.</strong> Setting up the computer</a></li><li class="chapter-item expanded "><a href="004A_first_program.html"><strong aria-hidden="true">4.</strong> Your first program</a></li><li class="chapter-item expanded "><a href="005A_to_the_IDE.html"><strong aria-hidden="true">5.</strong> Quick, to the IDE!</a></li><li class="chapter-item expanded "><a href="006A_recipes.html"><strong aria-hidden="true">6.</strong> It's like cooking recipes, seriously</a></li><li class="chapter-item expanded "><a href="007A_little_boxes.html"><strong aria-hidden="true">7.</strong> Variables are like little boxes that store things inside</a></li><li class="chapter-item expanded "><a href="008A_declaring.html"><strong aria-hidden="true">8.</strong> Declaring variables</a></li><li class="chapter-item expanded "><a href="009A_incrementing.html"><strong aria-hidden="true">9.</strong> Incrementing and decrementing</a></li><li class="chapter-item expanded "><a href="010A_looping.html"><strong aria-hidden="true">10.</strong> Looping' around</a></li><li class="chapter-item expanded "><a href="011A_comments.html"><strong aria-hidden="true">11.</strong> Adding some comments</a></li><li class="chapter-item expanded "><a href="012A_ifs.html"><strong aria-hidden="true">12.</strong> What If...?</a></li><li class="chapter-item expanded "><a href="013A_loops_again.html"><strong aria-hidden="true">13.</strong> For loops again!</a></li><li class="chapter-item expanded "><a href="014A_functions.html"><strong aria-hidden="true">14.</strong> Introducing Functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="014B_func_return.html"><strong aria-hidden="true">14.1.</strong> Returning values from functions</a></li><li class="chapter-item expanded "><a href="014C_func_args.html"><strong aria-hidden="true">14.2.</strong> Function arguments</a></li></ol></li><li class="chapter-item expanded "><a href="015A_data_types.html"><strong aria-hidden="true">15.</strong> Data types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="015B_rust_types.html"><strong aria-hidden="true">15.1.</strong> Rust data types</a></li></ol></li><li class="chapter-item expanded "><a href="016A_typedvars.html"><strong aria-hidden="true">16.</strong> Back to declaring variables... with type</a></li><li class="chapter-item expanded "><a href="017A_conversions.html"><strong aria-hidden="true">17.</strong> Converting types with explicit conversions</a></li><li class="chapter-item expanded "><a href="018A_strings_intro.html"><strong aria-hidden="true">18.</strong> A tiny bit on strings</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="018B_strings_and_str.html"><strong aria-hidden="true">18.1.</strong> Simple explanation on &str vs String</a></li></ol></li><li class="chapter-item expanded "><a href="019A_fun_with_libs.html"><strong aria-hidden="true">19.</strong> Having fun with libraries</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="X01A_TODO.html"><strong aria-hidden="true">20.</strong> To-do: pieces that need more work</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="X02A_datatypes.html"><strong aria-hidden="true">20.1.</strong> What are those other data types for?</a></li><li class="chapter-item expanded "><a href="X03A_funcs_revisited.html"><strong aria-hidden="true">20.2.</strong> A bit more detailed explanation on functions</a></li><li class="chapter-item expanded "><a href="X04A_garbage_collector.html"><strong aria-hidden="true">20.3.</strong> What is a Garbage Collector?</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="Y01A_Appendices.html"><strong aria-hidden="true">21.</strong> Appendices</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Y02A_license.html"><strong aria-hidden="true">21.1.</strong> Appendix A. License of this book</a></li><li class="chapter-item expanded "><a href="Y03A_caveats.html"><strong aria-hidden="true">21.2.</strong> Appendix B. Caveats and challenges in this book</a></li><li class="chapter-item expanded "><a href="Y04A_solutions.html"><strong aria-hidden="true">21.3.</strong> Appendix C. Exercises and Solutions</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Learn programming with Rust as a first language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="learn-programming-with-rust-as-first-language"><a class="header" href="#learn-programming-with-rust-as-first-language">Learn programming with Rust as first language</a></h1>
<ul>
<li>Source for this book: <a href="https://github.com/deavid/lprfl">https://github.com/deavid/lprfl</a></li>
<li>Author: David Martínez Martí</li>
<li>Blog: <a href="https://deavid.wordpress.com/">https://deavid.wordpress.com/</a></li>
</ul>
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Coding can be a daunting task to any beginner. In fact even at seniority levels, it still is for advanced concepts. As you get on your journey of learning how to code you’ll begin to find previous hard tasks as easy, and at some point they will become so obvious that it gets hard to imagine how other people don’t understand them. But regardless, there will always be daunting tasks waiting for you. Programming is not about the destination, it is about the journey itself.</p>
<p>It’s not something that you learn and you’re done. There’s almost an infinite amount of stuff that can be learned and used, as you gain more expertise, you’ll be able to specialize on certain types of programs and make them go the extra mile, which feels very satisfying. This field also keeps constantly evolving, so much that in 10 years the job requirements change drastically and it might be difficult to find a job if we don’t keep learning.</p>
<p>If you enjoy learning and trying to do new stuff day by day, then this is for you. It will get easier over time, I promise!</p>
<p>From zero knowledge on programming to being able to apply to any job and hope to succeed, it takes at least 6 months with full day dedication (8 hours a day) if you’re a good learner.</p>
<p>To get rid of the “junior” title, another 2-3 years are needed in a job usually. And (real) seniors have at least 8 years of experience. From there, the differences between someone with 8 or 20 years of experience tend to be very dim; it depends more on the people themselves than the experience.</p>
<p>The good news is that with enough dedication you can get yourself employed in record time, which for other careers requires proper study at a university, which takes several years.
And you’ll be able to grow easily on the job. Getting employed is not the destination, but maybe a new beginning. There’s always a huge demand on good developers, so if you prove yourself good, even if the company doesn’t allow you to grow, there will be several companies wanting your talent and will raise the offer accordingly.</p>
<p>So, before taking this journey ask yourself: Is this the path I want to take?
If the answer is yes, then do it! commit and push forward to get it.</p>
<blockquote>
<p>NOTE: I love oversimplifying a lot!. And I will lie in order to make things look simpler and create simple rules that don’t always work. This is done on purpose to make the experience easy to follow and add concepts slowly. I will correct these and get into specifics slowly as I feel the reader got enough knowledge to understand the whole thing. </p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="your-first-programming-language"><a class="header" href="#your-first-programming-language">Your first programming language</a></h1>
<p>This is a common question everyone asks themselves. 
In my opinion, Python and Rust are the two best languages to start with. 
While Python will give you an easier time to begin, and plenty of jobs that
actually exist, Rust is going to be a bit harder to begin with, with way less jobs.</p>
<p>As the title suggests, I’m going to recommend Rust. Why? Lots of reasons. 
I believe Rust will be the language of the future, so by the time you learn it 
hopefully there will be jobs waiting for you.</p>
<p>Rust also will teach you proper coding practices. As it is stricter, it will 
force you into the right shape and mindset for a programmer, and not someone who 
stitches things together that delivers delicate programs that break in strange 
ways just by looking at them.</p>
<p>The Rust community is very friendly. You’ll have a lot of people wanting to 
teach you the language and help you along on this. Python is a bit of 
hit-and-miss, some communities might be toxic.</p>
<p>The documentation is solid, nicely written, and very easy to follow. 
The reference docs might be a bit complex to understand at first, but 
after the first month or two it becomes very practical.</p>
<p>Rust has potential to be used for anything. Web, games, embedded devices, 
operating systems, browsers, you name it. There are still several gaps 
at the moment of this writing due to the nature of Rust being so new; over time 
more libraries will be created and mature, so right now there are several 
types of applications where Rust might not be fit. For now.</p>
<p>Python is very powerful and is able to do most of the applications that you 
might want to do, and it is very quick to write and get results with it. But it 
has several downsides (one is performance) that are very unlikely to disappear 
in the next 10 or 20 years<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<p>In the end, it doesn’t matter that much which language you start with. As long 
as you can learn to code, the language isn’t that important. All languages have 
lots of similarities, so much that when you learn the second one it will take 
99% less time than the first.</p>
<p>And you can’t count on learning a single language (i.e. Rust) and hope that this 
would be all. There are always languages that are very good at one thing, and 
you should learn those too. Because you don’t want to spend a week doing 
something in Rust that takes 1 line of Bash to do, if there’s no real reason or 
benefit<sup class="footnote-reference"><a href="#2">2</a></sup> for it.</p>
<p>So, no worries, you’ll be fine. You’ll learn other languages over the course of 
years and that will take less and less time as you go.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>As usual, there are several companies trying to make Python faster. Some
efforts are going through “compiling” typed python code with great speedups. 
There’s also PyPy. But the community at this point does not want a “typed Python”
so I don’t see the performance being fixed in the near future.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>I’ve seen someone write a full Java application for several days, trying
to make it as fast as possible, and someone else came up with a Bash one liner
with pipes that did the same thing 2x faster, and they basically spent 5 minutes
writing the line. Use the best tool for each job. You should learn more than one 
programming language.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="related-books"><a class="header" href="#related-books">Related books</a></h1>
<h2 id="the-holy-rust-book"><a class="header" href="#the-holy-rust-book">The holy Rust book</a></h2>
<p>You must know that there exists a book called just “The Rust book” or “the book”. </p>
<p>I will (jokingly &amp; friendly) call it here “The holy rust book”. </p>
<p>You can check it here:
<a href="https://doc.rust-lang.org/stable/book/">https://doc.rust-lang.org/stable/book/</a></p>
<p>The holy book is the main learning resource for Rust. 
It is the true starting point for learning the language and contains 
everything, from beginner to truly advanced. 
It covers the entire language (except the uses of Unsafe, that are covered in 
the Necronomicon… I mean, the Rustonomicon)</p>
<p>This guide is not meant to replace the holy book itself, as it is very well 
written by experts and reviewed by the whole community. </p>
<p>If that’s the case, what’s the point of this then? Well, the holy book assumes 
some knowledge. It will rapidly grow in difficulty and will require several 
reads for beginners and look in other places as well to fully grasp the concepts.</p>
<p>Only a small part of the language will be covered here; enough to get you started, 
and at a slow pace enough to follow without external resources (hopefully). 
From time to time I’ll link to the holy book, so you can go there to read if you 
like, as there’s more detail.</p>
<p>I call it “holy” because it’s the Rust Bible (in fact some people call it that). 
If the holy book disagrees with me, the book is right, I’m wrong. 
Whatever it says, it is right. 
A lot of people call Rust a cult (seriously) so I pretend to extend and embrace 
the term to make it a funny joke.</p>
<h2 id="other-rust-books"><a class="header" href="#other-rust-books">Other Rust books</a></h2>
<p>See <a href="https://github.com/sger/RustBooks">https://github.com/sger/RustBooks</a></p>
<ul>
<li>Rust by Example</li>
<li>Easy Rust</li>
<li>A Gentle Introduction to Rust</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-the-computer"><a class="header" href="#setting-up-the-computer">Setting up the computer</a></h1>
<p>So you reached this point! I guess we’re doing it. Let’s stop the chatter and bring in the real stuff. Let’s install Rust.</p>
<h2 id="installing-rust"><a class="header" href="#installing-rust">Installing Rust</a></h2>
<p>Get your browser and go to <a href="https://rustup.rs/">https://rustup.rs/</a>. Follow the instructions there.</p>
<ul>
<li>For Windows, there’s a <code>rust-init.exe</code> that you download and will install everything.</li>
<li>For Linux (my case), there’s a single command line that you copy and paste into the console.</li>
</ul>
<!--- And this is a security risk that some people don't want to take. Add an alternative option. -->
<p>(By the way, if you want to be a developer, you also need to make the terminal your friend)</p>
<p>That will be all we need to do. Congrats! You installed Rust in your machine!</p>
<blockquote>
<p><code>Chapter 1.1 - Installation</code> of the Holy Book contains the installation instructions.</p>
</blockquote>
<h2 id="choosing-an-editor-for-rust"><a class="header" href="#choosing-an-editor-for-rust">Choosing an editor for Rust</a></h2>
<p>I’m very opinionated here. Get Visual Studio Code. 
(not to be confused with MS Visual Studio)</p>
<!--- Add the de-Microsoftified Port of VS Code to your Guide: https://vscodium.com/ -->
<p>People call it VS Code or just “Code”. 
It’s open source, supports nearly all languages, and works really, really well.</p>
<p>From those that code with Rust, they mainly use VS Code or Vim. 
And I’m not going to recommend Vim to anyone. 
It is an excellent program, but geared towards very senior people. 
So VS Code it is.</p>
<p>I have more than 15 years coding, and I do use VS Code. It’s great. 
On the other hand, I almost never use Vim: 
it requires a lot of investment that I don’t want to commit to.</p>
<p>Now, go to the extensions panel and search for “rust-analyzer” and install it. 
This is all you need to get the best Rust experience.</p>
<p><img src="./img/vscode_extensions.png" alt="VSCode Extensions" /></p>
<p>(It is really important to have Rust properly installed at this point, or rust-analyzer will fail)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="your-first-program"><a class="header" href="#your-first-program">Your first program</a></h1>
<p>Before doing anything, it is important to have a folder where you put all your programs. 
So go ahead and create a folder with the name you like (i.e. “programs”)<sup class="footnote-reference"><a href="#1">1</a></sup>.
<sup class="footnote-reference"><a href="#1">1</a></sup>: Personally I use <a href="https://git-scm.com/">Git</a> for everything, and I have 
the folders structured as <code>/home/deavid/git/rust/project_name</code>.</p>
<p>A few tips though:</p>
<ul>
<li>
<p>Prefer to use lowercase only for the folder, no spaces. 
Use an underscore if you need to separate words, but I would 
recommend writing something short.</p>
</li>
<li>
<p>Place the folder somewhere that has a short, easy path. Don’t place it on your 
Desktop. On Windows, “C:&quot; might be better as the home folder contains a path with spaces.</p>
</li>
</ul>
<p>Now open a terminal and go to this folder. 
Using <code>cd ..</code> and <code>cd your_folder_name</code> should do the trick. 
If you followed my tips, this should be an easy task.</p>
<p>Once you’re set, run the following command:</p>
<pre><code class="language-console">$ cargo new learnrust
</code></pre>
<p>This will create a folder called <code>learnrust</code>, you should be able to find it with 
your file explorer. 
Inside, there are a few folders and files. 
This is how an empty Rust program looks.</p>
<!-- Screenshot of the file manager? -->
<p>It already includes a program in src called <code>main.rs</code> (we’ll check out the contents later). 
And it can be executed. </p>
<p>Do <code>cd learnrust</code> on the console to get into the folder, then run:</p>
<pre><code class="language-console">$ cargo run
</code></pre>
<p>The output will be similar to this:</p>
<pre><code class="language-console">$ cargo run
Compiling learnrust v0.1.0 (/home/deavid/git/rust/learnrust)
Finished dev [unoptimized + debuginfo] target(s) in 0.34s
  Running `target/debug/learnrust`
Hello, world!
</code></pre>
<p>The program has been built and executed. The program output is “Hello, world!”.</p>
<p>Congrats! You just wrote your first program. (more or less, hah)</p>
<p>If you execute “cargo run” again, then:</p>
<pre><code class="language-console">    $ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
     Running `target/debug/learnrust`
    Hello, world!
</code></pre>
<p>Notice how something is different. 
At first, it compiled the program, then executed it. 
On the second time, it noticed that the program was unchanged, so 
it was run without compiling it again.</p>
<p>This is covered in <code>Chapter 1.2 - Hello World!</code> of the holy book.</p>
<h2 id="what-is-this-cargo-command"><a class="header" href="#what-is-this-cargo-command">What is this cargo command?</a></h2>
<p>Surely you noticed that we did “cargo run” and not “rust run”. 
Cargo is like the swiss-army knife of Rust, it will simplify all our processes 
during coding, and removes a lot of stuff that we don’t need to learn.</p>
<p>Main things that it does:</p>
<ul>
<li>Instead of compiling the program with <code>rustc</code>, it’s just <code>cargo build</code>. 
<code>rustc</code> will need flags, and it’s a bit tricky to do right, cargo makes this super simple.</li>
<li>The programs are built in <code>./target/debug/</code> or <code>./target/release</code>. 
We could run these directly, but we would need to remember to build them first. 
<code>cargo run</code> does this for us.</li>
<li>We might need to download libraries for additional stuff 
(this is common in all programming languages), but instead of doing this manually, 
we can declare in <code>Cargo.toml</code> which ones do we want, and when 
we do <code>cargo build</code> it will download anything missing automatically.</li>
</ul>
<p>There’s much more than this, but for now this is what we will be using. 
The bottom line is that we will always use <code>cargo</code> and forget about the other commands. 
That’s fewer things to remember.</p>
<p>As a side note, if you installed with <code>rustup.rs</code> as I recommended, there’s 
also a <code>rustup</code> command. This is used to update rust and cargo themselves. 
If you need to update, just run <code>rustup update</code> and everything will be done 
automatically. 
It’s a good idea to do this once a month or so, but if you don’t do it is also fine.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-to-the-ide"><a class="header" href="#quick-to-the-ide">Quick, to the IDE!</a></h1>
<p>Let’s start using that nice VS Code that we installed earlier. </p>
<p>Open VS Code, look for the Menu <code>File</code> and click <code>Open Folder...</code>. </p>
<p><img src="./img/vscode_open_folder.png" alt="Open Folder" /></p>
<p>Select the <code>learnrust</code> folder that cargo created.</p>
<blockquote>
<p>NOTE: For myself, I find more convenient to open VSCode from the terminal.<br />
I simply <code>cd learnrust</code> and run <code>code .</code>. VSCode will open the folder.</p>
</blockquote>
<p>Now, open the src folder using the left panel, and you’ll see the <code>main.rs</code>. 
Double-click on it.</p>
<p>This is what you should see:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
   println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p><code>fn main()</code> represents the main program. </p>
<p>The brackets next to it (<code>{</code> and <code>}</code>) define where the program starts and ends. </p>
<p>Right now there’s only one line in the program: <code>println!(...)</code></p>
<p><code>println!(...)</code> is for printing text on the console/terminal.</p>
<p>The text between the parentheses is what will be printed. 
Notice that it’s surrounded by double quotes and these are 
not printed to the terminal. They’re required.</p>
<p>This line ends with a semicolon <code>;</code> this is what marks the end of the 
instruction (the command to run). 
Rust does not care about the different lines, or how they look in your editor. 
You can put all in one line and still will do the same thing. 
VSCode will format by default when you save, so it will always look nice and tidy.</p>
<!-- user might need to enable format on save; also other configs to tune would be helpful like auto save -->
<p>Open a new terminal inside VS Code. Go to <code>Terminal</code> ⇒ <code>New Terminal</code>:</p>
<p><img src="./img/vscode_new_terminal.png" alt="New Terminal" /></p>
<p>This opens a terminal on the project folder, so you can now type there 
<code>cargo run</code> to run the program inside this terminal panel.</p>
<p>As you can see we can do the same things as with an external terminal. 
As this is more convenient, we’ll use this from now on. There’s no difference to
an external one, so if you prefer to have a separate terminal program 
running, it’s totally fine.</p>
<p>You can try to print different texts or more lines. For example:</p>
<p><img src="./img/vscode_program_run.png" alt="Program run" /></p>
<p>This is not very useful, but it’s important to play around and get familiar 
with what we learn.</p>
<p>Programs are executed one line at a time. 
Rust will read the first line, execute the command, then go to the next line 
and do the same. 
Until it reaches the end of the program and then the program just ends.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="its-like-cooking-recipes-seriously"><a class="header" href="#its-like-cooking-recipes-seriously">It’s like cooking recipes, seriously</a></h1>
<p>You may not be into cooking, and that’s fine. 
But probably you know what a cooking recipe is: 
nothing more than a set of steps (instructions) that if followed 
produce the desired result: delicious food.</p>
<p>A program works in the same way. 
It has a set of instructions that should be followed step by step to produce 
the desired result. </p>
<p>There are stupid simple cooking recipes, for example to prepare frozen pizza:</p>
<ul>
<li>Preheat the oven to 180ºC for 10 minutes</li>
<li>Remove the pizza from the box and remove the film</li>
<li>Put the pizza into the oven, on top of a tray.</li>
<li>Wait 15 minutes.</li>
<li>Turn off the oven, remove the pizza and serve.</li>
</ul>
<p>And there are simple computer programs as well:</p>
<ul>
<li>Print one line on the console that says <code>Hello world!</code></li>
<li>end the program.</li>
</ul>
<p>But a common problem in cooking recipes is that they prepare a specific 
amount of food. If you want more or less, you have to tweak <em>“the program”</em> to 
roughly make more or less food to meet your requirements.</p>
<p>In programs, we have inputs (or arguments), where we can add a value and the 
program will take it into account for the calculation. In recipes, this is like 
having a number of “people to serve” and having some formula to scale up the 
ingredients to get the right amount of food.</p>
<p>We also have conditions, which work like those recipe 
steps that say “cook until brown”.</p>
<p>There are loops, which allow us to say “do this 10 times”.</p>
<p>There are functions, which in recipes appears when a meal is very complicated 
and for a particular step says “to do the base of the cake, refer to this other recipe”. 
It avoids repeating ourselves every time that a set of steps are reused across recipes.</p>
<p>Of course programs can do things really complicated that are quite far from recipes, 
but if you’re starting to learn, this comparison will serve you to get a 
better grasp on how this all works.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables-are-like-little-boxes-that-store-things-inside"><a class="header" href="#variables-are-like-little-boxes-that-store-things-inside">Variables are like little boxes that store things inside</a></h1>
<p>Printing some texts gets boring very fast. A computer does calculations 
for us, that’s what makes them useful. </p>
<p>It is possible to do simple calculations and print them, but this 
doesn’t have much mystery either:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> println!(&quot;{}&quot;, (2 * (1 + 5) + 3 / 7) / 2);
<span class="boring">}
</span></code></pre></pre>
<p>This will print 6, because it works with integers (whole numbers). 
Just like a regular calculator but without decimal points.</p>
<p>To get a decimal value just use all numbers as decimals, even if it’s <code>2.0</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;{}&quot;, (2.0 * (1.0 + 5.0) + 3.0 / 7.0) / 2.0);
<span class="boring">}
</span></code></pre></pre>
<p>This prints <code>6.214285714285714</code>, just like a calculator with probably more digits.</p>
<p>You’ll notice that Rust will error out if you mix numbers without decimals with 
numbers that do have decimals. We’ll go into more detail on this soon. 
For now, just remember that if you want decimal points, they need to be in all numbers.</p>
<p>Again, this gets boring very easily. We need to spice it up with… variables!</p>
<p>If you did math school before you probably remember equations. For example:</p>
<p>\[ 1+x = 2x+5 \]</p>
<p>These have an <em>unknown</em> that is \(x\) that must be resolved for. In this case it would be \(x=-4\).</p>
<blockquote>
<p>If you hate math and equations, do not worry. 
This is just to anchor into something you know. In coding we don’t do equations. 
Math is done by the computer itself.</p>
</blockquote>
<p>So do we agree that \(x\) is “something” whose value is \(-4\), right?</p>
<p>Ok, hold on to that idea. That is the same for variables. What is not the same is:</p>
<ul>
<li>We don’t have equations. We have instructions. Instructions do things like a command<!--- Program? Maybe someone has difficulty with the term command --> does something in the terminal.</li>
<li>We don’t have <em>unknowns</em>, and \(x\) in this example is an <em>unknown</em>. 
In programming, we have variables. An <em>unknown</em> is something that we don’t know (yet), while 
a <strong>variable</strong> is something that <strong>always has a value, and we know it</strong>.</li>
</ul>
<p>In Rust, we would do instead:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>x = -4;
<span class="boring">}
</span></code></pre></pre>
<p>Here <code>x</code> is the variable. It can be any name: <code>a</code>, <code>j</code> or even a word <code>animals</code>. 
Heck, even several words together: “number_of_legs_in_a_dog”. 
(If you’re a cat person, feel free to set “number_of_legs_in_a_cat” instead)</p>
<p>number_of_legs_in_a_cat = 4;</p>
<p>I did it for you. You can thank me later.</p>
<p>The equals part is an operation, it means “to store”. It actually saves the value on the right (number 4) into the name of the left.</p>
<p>(Variables should be named in snake_case, meaning they should be all lower case, contain only english characters and it should start by letter. Spaces are not valid<sup class="footnote-reference"><a href="#note">1</a></sup>)
<sup class="footnote-reference"><a href="#note">1</a></sup> Actually it’s more flexible than that, some emojis are also allowed; but for simplicity, let’s use only english alphabet.</p>
<p>So now we do have a name “x” or “number_of_legs_in_a_cat” whose value is 4.</p>
<p>The semicolon marks the end of the instruction. This serves to tell Rust that this line is something that needs to be executed, and to avoid confusion with the next line. If we forget the semicolon, it will think that two lines are in fact one and will get confused.</p>
<p>If we translate this line into english it will say:</p>
<blockquote>
<p>Please store the value four into the variable named “number_of_legs_in_a_cat”, end of instruction.</p>
</blockquote>
<!-- Like a telegram where it said "stop" -->
<p>And from this point, the computer would remember that this name equals to 4, so we could print it later:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;{}&quot;, number_of_legs_in_a_cat);
<span class="boring">}
</span></code></pre></pre>
<p>This is actually the same as doing:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   println!(&quot;4&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>So, if this is the case, why do we complicate this so much?</p>
<p>Well, variables will help us do much more complex programs, as they can keep track of what was the user input or other data that we are managing inside. It will make sense soon, so bear with me for now.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="declaring-variables"><a class="header" href="#declaring-variables">Declaring variables</a></h1>
<p>Before we can store values into a variable, we need to declare it. Declaring a variable means to tell Rust to create it, we will be explaining to it that this name is something that we will be using later.</p>
<!-- I don't really like this explanation but can't think of anything else -->
<p>Some programming languages don’t require declaring, and just storing a value for the first time will do the trick. This is the case for Python, but not for Rust.</p>
<p>Anyway, it’s not a big deal. Declaring a variable is very easy, we just have to use “let”:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   let x;
<span class="boring">}
</span></code></pre></pre>
<p>This comes from the wording in math of “let x be a number…”, so we use the keyword let to announce new variable names.</p>
<p>(A keyword is a reserved name by the programming language. So this means that you can’t have a variable named “let”, because “let let;” would be confusing for Rust to understand your program)</p>
<p>A very simple program that makes use of variables could be:</p>
<pre><pre class="playground"><code class="language-rust edition2021">   fn main() {
      let x;
      x = 4;
      println!(&quot;{}&quot;, x);
   }
</code></pre></pre>
<p>You already know what it does. Prints 4. That’s all.</p>
<p>A variable can change their value at any time. For this we need to use “let mut x” instead of “let x”, so Rust knows that we want to mutate the value inside this variable later on (more on this later).</p>
<p>An example:</p>
<pre><pre class="playground"><code class="language-rust edition2021">   fn main() {
      let mut x;
      x = 4;
      println!(&quot;{}&quot;, x);
      x = 6;
      println!(&quot;{}&quot;, x);
      x = 1;
      println!(&quot;{}&quot;, x);
   }
</code></pre></pre>
<p>That will print “4”, then “6”, then “1”. It’s just that the variable has changed the value it contained over time, as the program runs. Then the println!() just reads the value at that point in time and prints it to the terminal.</p>
<p>An important thing here, we have to use “let mut x” instead of just “let x” to tell Rust that this variable is “mutable”, this means that we can change the contents later on.</p>
<p>We can declare one variable per line, each one with its own let:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x;
let y;
let z;
<span class="boring">}
</span></code></pre></pre>
<p>But we can’t declare these in a single let instruction. Other programming languages such as C++ allow separating them with commas, but not in Rust. We need one line for each one.</p>
<p>Most of the time we declare a variable we actually want to give them a value, because after all a value must always have a value at all times. So we can save a few lines and do it in one shot:</p>
<!--- Why can we declare without assigning if it has to have a value anyway? -->
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 4;
let y = 3;
let z = 2;
<span class="boring">}
</span></code></pre></pre>
<p>So now this does two things at the same time, it declares and it stores a value. To be clear, this is just shorter and nicer on our eyes. To the computer, it is exactly the same as if we declared first and then we used another 3 lines to store the value. The program will be identical and will run equally fast.</p>
<p>Bottom line: do you prefer to see it on three lines all together or in six lines? Which one is easier to understand and read for you? Whatever is your response, that should be what you should write.</p>
<p>We don’t write the programs for computers, we write them for humans to understand. If you think that a particular way is easier to read and understand, go with it.</p>
<p>As you’ll start to notice by now, there are several ways to write a program (in fact, they’re infinite). This might feel annoying. Worse even, there’s no “right way”. There are subjectively better and worse ways, but it’s always up to humans to define what looks and feels better and come up with reasons for it.</p>
<p>Don’t be bothered about this, don’t think much about this. It is fine. Just write what it feels better to you personally and you’ll be grand. Over time you’ll learn more about how to make the code more readable, but that comes with experience. For now, let’s focus on learning this.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="incrementing-and-decrementing"><a class="header" href="#incrementing-and-decrementing">Incrementing and decrementing</a></h1>
<p>There’s a lot of stuff we can do with variables, but a very common thing is to use them to count, so an instruction that just says “add one to X” is quite handy:</p>
<pre><pre class="playground"><code class="language-rust edition2021"> fn main() {
   let mut x = 4;
   println!(&quot;{}&quot;, x);
   x += 1;
   println!(&quot;{}&quot;, x);
   x += 2;
   println!(&quot;{}&quot;, x);
   x += 3;
   println!(&quot;{}&quot;, x);
  }
</code></pre></pre>
<p>This program will output 4,5,7 and 10.</p>
<p>The other way around, subtracting, is also possible:</p>
<pre><pre class="playground"><code class="language-rust edition2021"> fn main() {
   let mut x = 10;
   println!(&quot;{}&quot;, x);
   x -= 1;
   println!(&quot;{}&quot;, x);
   x -= 1;
   println!(&quot;{}&quot;, x);
   x -= 1;
   println!(&quot;{}&quot;, x);
  }
</code></pre></pre>
<p>This one returns 10, 9, 8 and 7.</p>
<p>These operations are just a shorthand of this:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   x = x + 1;
   x = x - 1;
<span class="boring">}
</span></code></pre></pre>
<p>Which just means: read “x”, add one, and write the result into “x” again; overwriting the previous content.</p>
<p>A reminder: these are instructions, not math equations. The equals sign stores on the left the result of evaluating the right side.</p>
<p>Most operations you can think of that take the same form have a shortened operator as well. For example doubling a number is just “x *= 2”, which means “x = x * 2”.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="looping-around"><a class="header" href="#looping-around">Looping’ around</a></h1>
<p>I’m sure you feel that variables don’t do that much. But that’s because the programs we can write up to now are too linear and simple. We need to step up the game with… loops!</p>
<p>Loops are ways of repeating the same piece of code several times without need of copy pasting. For example, imagine we want to make a simple program that counts from 1 to 100:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
   println!(&quot;Number {}&quot;, 1);
   println!(&quot;Number {}&quot;, 2);
   println!(&quot;Number {}&quot;, 3);
   // ...
   println!(&quot;Number {}&quot;, 98);
   println!(&quot;Number {}&quot;, 99);
   println!(&quot;Number {}&quot;, 100);
 }
</code></pre></pre>
<p>As you can imagine, this gets tedious very easily. Copying, pasting and changing all the numbers manually is cumbersome.</p>
<p>Presenting… the for loop!</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
   for number in 1..=100 {
       println!(&quot;Number {}&quot;, number);
   }
 }
</code></pre></pre>
<p>This program does exactly the same thing in just three lines! Amazing, isn’t it? Now variables are actually being useful.</p>
<p>The syntax for this is as follows<sup class="footnote-reference"><a href="#note">1</a></sup>:
<sup class="footnote-reference"><a href="#note">1</a></sup> As usual, I’m lying and it’s not the real syntax. For loops are way more powerful than this; we’ll get to that later.</p>
<p>for variable_name in first_number..=last_number</p>
<p>We are asking the program to have a variable that counts from 1 to 100. The current count number will be stored in the variable “number” (which we can name it as we like).</p>
<p>The “..=” in between the numbers is used to define a range. The equals on the right means that it includes the right number. There also exists “..” which does not include the last number (i.e. 0..100 counts from 0 to 99).</p>
<p>We can also put a loop inside a loop, so we can count in two directions. This could be useful to describe all positions in a chess board:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
   for row in 1..=8 {
       for column in 1..=8 {
           println!(&quot;Row {}, Column {}&quot;, row, column);
       }
   }
 }
</code></pre></pre>
<p>And of course, there’s no limit. You could put three or ten loops one inside another. The limit is your imagination here!</p>
<p>In this code, it will first pick a row, then go over all the columns. When all 8 columns are done it will proceed with the next row.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-some-comments"><a class="header" href="#adding-some-comments">Adding some comments</a></h1>
<p>The programs sometimes are hard to understand and it would be nice to leave some notes for the people reading it so they can understand it too. And I bet you that you’ll forget what a program does after 3 months, even if you wrote it yourself. It happens to me too. So it’s good to have some notes on the program so we can understand it later.</p>
<p>They can also be used to denote that some work is yet missing (we call these TODO) so it serves as a reminder for later on. But we all know that we will never get to do them. That’s how it works in reality, trust me.</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
   // Compute all the cells in a Chess Board:
   for row in 1..=8 {
       for column in 1..=8 {
           // TODO: For now just display the numbers, we'll fix this &quot;&quot;later&quot;&quot;.
           println!(&quot;Row {}, Column {}&quot;, row, column);
       }
   }
 }
</code></pre></pre>
<p>Most comments use the double slash (//). When Rust sees this, it ignores any text on the right side of it, so we can use this to add our thoughts on the program.</p>
<p>However, if you need to comment out a lot of lines, adding “//” to every line can be daunting. VS Code has shortcuts for this (and you can customize them) so it’s easier.</p>
<p>But Rust also has comment blocks. A comment block starts with “/<em>” and ends with “</em>/”. Everything in the middle is completely ignored even if there are multiple pages.</p>
<pre><pre class="playground"><code class="language-rust edition2021">/*fn main() {
   for row in 1..=8 {
       for column in 1..=8 {
           println!(&quot;Row {}, Column {}&quot;, row, column);
       }
   }
 }*/
</code></pre></pre>
<p>Voilà. Now we no longer have any program. As Rust is concerned, the file is empty.</p>
<p>But these comment types are a bit trickier. They cannot be nested. If you try to add a block comment on something that already contains a comment block inside, Rust will get confused.</p>
<p>Because of this, I prefer to avoid these and stick with the simple and reliable double slash (//).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-if"><a class="header" href="#what-if">What If…?</a></h1>
<p>… it is raining outside? You should get an umbrella, right?</p>
<p>This is basically a conditional: If it’s raining, get an umbrella. We have these in Rust and use the keyword “if”. The name may not sound original at all, but helps reading the program as if it were english.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
   let apples = 6;
   if apples &gt; 1 {
       println!(&quot;You have many apples!&quot;);
   }
 }
</code></pre></pre>
<p>This program will print “You have many apples!” only if the “apples” variable is bigger than one.</p>
<p>Of course, it only changes if you manually go and change the variable value. Don’t go that fast! we’ll see something useful soon.</p>
<p>The syntax is:
if condition { … what to do if the condition is true … } else { … what to do if it’s not … }</p>
<p>Condition can be anything that is either true or false. Some examples:</p>
<ul>
<li>apples == 1 → if “apples” is exactly 1.</li>
<li>apples != 1 → if it’s not 1. Any other value except one will do.</li>
<li>apples &gt;= 1 → if it’s greater or equal to 1.</li>
<li>apples &lt; 1 → if it’s less than 1.</li>
<li>apples &lt;= 1 → if it’s less than or equal to 1.</li>
</ul>
<p>Notice how I told you the “if” has an else part, but I did not write it on the above program. That’s because it’s optional. If we only care about the part it’s true, the “else” is not needed.</p>
<p>However, we cannot do the reverse. You cannot have an “else” without an “if”. If we need to target when the condition is false, we need to reverse the condition so it returns true when we need to.</p>
<p>Let’s see an example with an “else”:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
   let apples = 1;
   if apples &gt; 1 {
       println!(&quot;You have many apples!&quot;);
   } else {
       println!(&quot;Please go to the supermarket.&quot;);
   }
 }
</code></pre></pre>
<p>Ok, enough of this. It’s too simple I guess and we need to spice it up with…</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="for-loops-again"><a class="header" href="#for-loops-again">For loops again!</a></h1>
<p>Yay! Wait, I thought you were excited about this.</p>
<p>Let’s do something useful. This program will graph the function “y = x * x / 20 - 9” in the terminal:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
   for y in -10..10 {
       for x in -30..30 {
           let value = x * x / 20 - 9;
           if value &gt;= y {
               print!(&quot; &quot;);
           } else {
               print!(&quot;#&quot;);
           }
       }
       println!();
   }
 }
</code></pre></pre>
<p>As you can see, it only uses “for” and “if”. It might look complicated, but with a bit of work you should be able to follow it.</p>
<p>For the record, this is the output it produces:</p>
<pre><code> $ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
     Running `target/debug/learnrust`
                                                            
                                               
                      #########              
                    #############            
                   ###############           
                  #################          
                 ###################         
                #####################        
               #######################       
              #########################      
             ###########################     
            #############################    
            #############################    
           ###############################   
          #################################  
          #################################  
         ################################### 
         ################################### 
        #####################################
        #####################################
</code></pre>
<p>You can change the formula in “let value = x * x / 20 - 9” and it will graph whatever math function you like.</p>
<p>I know, there’s a lot to unpack here. I’ll go step by step. But first, for the avid readers, yes the function is mirrored upside down. This is because the first line that is drawn first is in math the bottom one, and computers draw top to bottom while in math the Y axis goes from bottom to top.</p>
<p>It can be fixed, but to keep things simple I prefer to keep this bug in.</p>
<p>Let’s go first on the inner code of the loops:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>           let value = x * x / 20 - 9;
           if value &gt;= y {
               print!(&quot; &quot;);
           } else {
               print!(&quot;#&quot;);
           }
<span class="boring">}
</span></code></pre></pre>
<p>This computes x² by doing “x * x”, divides by 20 and then subtracts 9. Rust has a pow() function to do x² instead of x * x, but to keep it simple I avoided it. Anyway, this gets stored into the “value” variable and the “if” compares against “y”.</p>
<p>So, if it’s less than “y” prints a hash “#”, if not, it prints a space “ “ otherwise.</p>
<p>This is meant to fill the shape. Given the math function:</p>
<pre><code>    y = x² / 20 - 9
</code></pre>
<p>It computes which “squares” are below the math function and uses the “#” character to fill the shape.</p>
<p>Notice how I used “print!” instead of “println!”. The lack of the “ln” (which stands for line) makes that print not open a new line, so it prints to the right, like a typewriter.</p>
<p>So all that is left is to loop across all “x” and “y” squares:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   for y in -10..10 {
       for x in -30..30 {
           // ... 
       }
       println!();
   }
<span class="boring">}
</span></code></pre></pre>
<p>So using here a nested loop we iterate through negative and positive values for both x and y.</p>
<p>As “y” is usually the vertical axis, and the terminal prints first left-to-right and then to-to-bottom, we need to first print an entire row; That’s why the “for y” appears first and the “for x” appears next.</p>
<p>After the “for x” is done, we need to move to the next line, so an empty “println!()” will move the cursor to the next line.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introducing-functions"><a class="header" href="#introducing-functions">Introducing Functions</a></h1>
<p>It might seem difficult to picture that sometimes the same piece of code needs to repeat in different places of the code, and it’s not a loop what I’m talking about.</p>
<p>The example programs I can add in this book have to be small so we can go line by line. In reality, good useful programs have thousands of lines. It’s hard to make something really useful in twenty lines with only the basic operations we learned.</p>
<p>It might seem daunting to think about writing several thousand lines, but it is easier than it seems. We always start small, we keep adding pieces and after a few weeks it’s easy to have those thousand lines.</p>
<p>One of the applications I wrote, zzping, has nearly 7000 lines of code in it. And it has been only a hobby without much investment from my side. Programs get big very easily.</p>
<p>Having all those instructions inside the “fn main() {…}” is very hard to follow. It’s similar to organizing stuff in your room or in the house. If all items of your house were in a single big box, trying to find anything there is nearly impossible, so we all use different drawers, stands and boxes to sort the stuff so we can locate it later.</p>
<p>In the same fashion, we split big programs into different files, so all related instructions that work towards a similar goal are near each other, and each file has its own tools there.</p>
<p>We will see later on how to split into different files (in Rust, those are called modules), but now I want to explain how to sort stuff out inside a single file.</p>
<p>Imagine we’re doing some sort of program that tells the user interesting stuff and it has a menu:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
   println!(&quot;Welcome to the Trivia program!&quot;);
   println!(&quot;------------------------------&quot;);
   println!(&quot;&quot;);
   println!(&quot;Please choose an option:&quot;);
   println!(&quot;&quot;);
   println!(&quot;    1. Tell a funny story&quot;);
   println!(&quot;    2. Show the multiplication table for a number&quot;);
   println!(&quot;    3. Show the dividing table for a number&quot;);
   println!(&quot;    4. Tell the future for a zodiac sign&quot;);
   println!(&quot;    5. Browse the cooking recipes&quot;);
   println!(&quot;    6. Exit the program&quot;);
   println!(&quot;&quot;);
   println!(&quot; Your option:&quot;);
 }
</code></pre></pre>
<p>As you can imagine, each of these options almost consists of its own program. Trying to code everything in here is going to be really confusing:</p>
<pre><pre class="playground"><code class="language-rust edition2021"> fn main() {
   println!(&quot;Welcome to the Trivia program!&quot;);
   println!(&quot;------------------------------&quot;);
   println!(&quot;&quot;);
   println!(&quot;Please choose an option:&quot;);
   println!(&quot;&quot;);
   println!(&quot;    1. Tell a funny story&quot;);
   println!(&quot;    2. Show the multiplication table for a number&quot;);
   println!(&quot;    3. Show the division table for a number&quot;);
   println!(&quot;    4. Tell the future for a zodiac sign&quot;);
   println!(&quot;    5. Browse the cooking recipes&quot;);
   println!(&quot;    6. Exit the program&quot;);
   println!(&quot;&quot;);
   println!(&quot; Your option:&quot;);
   let option = 1; // TODO: Read the user input option and store it here.
   if option == 1 {
       println!(&quot;Here's a joke...&quot;)
       // TODO: Add jokes and a joke selector
   }
   if option == 2 {
       // TODO: Ask the user which number
       // ... compute and show the multiplication table
   }
   if option == 3 {
       // TODO: Ask the user which number
       // ... compute and show the division table
   }
   if option == 4 {
       // TODO: Add a database of zodiacs with their predictions
       // ... ask the user and show the matching one
   }
   if option == 5 {
       // TODO: Add a database of recipes
       // ... ask the user and show the matching one
   }
   if option == 6 {
       // TODO: Exit the program here
   }
   // TODO: Loop again to the beginning if option 6 wasn't chosen.
 }
</code></pre></pre>
<p>It would be nice if we could break the program into subprograms that do specific things, so we can call those when we need them, right?</p>
<p>That concept is exactly what a function is.</p>
<p>As usual, I’ll go back to short and stupid programs, but keep in mind the above example where they’re useful.</p>
<pre><pre class="playground"><code class="language-rust edition2021"> fn welcome() {
   println!(&quot;Welcome adventurer!&quot;);
   println!(&quot;There are lots of treasures hidden in this place.&quot;);
   println!(&quot;Oh, and there's also a princess trapped in a castle.&quot;);  
   println!(&quot;&quot;);
   println!(&quot;You know what to do.&quot;);
 }


 fn main() {
   welcome();
   println!(&quot;End of program&quot;);
 }
</code></pre></pre>
<p>Here we can see a “welcome” function that prints six lines of text. What the computer does is:</p>
<ul>
<li>It always starts from the main function.</li>
<li>Reads the welcome() call to the function, so it jumps to the top “fn welcome()”</li>
<li>Executes the five println!</li>
<li>The function ends on the “}”, so it goes back where it was on main.</li>
<li>Reads the next line and prints “End of program”.</li>
<li>Reaches the end of main (the “}”) and the program ends here.</li>
</ul>
<p>A function has two sides, the declaration and the call. The function declaration states what is the function name and what it does:
fn your_function_name() { … your code here for what this function does … }</p>
<p>And then you can call it as many times you want, using:
your_function_name();</p>
<p>And the key thing here is “call it as many times you want”. The function’s purpose is to be reused several times, so you don’t have to repeat your code several times.</p>
<p>The declaration part doesn’t need to be above or below the main(), it can be anywhere as long as it is not inside the main. Placing it before or after the main is fine, the order doesn’t matter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="returning-values-from-functions"><a class="header" href="#returning-values-from-functions">Returning values from functions</a></h1>
<p>It is also possible to use a function to calculate a certain value. For example, we can calculate the number PI:</p>
<pre><pre class="playground"><code class="language-rust edition2021"> fn calculate_pi() -&gt; f64 {
   // https://en.wikipedia.org/wiki/Leibniz_formula_for_%CF%80
   // pi/4 = 1 - 1/3 + 1/5 - 1/7 + 1/9 - ...
   let mut pi_4 = 1.0;
   let mut divisor = 3.0;
   let steps = 20_000_000;
   for _ in 0..steps {
       pi_4 -= 1.0 / divisor;
       divisor += 2.0;
       pi_4 += 1.0 / divisor;
       divisor += 2.0;
   }
   return pi_4 * 4.0;
 }
 fn main() {
   let pi = calculate_pi();
   println!(&quot;pi: {}&quot;, pi);
 }
</code></pre></pre>
<p>Again, this program might be a bit too much, but the important thing is in the first line:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> fn calculate_pi() -&gt; f64 {
<span class="boring">}
</span></code></pre></pre>
<p>The arrow symbol (-&gt;) indicates that this function returns a value. “f64” is which kind of value we want to return, which for this case is a floating point number (one with decimal places). If we wanted to return an integer we would have used “i64”.</p>
<p>The last line of the function specifies the actual value to be returned:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   return pi_4 * 4.0;
<span class="boring">}
</span></code></pre></pre>
<p>Since this fraction series calculates PI divided by four, we need to multiply it by four to get PI, and the return keyword is what signals Rust that it should exit the function at that point (it marks the end of it) and return the value on the right.</p>
<p>It is worth noting that while the “return” keyword is in most other programming languages as well, Rust specifically has another way of writing this:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   pi_4 * 4.0
<span class="boring">}
</span></code></pre></pre>
<p>Just removing the return keyword and also removing the semicolon signals Rust that this is the output of that block. It behaves similar but not identical to return. For simplicity sake we’ll keep using return for now which could be simpler to read and understand. However, this form is actually preferred in Rust code. We will learn it in depth later on.</p>
<p>The next thing we should focus on is how this function is called:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let pi = calculate_pi();
<span class="boring">}
</span></code></pre></pre>
<p>Notice how it is used like it was a value. Rust will call the function, get the output and replace here the function by the output value. Then it will be stored in the variable “pi”.</p>
<p>Everything else in this program is something that we already saw before. Let me go over a few things that might seem new:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let mut pi_4 = 1.0;
   let mut divisor = 3.0;
   let steps = 20_000_000;
   for _ in 0..steps {
<span class="boring">}
</span></code></pre></pre>
<p>We are using “let mut” here to be able to change the values of pi_4 and divisor inside the function. Without that, Rust will not let us change the variable contents.</p>
<p>Another thing that might seem strange is the number 20_000_000. This is just 20 million, but the underscores are placed to make it easier to read. They have no meaning to Rust.</p>
<p>In the for loop, you’ll notice that it says “0..steps”; so this basically makes the for count up to “steps”. There’s nothing special with this.</p>
<p>Finally, the for has as a variable an underscore “_”. This is because this variable is not used. We only need N steps, but we use “divisor” to keep track of the position. Rust will emit warnings for unused variables. To avoid this, we use an underscore to signal Rust we don’t need this value.</p>
<p>The result of the program is:
pi: 3.1415926785904635</p>
<p>It’s quite close to the real thing. Of course, if you increment the number of steps it will get closer, but the program will take a bit to run. For those cases we can make our Rust program faster by adding the “–release” flag to cargo run:</p>
<pre><code> $ cargo run --release
   Compiling learnrust v0.1.0 (/home/deavid/git/rust/learnrust)
    Finished release [optimized] target(s) in 1.00s
     Running `target/release/learnrust`
  pi: 3.1415926785904635
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-arguments"><a class="header" href="#function-arguments">Function arguments</a></h1>
<p>But what if we wanted a configurable number of steps? We can do that!</p>
<p>Functions can accept data when they’re called, like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let pi = calculate_pi(100);
<span class="boring">}
</span></code></pre></pre>
<p>But for this to work we need to change the function signature:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  fn calculate_pi(steps: i64) -&gt; f64 {
<span class="boring">}
</span></code></pre></pre>
<p>We have to specify between the parenthesis what is the variable name that will record the input value, as well as the type. Since steps won’t have any decimal places, we use “i64” instead of “f64”.</p>
<p>Therefore, a more complete description on the syntax for a function is:
fn function_name( input_var_name: type ) -&gt; return_type { … }</p>
<p>Where the arguments can be omitted and the return type can be omitted as well if we don’t use them.</p>
<p>It is possible as well to have many input values, just separating them by comma:
fn function_name( input1: type1, input2: type2, input2: type2, … ) { … }</p>
<p>Each input variable needs to have its own type associated. We’ll see more examples on this later on.</p>
<p>For now, let’s see the full program changed:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn calculate_pi(steps: i64) -&gt; f64 {
   // https://en.wikipedia.org/wiki/Leibniz_formula_for_%CF%80
   // pi/4 = 1 - 1/3 + 1/5 - 1/7 + 1/9 - ...
   let mut pi_4: f64 = 1.0;
   let mut divisor = 3.0;
   for _ in 0..steps {
       pi_4 -= 1.0 / divisor;
       divisor += 2.0;
       pi_4 += 1.0 / divisor;
       divisor += 2.0;
   }
   return pi_4 * 4.0;
 }
 fn main() {
   for n in 1..10 {
       let steps = i64::pow(10, n);
       let pi = calculate_pi(steps);
       println!(&quot;pi: {} ({} steps)&quot;, pi, steps);
   }
 }
</code></pre></pre>
<p>This program now has a loop in main() that will do 10 different calculations of PI at different precision levels.</p>
<p>Here’s the output:</p>
<pre><code> $ cargo run --release
   Compiling learnrust v0.1.0 (/home/deavid/git/rust/learnrust)
    Finished release [optimized] target(s) in 1.00s
     Running `target/release/learnrust`
 pi: 3.189184782277596  (10 steps)
 pi: 3.1465677471829556 (100 steps)
 pi: 3.1420924036835256 (1000 steps)
 pi: 3.1416426510898874 (10000 steps)
 pi: 3.141597653564762  (100000 steps)
 pi: 3.1415931535894743 (1000000 steps)
 pi: 3.1415927035898146 (10000000 steps)
 pi: 3.1415926585894076 (100000000 steps)
 pi: 3.1415926540880768 (1000000000 steps)
</code></pre>
<p>It’s important to run this with “–release” or it will take a bit too long to compute.</p>
<p>Also, it’s always mesmerizing to see how more and more digits are getting “stuck in” as the number of steps grows.</p>
<p>I think this variation should be self explanatory with maybe the exception of this line:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>       let steps = i64::pow(10, n);
<span class="boring">}
</span></code></pre></pre>
<p>This computes “steps = 10n”, that is, the power of 10 raised to the “n”. For this we use the function pow that exists inside the “i64” type. The double colon operator “a::b” is used to access the functions inside other libraries (or any content in fact).</p>
<p>Note that this function pow accepts two numbers as input and returns a number.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-types"><a class="header" href="#data-types">Data types</a></h1>
<p>We have reached a point where I cannot continue to explain much more without giving you a fair bit of theory. Sorry about this, but it’s needed.</p>
<p>What are data types?</p>
<p>First of all: what is data? Data is just the technical term for value. The number 5 is a value and is data, and so is 2.41 or the string “Basement”.</p>
<p>The concept of “data types” just refers to the different kinds of values. You see, 3+5 is 8, but “Base”+“ment” is “Basement”. The sign plus (+) might work differently depending on if it is text or a number.</p>
<p>Some operators like dividing (/) make sense on numbers (8/2=4) but don’t make any sense on texts (“Base”/“ment” = ????).</p>
<p>So the primordial thing that puts data types apart is what can be done with the values, what makes sense and what doesn’t; and also what the operations actually mean.</p>
<p>Because, you know, computers might look like really smart but they’re actually pretty stupid. If you do, “3”+“5” is just “35” and not “8” (because of the quotes, it is treated like text, so it gets concatenated when using the plus sign). They take everything literally, too literally. And we need to tell them what to do, step by step to a level that feels like training a monkey how to make a chocolate brownie.</p>
<p>There are tons of data types, you can construct your own and you can also use other people’s types. But in general, to start, we have three basic types:</p>
<ul>
<li>Numbers
<ul>
<li>Integers (which can be positive or negative, but don’t have a decimal point)</li>
<li>Floating point numbers (or floats) that actually have decimal places.</li>
</ul>
</li>
<li>Texts, generally called “strings” in programming (at some point later I might explain where the name “string” comes from, it’s a bit funny)</li>
<li>True/False types, called “bools” or “boolean”, used to store the result of comparisons such as “apples &gt; 1”.</li>
</ul>
<p>You might be inclined to always use floating point numbers for everything, as they can do much more than regular integers. If they’re better, there’s no point in using the puny integers, right?</p>
<p>Well, no. Later on I will recommend you to avoid floats like the plague. They have lots of problems that will make your life difficult. But for now if you want to stick with them it’s totally fine. Just write 2.0 instead of 2 for every number and you’re done.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-data-types"><a class="header" href="#rust-data-types">Rust data types</a></h1>
<p>Rust data types are however a bit more nuanced. You see, these values we want to store have to be actually recorded somewhere in your physical computer. And that will be your computer memory (RAM, or DDR if you prefer). The number 4 might not look like much, but Rust has to ask for memory from your computer in order to save the value somewhere, else it would be lost, forgotten and programs won’t run.</p>
<p>So the question that Rust faces is: how much memory is needed for this variable? A variable can change its value later on, for example that x=4, later on it can be x=99999999. It needs to grab enough memory in order to ensure that all values you might want to put there actually do fit.</p>
<p>This is why integers are split into different sizes:</p>
<ul>
<li>i8</li>
<li>i16</li>
<li>i32</li>
<li>i64</li>
</ul>
<p>Each of those is a valid Rust type for an integer. And yeah, the “i” is short for integer. The number that it follows is the number of bits that Rust will get for them.</p>
<p>Is 8 bits a lot? Let’s see. A computer might have 4 gigabytes of RAM. Giga just means billion. So that’s 4,000,000,000 bytes. And a byte is just 8 bits.</p>
<p>So this means that i8 only uses 1 byte of memory. And if a computer has 4,000,000,000 bytes, I can surely assume it can store a whole lot of those and still have plenty of space left. So yeah, it’s very tiny.</p>
<p>But this affects the range of numbers we can store. It is fine for storing -4, 12 or 81. But 355 is too much for an i8 and the program will fail. If we need to store bigger numbers, we need to use types that use more space.</p>
<p>For example, i16 can store up to 32,000.</p>
<p>But you know what? This is too complicated. Why bother? Use i64 and that’s it. Forget about the others for now and just use i64 for everything. Your computer has so much memory that it doesn’t care if a number uses 1 byte or 8.</p>
<p>An i64 can store any integer number up to roughly 9,000,000,000,000,000,000. Either positive or negative. Unless you want to start counting atoms, I think we have more than enough to work with. So again, let’s use i64 for all our integer numbers and forget about this conversation.</p>
<p>Rust also has unsigned numbers, which work exactly the same as the regular integers but they can’t store negative numbers, Instead of “i” they go with “u” and work exactly the same:</p>
<ul>
<li>u8</li>
<li>u16</li>
<li>u32</li>
<li>u64</li>
</ul>
<p>Why limit ourselves to only positive? Well, they can hold double the numbers inside. But… why? wasn’t 9,00.. or whatever enough for us…?</p>
<p>Exactly. It is enough. So again, we won’t be using these. Use i64.</p>
<p>There are two extra integer types in Rust:</p>
<ul>
<li>usize</li>
<li>isize</li>
</ul>
<p>If your computer is a 64bit one, then these are equivalent to u64 and i64. But these have their specific use. We will come back later to the “usize” as it is how computers locate things in memory. Certain things such as locating an item in a list/collection of numbers use “usize”.</p>
<p>I’m dumping this to you now to give an approximate picture of the data types that Rust has in the hopes that you’ll begin to recognise these later on. I’ll explain this again later on with more detail, so no need to study and memorize these things now.</p>
<p>Floating points, very similarly have two variants for sizes:</p>
<ul>
<li>f32</li>
<li>f64</li>
</ul>
<p>“f” for float, and 32 or 64 for the amount of memory that they use. And guess what, we’ll use f64 when we need decimal places and forget about f32.</p>
<p>Boolean values (bool) only have one type:</p>
<ul>
<li>bool</li>
</ul>
<p>There isn’t much secret on this type, it is quite like an integer that holds 0 for false and 1 for true. That is all.</p>
<p>Strings (texts) also come in two variants, but, surprise! it’s not for size!</p>
<ul>
<li>str</li>
<li>String</li>
</ul>
<p>The difference is a bit too nuanced to explain right now, so let’s just say they’re almost the same thing. We will use String for our variables, as it is simpler to use, but in some cases, Rust wants a “str” instead. They can be converted one to another, so it’s not a big deal.</p>
<p>As you might have noticed, they don’t have any specific size. So, how big can the text be inside?</p>
<p>Short answer: As long as you want.</p>
<p>They’re dynamic. Rust will request more memory when needed. So as long as your computer has enough memory to store the text, it will work<sup class="footnote-reference"><a href="#note">1</a></sup>. 
<sup class="footnote-reference"><a href="#note">1</a></sup> Oh crap, I’m sorry, I’m lying way too much… I swear I will fix this mess later on. For now, bear with me, this is the explanation you need</p>
<p>And those are all types we will be using for a long, long time here. So, to recap:</p>
<ul>
<li>Integer numbers (without decimal places): i64</li>
<li>Floating point numbers (with decimal places): f64</li>
<li>Strings (text): String (with the first S in uppercase)</li>
<li>Booleans (true/false): bool</li>
<li>Locating values inside a list: usize (we’ll see this later on)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="back-to-declaring-variables-with-type"><a class="header" href="#back-to-declaring-variables-with-type">Back to declaring variables… with type</a></h1>
<p>Now that we have a rough idea on types, we can do more things with the “let” keyword.</p>
<p>For example, we can tell Rust to use an i64 for our number:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   let x: i64 = 2;
<span class="boring">}
</span></code></pre></pre>
<p>That will force the selection of this type. But wait… if we didn’t specify a type, and Rust needs one to know how much memory to use… how did Rust make the previous examples work?</p>
<p>As a reminder, we did:</p>
<pre><pre class="playground"><code class="language-rust edition2021">   fn main() {
      let x;
      x = 4;
      println!(&quot;{}&quot;, x);
   }
</code></pre></pre>
<p>And we did not specify a type here. In fact, this could be i8, i16, i32, i64 or even u8, u16, etc. All these will work.</p>
<p>Which one did select Rust and why?</p>
<p>Did we care which one to use when writing this? no. And neither does Rust.</p>
<p>Rust will do something similar to what I’m telling you to do. i64 is a perfectly fine type for most uses, so just go with that. Rust is probably doing the same thing here: It seems you want a number; does i64 work? ok, so that one then; that looks good<sup class="footnote-reference"><a href="#note">1</a></sup>.
<sup class="footnote-reference"><a href="#note">1</a></sup> Note here that Rust might guess differently and prefer an i32 over an i64 “because it’s smaller and it still works”. As we didn’t care about which type, it’s pointless to try to know what Rust exactly does. If we want to be sure it’s an i64, we just write it down</p>
<p>Rust does a lot of guesswork to select the type, and most of the time we don’t need to care about this. In a few particular times it might be confused with too many options that are too different, and might complain. In such cases, we need to help it by defining the type. Aside from that we’ll avoid setting the types and let Rust do its magic.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="converting-types-with-explicit-conversions"><a class="header" href="#converting-types-with-explicit-conversions">Converting types with explicit conversions</a></h1>
<p>As you can imagine, it is pretty common having a mix of types. With so many data types it is easy to end up having an operation that needs to mix them in some way, and Rust does not allow that.</p>
<p>We will avoid the majority of those problems by using as few types as possible, just i64 and f64. But it will happen at some point.</p>
<p>For example, consider a simplistic example:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   let apples: i64 = 2;
   let apple_weight: f64 = 0.35;
   let total_weight: f64 = apples * apple_weight;
<span class="boring">}
</span></code></pre></pre>
<p>In this case we could define “apples” to be a float and it will work, but this could appear in a different way where this is not so simple, and we need “apples” to be an integer regardless.</p>
<p>To make this work we can simply convert “apples” variable in the spot, right where we need it:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   let apples: i64 = 2;
   let apple_weight: f64 = 0.35;
   let total_weight: f64 = apples as f64 * apple_weight;
<span class="boring">}
</span></code></pre></pre>
<p>By adding “as f64” we’re making what is called an “explicit conversion”. Rust will convert the integer into a floating point on the spot and will use that on the calculation of total_weight.</p>
<p>The variable “apples” is still an integer after that line. If we keep using it as a float we would need to keep converting every time. So if it is needed in all places as a float, maybe it is better to just make it a float from the start.</p>
<p>Explicit conversions have their limitations though. It works only between some types that are easy for Rust to convert. You can’t use it to convert to or from strings (there are other conversion types for that), or between string types.</p>
<p>Doing the reverse, converting a float into an integer, will drop any decimal places. So “2.99999 as i64” is just 2. It will not round the number to 3. There are other ways for rounding numbers.</p>
<p>The reason why explicit conversion works for so few cases and its behavior. These conversions are usually supported by your CPU and are really fast. Rounding numbers or converting an integer into a string will take several iterations in your CPU to complete. Those are also very fast, just not as fast as the explicit conversion. Rust is trying to signal you where your program might be consuming more resources, which is helpful, but we don’t need to be obsessed with speed. Rust is very fast, and so is your computer (even if old).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-tiny-bit-on-strings"><a class="header" href="#a-tiny-bit-on-strings">A tiny bit on strings</a></h1>
<p>Storing and manipulating texts in a program is a bit harder to explain than numbers. This is because a computer does not work with text, but with numbers.</p>
<p>Surely you have heard that in a computer everything are ones and zeros (the binary system). These can be combined to create big numbers, and with some tricks the CPU can also work natively with floating point in order to have decimal places.</p>
<p>But text is not a number, which means that Rust needs a bit of work behind the scenes to make these work.</p>
<p>As a basic introduction, a text is nothing more than a sequence of letters. The text “ABC” might be a string, but it also is a sequence of three letters: ‘A’, ‘B’ and ‘C’.</p>
<p>Each letter is a character. If we assign each possible character a number, we can in fact store text using numbers:</p>
<ul>
<li>‘A’ -&gt; 65</li>
<li>‘B’ -&gt; 66</li>
<li>‘C’ -&gt; 67</li>
<li>…</li>
</ul>
<p>This is totally arbitrary, but there’s a standard called “ASCII” that defines a table of conversions from letters to numbers. If all programs use the same table, then we can save those numbers into a file, and get the correct texts back when another program reads the same file.</p>
<p>So a string is just a list of numbers that it is conveniently interpreted as text.</p>
<p>Instead of the ASCII table Rust by default uses UTF8 for strings. I won’t go into much detail here, but the world has different languages with different characters. Think about Chinese, Japanese, and Russian. The ASCII table is not good for those. UTF8 is still compatible with ASCII but it allows for a character to span multiple number entries (bytes), so we can have in the same format any kind of writing language.</p>
<p>To keep things simple, just assume it is ASCII for now. We’ll cover UTF later on.</p>
<p>Why are texts called “strings”?
https://stackoverflow.com/questions/880195/the-history-behind-the-definition-of-a-string
(To be completed later)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simple-explanation-on-str-vs-string"><a class="header" href="#simple-explanation-on-str-vs-string">Simple explanation on &amp;str vs String</a></h1>
<p>We will use these soon, so they need a bit of an introduction. They both store a sequence of characters.</p>
<p>It all boils down to what I commented early on. Rust (and the computer itself) needs to know how big a variable is. But a string can change in size very abruptly.</p>
<p>Because of this, Rust cannot know the size of most strings until the program is actually executed. This poses a problem, because without a rigid size in memory we cannot have variables that contain text. At most, we can have a variable that stores a single character, but this isn’t very useful.</p>
<p>So what do we do? Well, instead of having the text itself in a variable we store where the string is and its length. This is the type “&amp;str”.</p>
<p>While this is the fastest way for the computer to do this, and convenient for some parts of the program, it’s certainly very hard to manipulate. It’s nearly impossible to change the contents of a “&amp;str” variable.</p>
<p>It’s because of that inconvenience that String exists. The String type encapsulates and automates string changes.</p>
<p>So, in general, when a text never changes, &amp;str is just fine. But if we want to store the user’s input, String might be better.</p>
<p>In Rust these two are very easy to convert from one to another:</p>
<pre><pre class="playground"><code class="language-rust edition2021"> fn main() {
   let s1 = &quot;This is a &amp;str&quot;;
   let s1a = s1.to_owned(); // This converts &amp;str to String.
   let s2 = String::from(&quot;This is a String&quot;);
   let s2a = s2.as_str(); // This converts String to &amp;str.
 }
</code></pre></pre>
<p>We’ll go on more details later on, but for now we will basically use whatever type Rust is happier with. Depending on what we’re doing we will probably need one or the other and convert accordingly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="having-fun-with-libraries"><a class="header" href="#having-fun-with-libraries">Having fun with libraries</a></h1>
<p>Doing everything by ourselves might be rewarding, but it is also tiring. It takes a lot of effort and knowledge to code a proper program that is really useful. But I like a saying that goes: “Don’t reinvent the wheel”</p>
<p>If you need something, it is highly probable that someone else did it already and shared it for free. Seriously. Most of the time it is just a problem of not googling enough, or using the right keywords.</p>
<p>People share their functions and modules as libraries called “crates” in a site called crates.io.</p>
<p>As a beginner, it is important to use as many crates as you can<sup class="footnote-reference"><a href="#note">1</a></sup>. They will allow you to create interesting programs easily, giving you a good sense of progress.
<sup class="footnote-reference"><a href="#note">1</a></sup> Of course, don’t go crazy and import the whole site. It’s not a race to see who imports more crates. Also, as you gain more experience you should be able to keep the number of imported libraries low.</p>
<p>The first library I want you to try is “rand”: https://crates.io/crates/rand</p>
<p>This crate as the name suggests creates random numbers. We need to install it in our project, and for that, notice that on the right side of the website there are Install instructions and Documentation:</p>
<p>So we will follow the install instructions. We need to open our “Cargo.toml” file first. This file was created when we did “cargo new”.</p>
<pre><code class="language-toml"> [package]
 name = &quot;learnrust&quot;
 version = &quot;0.1.0&quot;
 edition = &quot;2021&quot;
 
 # See more keys and their definitions at ...
 
 [dependencies]
 rand = &quot;0.8.4&quot;   # Add dependencies here
</code></pre>
<p>We add the new crate to this file by inserting the line <code>rand = &quot;0.8.4&quot;</code> as the instructions say just below the <code>[dependencies]</code>.</p>
<p>If we execute now “cargo run” we get something different already:</p>
<pre><code> $ cargo run
   Compiling cfg-if v1.0.0
   Compiling ppv-lite86 v0.2.15
   Compiling libc v0.2.107
   Compiling getrandom v0.2.3
   Compiling rand_core v0.6.3
   Compiling rand_chacha v0.3.1
   Compiling rand v0.8.4
   Compiling learnrust v0.1.0 (/home/deavid/git/rust/learnrust)
    Finished dev [unoptimized + debuginfo] target(s) in 2.54s
     Running `target/debug/learnrust`
 Hello world
</code></pre>
<p>Cargo noticed that we have added a new dependency, so it downloaded the required libraries and compiled them too! A lot of work that didn’t require almost any manual action from our side.</p>
<p>The program however still does the same thing. Just installing a library is not going to make our program generate random numbers.</p>
<p>The simplest way to start with it is to use rand::random():</p>
<pre><pre class="playground"><code class="language-rust edition2021"> fn main() {
   let randnum: i64 = rand::random();
   println!(&quot;Hello world: {}&quot;, randnum);
 }
</code></pre></pre>
<p>We need to define the type of randnum this time. The reason is that this library detects where we want to save it and creates a random number as big as possible that does fit.</p>
<p>The result is:</p>
<pre><code> deavid@debian:~/git/rust/learnrust$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
     Running `target/debug/learnrust`
 Hello world: 1976599895379426978
 deavid@debian:~/git/rust/learnrust$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
     Running `target/debug/learnrust`
 Hello world: -2920297650750248329
 deavid@debian:~/git/rust/learnrust$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
     Running `target/debug/learnrust`
 Hello world: 8971769657686972258
 deavid@debian:~/git/rust/learnrust$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
     Running `target/debug/learnrust`
 Hello world: -8688429354790802443
</code></pre>
<p>As we can see it creates very big numbers, both positive and negative. A different random number is generated in each run.</p>
<p>We could make the number positive and smaller by choosing “u8” instead of “i64”:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   let randnum: u8 = rand::random();
<span class="boring">}
</span></code></pre></pre>
<p>This creates the following results:</p>
<pre><code> Hello world: 140
 Hello world: 215
 Hello world: 99
 Hello world: 221
</code></pre>
<p>Because u8 is unsigned and can hold numbers between 0 and 255 (2⁸-1), this is the range that we get.</p>
<p>We can instead ask this library for a specific range:</p>
<pre><pre class="playground"><code class="language-rust edition2021"> use rand::Rng;


 fn main() {
   let mut rng = rand::thread_rng();
   let randnum: i64 = rng.gen_range(1..=100);
   println!(&quot;Hello world: {}&quot;, randnum);
 }
</code></pre></pre>
<p>In this case we need to create a random number generator object (rng). This will be holding the internal state of the random generator. It needs to be mutable because the state changes as each number is generated, so the numbers aren’t repeated every time.</p>
<p>The gen_range(1..=100) specifies which range of numbers to retrieve, like in a for loop, but in this case we only get a single number, randomly.</p>
<p>The “use rand::Rng” on the top is needed to access the gen_range method. This is what Rust calls a Trait. We will go over these later on.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="to-do-pieces-that-need-more-work"><a class="header" href="#to-do-pieces-that-need-more-work">To-do: pieces that need more work</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-are-those-other-data-types-for"><a class="header" href="#what-are-those-other-data-types-for">What are those other data types for?</a></h1>
<p>So we talked earlier about Rust data types and we’re just using a few. Why do they exist? Let’s put them together here:</p>
<table><thead><tr><th>Type</th><th>Min</th><th>Max</th><th></th><th>Type</th><th>Min</th><th>Max</th></tr></thead><tbody>
<tr><td>u8</td><td>0</td><td>255</td><td></td><td>i8</td><td>-128</td><td>127</td></tr>
<tr><td>u16</td><td>0</td><td>65535</td><td></td><td>i16</td><td>-32768</td><td>32767</td></tr>
<tr><td>u32</td><td>0</td><td>4294967296</td><td></td><td>i32</td><td>-2147483648</td><td>2147483647</td></tr>
<tr><td>u64</td><td>0</td><td>1.84 * 10^19</td><td></td><td>i64</td><td>-9.22 * 10^18</td><td>9.22 * 10^18</td></tr>
</tbody></table>
<p>Examples:</p>
<ul>
<li>u8 is generally used to represent characters in the ASCII table, and also bytes in a file in disk.</li>
<li>u16 is used for storing UTF16 characters, which are 2 byte long.</li>
<li>u32 can be used to store colors of pixels of an image (Red, Green, Blue and Alpha)</li>
</ul>
<p>While a single number might be small in comparison to the amount of memory a computer has, some programs are in fact “number crunching programs”, where millions or even billions of numbers need to be processed very fast. When you have so much data, compacting it on the smallest possible representation will save memory and/or disk space.</p>
<p>That is why, for what we’re doing in this guide we don’t care that much and use i64 for everything. All in all these are toy programs. Our toy programs don’t do much and the difference in memory used is roughly zero.</p>
<p>In real life, things are different. Say you want to read a JPG photo from your phone camera and do some process on it, like enhancing the photo. A photo can easily be 16 million pixels, and if for each pixel we use a i64 for each color (Red, Green and Blue), we would be wasting a lot of memory.</p>
<p>A program that plays chess by itself has to consider billions of chess possibilities, in this case it is also important to keep each representation as compact as possible.</p>
<p>On the other hand, there are also the two float types, f32 and f64. The difference between them is not the maximum or minimum number like integers, but the amount of significant digits they can carry. f32 can record 6 digits correctly (and a few extra ones) while f64 can record more than 12.</p>
<!-- in fact, f64 can represent bigger numbers than f32, but not that this does matter here... -->
<p>Floating point numbers are used specially on scientific problems. Depending on the problem at hand an f64 might be required, while in others f32 might be better as it has enough precision but it is smaller, allowing for much complex simulations.</p>
<p>Graphics cards use a lot of floating point numbers to draw scenes for a game. If the precision is not high enough it might lead to jitter: https://www.youtube.com/watch?v=jsLiDQyyBXk</p>
<p>I hope this helps understanding why these types exist, and why we aren’t using them for now.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-bit-more-detailed-explanation-on-functions"><a class="header" href="#a-bit-more-detailed-explanation-on-functions">A bit more detailed explanation on functions</a></h1>
<p>(….) (roughly explain a type, why the parentheses produce the call of the function, what happens if you forget the parentheses when calling, etc)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-a-garbage-collector"><a class="header" href="#what-is-a-garbage-collector">What is a Garbage Collector?</a></h1>
<p>It’s something that Rust doesn’t have. Have a good day!</p>
<p>Garbage Collector is about memory allocation. In C &amp; C++ memory needs to be manually requested and freed. Because this is very dangerous, most other languages automatically allocate and free.</p>
<p>Allocating is “easy”, as the first use is allocating. But automatic free is hard, because you need to ensure that no parts of the program can access that variable anymore.</p>
<p>So a Garbage Collector is a system that can track when variables go out of scope (unreachable) in order to free the memory. There are lots of types of GCs (each language might use a different approach), but they tend to have performance penalties, memory over-consumption and may temporarily halt all threads of the program to do the free.</p>
<ul>
<li>In Python, the GC prevents Python from running several threads of python code in parallel. So most python code, even if it uses threads, effectively is single-threaded because of the GC.</li>
<li>In Java, the GC tends to free memory very late, causing bloat, a lot of memory consumption.</li>
<li>In Go, the GC causes micro-pauses. All threads suddenly stop for a few milliseconds to clean up.</li>
<li>In Rust, there’s no GC. Instead the automatic free is computed at compile time (by static analysis). So no bloat, no performance penalty.</li>
<li>C &amp; C++, there’s no GC, you do it manually, and a mistake causes memory corruption and segfaults.</li>
</ul>
<p>Rust is kind of a compiler assisted C++. Automatic like Python, but if the compiler cannot prove your program is correct (even if the program in fact IS correct), it will reject it and won’t compile. </p>
<p>So the drawback from Rust approach is the added difficulty of learning Ownership &amp; Borrowing (which I talk about in my blog post)
….</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendices"><a class="header" href="#appendices">Appendices</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-a-license-of-this-book"><a class="header" href="#appendix-a-license-of-this-book">Appendix A. License of this book</a></h1>
<p>This text is licensed under the Creative Commons license “Attribution 4.0 International (CC BY 4.0)” which can be read here:</p>
<p>https://creativecommons.org/licenses/by/4.0/</p>
<p>https://creativecommons.org/licenses/by/4.0/legalcode</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-b-caveats-and-challenges-in-this-book"><a class="header" href="#appendix-b-caveats-and-challenges-in-this-book">Appendix B. Caveats and challenges in this book</a></h1>
<p>This book is intended to people with no previous experience in coding at all and attempts to teach programming in a very approachable way.</p>
<p>Because of this, a lot of information is hidden, misrepresented or factually incorrect. It is needed to hide and oversimplify stuff so new learners don’t get overloaded with information. This also helps the reader to create their own programs very early on without needing 
to have a proper understanding, which can come in later on.</p>
<p>Other books might put a lot of theory in front to give a good understanding of what is coming next, but theory is indeed boring until it’s put into use, so in this book I try to push down the theory as far as possible.</p>
<p>If this approach is good or bad it’s certainly subjective. But as everyone else goes for a more academic way, and there is almost no one that does something like I do in this book, I think it’s good to add more choices for learning.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-c-exercises-and-solutions"><a class="header" href="#appendix-c-exercises-and-solutions">Appendix C. Exercises and Solutions</a></h1>
<p>TODO: There should be some exercises for the reader and put the solutions here. Ideally, place the solutions in random order to avoid the reader from inadvertently reading the next solution to their problem. </p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
